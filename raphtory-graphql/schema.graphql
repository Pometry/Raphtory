"""
Alignment unit used to align window boundaries.
"""
enum AlignmentUnit {
	UNALIGNED
	MILLISECOND
	SECOND
	MINUTE
	HOUR
	DAY
	WEEK
	MONTH
	YEAR
}

enum AllPropertySpec {
	"""
	All properties and metadata.
	"""
	ALL
	"""
	All metadata.
	"""
	ALL_METADATA
	"""
	All properties.
	"""
	ALL_PROPERTIES
}

"""
Collection of items
"""
type CollectionOfMetaGraph {
	"""
	Returns a list of collection objects.
	"""
	list: [MetaGraph!]!
	"""
	Fetch one page with a number of items up to a specified limit, optionally offset by a specified amount. The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [MetaGraph!]!
	"""
	Returns a count of collection objects.
	"""
	count: Int!
}

"""
Collection of items
"""
type CollectionOfNamespace {
	"""
	Returns a list of collection objects.
	"""
	list: [Namespace!]!
	"""
	Fetch one page with a number of items up to a specified limit, optionally offset by a specified amount. The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [Namespace!]!
	"""
	Returns a count of collection objects.
	"""
	count: Int!
}

"""
Collection of items
"""
type CollectionOfNamespacedItem {
	"""
	Returns a list of collection objects.
	"""
	list: [NamespacedItem!]!
	"""
	Fetch one page with a number of items up to a specified limit, optionally offset by a specified amount. The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [NamespacedItem!]!
	"""
	Returns a count of collection objects.
	"""
	count: Int!
}

"""
Document in a vector graph
"""
type Document {
	"""
	Entity associated with document.
	"""
	entity: DocumentEntity!
	"""
	Content of the document.
	"""
	content: String!
	"""
	Similarity score with a specified query
	"""
	embedding: [Float!]!
	score: Float!
}

"""
Entity associated with document.
"""
union DocumentEntity = Node | Edge

"""
Raphtory graph edge.
"""
type Edge {
	"""
	Return a view of Edge containing only the default edge layer.
	"""
	defaultLayer: Edge!
	"""
	Returns a view of Edge containing all layers in the list of names.
	
	Errors if any of the layers do not exist.
	"""
	layers(names: [String!]!): Edge!
	"""
	Returns a view of Edge containing all layers except the excluded list of names.
	
	Errors if any of the layers do not exist.
	"""
	excludeLayers(names: [String!]!): Edge!
	"""
	Returns a view of Edge containing the specified layer.
	
	Errors if any of the layers do not exist.
	"""
	layer(name: String!): Edge!
	"""
	Returns a view of Edge containing all layers except the excluded layer specified.
	
	Errors if any of the layers do not exist.
	"""
	excludeLayer(name: String!): Edge!
	"""
	Creates a WindowSet with the given window duration and optional step using a rolling window.
	
	A rolling window is a window that moves forward by step size at each iteration.
	
	alignment_unit optionally aligns the windows to the specified unit. "Unaligned" can be passed for no alignment.
	If unspecified (i.e. by default), alignment is done on the smallest unit of time in the step (or window if no step is passed).
	e.g. "1 month and 1 day" will align at the start of the day.
	Note that passing a step larger than window while alignment_unit is not "Unaligned" may lead to some entries appearing before
	the start of the first window and/or after the end of the last window (i.e. not included in any window).
	"""
	rolling(window: WindowDuration!, step: WindowDuration, alignmentUnit: AlignmentUnit): EdgeWindowSet!
	"""
	Creates a WindowSet with the given step size using an expanding window.
	
	An expanding window is a window that grows by step size at each iteration.
	
	alignment_unit optionally aligns the windows to the specified unit. "Unaligned" can be passed for no alignment.
	If unspecified (i.e. by default), alignment is done on the smallest unit of time in the step.
	e.g. "1 month and 1 day" will align at the start of the day.
	"""
	expanding(step: WindowDuration!, alignmentUnit: AlignmentUnit): EdgeWindowSet!
	"""
	Creates a view of the Edge including all events between the specified start (inclusive) and end (exclusive).
	
	For persistent graphs, any edge which exists at any point during the window will be included. You may want to restrict this to only edges that are present at the end of the window using the is_valid function.
	"""
	window(start: TimeInput!, end: TimeInput!): Edge!
	"""
	Creates a view of the Edge including all events at a specified time.
	"""
	at(time: TimeInput!): Edge!
	"""
	Returns a view of the edge at the latest time of the graph.
	"""
	latest: Edge!
	"""
	Creates a view of the Edge including all events that are valid at time.
	
	This is equivalent to before(time + 1) for Graph and at(time) for PersistentGraph.
	"""
	snapshotAt(time: TimeInput!): Edge!
	"""
	Creates a view of the Edge including all events that are valid at the latest time.
	
	This is equivalent to a no-op for Graph and latest() for PersistentGraph.
	"""
	snapshotLatest: Edge!
	"""
	Creates a view of the Edge including all events before a specified end (exclusive).
	"""
	before(time: TimeInput!): Edge!
	"""
	Creates a view of the Edge including all events after a specified start (exclusive).
	"""
	after(time: TimeInput!): Edge!
	"""
	Shrinks both the start and end of the window.
	"""
	shrinkWindow(start: TimeInput!, end: TimeInput!): Edge!
	"""
	Set the start of the window.
	"""
	shrinkStart(start: TimeInput!): Edge!
	"""
	Set the end of the window.
	"""
	shrinkEnd(end: TimeInput!): Edge!
	"""
	Takes a specified selection of views and applies them in given order.
	"""
	applyViews(views: [EdgeViewCollection!]!): Edge!
	"""
	Returns the earliest time of an edge.
	"""
	earliestTime: EventTime!
	firstUpdate: EventTime!
	"""
	Returns the latest time of an edge.
	"""
	latestTime: EventTime!
	lastUpdate: EventTime!
	"""
	Returns the time of an exploded edge. Errors on an unexploded edge.
	"""
	time: EventTime!
	"""
	Returns the start time for rolling and expanding windows for this edge. Returns none if no window is applied.
	"""
	start: EventTime!
	"""
	Returns the end time of the window. Returns none if no window is applied.
	"""
	end: EventTime!
	"""
	Returns the source node of the edge.
	
	Returns:
	Node:
	"""
	src: Node!
	"""
	Returns the destination node of the edge.
	
	Returns:
	Node:
	"""
	dst: Node!
	"""
	Returns the node at the other end of the edge (same as dst() for out-edges and src() for in-edges).
	
	Returns:
	Node:
	"""
	nbr: Node!
	"""
	Returns the id of the edge.
	
	Returns:
	list[str]:
	"""
	id: [String!]!
	"""
	Returns a view of the properties of the edge.
	"""
	properties: Properties!
	"""
	Returns the metadata of an edge.
	"""
	metadata: Metadata!
	"""
	Returns the names of the layers that have this edge as a member.
	"""
	layerNames: [String!]!
	"""
	Returns the layer name of an exploded edge, errors on an edge.
	"""
	layerName: String!
	"""
	Returns an edge object for each update within the original edge.
	"""
	explode: Edges!
	"""
	Returns an edge object for each layer within the original edge.
	
	Each new edge object contains only updates from the respective layers.
	"""
	explodeLayers: Edges!
	"""
	Returns a History object with time entries for when an edge is added or change to an edge is made.
	
	Returns:
	History:
	"""
	history: History!
	"""
	Returns a history object with time entries for an edge's deletion times.
	
	Returns:
	History:
	"""
	deletions: History!
	"""
	Checks if the edge is currently valid and exists at the current time.
	
	Returns: boolean
	"""
	isValid: Boolean!
	"""
	Checks if the edge is currently active and has at least one update within the current period.
	
	Returns: boolean
	"""
	isActive: Boolean!
	"""
	Checks if the edge is deleted at the current time.
	
	Returns: boolean
	"""
	isDeleted: Boolean!
	"""
	Returns true if the edge source and destination nodes are the same.
	
	Returns: boolean
	"""
	isSelfLoop: Boolean!
	filter(expr: EdgeFilter!): Edge!
}

input EdgeAddition {
	"""
	Source node.
	"""
	src: String!
	"""
	Destination node.
	"""
	dst: String!
	"""
	Layer.
	"""
	layer: String
	"""
	Metadata.
	"""
	metadata: [PropertyInput!]
	updates: [TemporalPropertyInput!]
}

"""
GraphQL input type for filtering edges.

`EdgeFilter` represents a composable boolean expression evaluated
against edges in a graph. Filters can target:

- edge **endpoints** (source / destination nodes),
- edge **properties** and **metadata**,
- **temporal scope** (windows, snapshots, latest),
- **layer membership**,
- and **structural edge state** (active, valid, deleted, self-loop).

Filters can be combined recursively using logical operators
(`And`, `Or`, `Not`).

Examples (GraphQL):
```graphql
{
edges(filter: {
And: [
{ IsActive: true },
{ Property: { name: "weight", gt: 0.5 } }
]
}) {
src
dst
}
}
```
"""
input EdgeFilter @oneOf {
	"""
	Applies a filter to the **source node** of the edge.
	
	The nested `NodeFilter` is evaluated against the source endpoint.
	
	Example:
	`{ Src: { Name: { contains: "alice" } } }`
	"""
	src: NodeFilter
	"""
	Applies a filter to the **destination node** of the edge.
	
	The nested `NodeFilter` is evaluated against the destination endpoint.
	
	Example:
	`{ Dst: { Id: { eq: 42 } } }`
	"""
	dst: NodeFilter
	"""
	Filters an edge **property** by name and value.
	
	Applies to static or temporal properties depending on context.
	
	Example:
	`{ Property: { name: "weight", gt: 0.5 } }`
	"""
	property: PropertyFilterNew
	"""
	Filters an edge **metadata field**.
	
	Metadata is shared across all temporal versions of an edge.
	
	Example:
	`{ Metadata: { name: "source", eq: "imported" } }`
	"""
	metadata: PropertyFilterNew
	"""
	Filters a **temporal edge property**.
	
	Used when the property value varies over time and must be
	evaluated within a temporal context.
	
	Example:
	`{ TemporalProperty: { name: "status", eq: "active" } }`
	"""
	temporalProperty: PropertyFilterNew
	"""
	Logical **AND** over multiple edge filters.
	
	All nested filters must evaluate to `true`.
	
	Example:
	`{ And: [ { IsActive: true }, { IsValid: true } ] }`
	"""
	and: [EdgeFilter!]
	"""
	Logical **OR** over multiple edge filters.
	
	At least one nested filter must evaluate to `true`.
	
	Example:
	`{ Or: [ { IsDeleted: true }, { IsSelfLoop: true } ] }`
	"""
	or: [EdgeFilter!]
	"""
	Logical **NOT** over a nested edge filter.
	
	Negates the result of the wrapped filter.
	
	Example:
	`{ Not: { IsDeleted: true } }`
	"""
	not: EdgeFilter
	"""
	Restricts edge evaluation to a **time window**.
	
	The window is inclusive of `start` and exclusive of `end`.
	"""
	window: EdgeWindowExpr
	"""
	Restricts edge evaluation to a **single point in time**.
	"""
	at: EdgeTimeExpr
	"""
	Restricts edge evaluation to times **strictly before** a given time.
	"""
	before: EdgeTimeExpr
	"""
	Restricts edge evaluation to times **strictly after** a given time.
	"""
	after: EdgeTimeExpr
	"""
	Evaluates edge predicates against the **latest available state**.
	"""
	latest: EdgeUnaryExpr
	"""
	Evaluates edge predicates against a **snapshot** of the graph
	at a specific time.
	"""
	snapshotAt: EdgeTimeExpr
	"""
	Evaluates edge predicates against the **most recent snapshot**
	of the graph.
	"""
	snapshotLatest: EdgeUnaryExpr
	"""
	Restricts evaluation to edges belonging to one or more **layers**.
	
	Example:
	`{ Layers: { values: ["fire_nation", "air_nomads"] } }`
	"""
	layers: EdgeLayersExpr
	"""
	Matches edges that have at least one event in the current view/window.
	
	When `true`, only active edges are matched.
	"""
	isActive: Boolean
	"""
	Matches edges that are structurally valid (i.e. not deleted)
	in the current view/window.
	"""
	isValid: Boolean
	"""
	Matches edges that have been deleted in the current view/window.
	"""
	isDeleted: Boolean
	"""
	Matches edges that are **self-loops**
	(source node == destination node).
	"""
	isSelfLoop: Boolean
}

"""
Restricts edge evaluation to one or more layers and applies a nested `EdgeFilter`.

Used by `GqlEdgeFilter::Layers`.
"""
input EdgeLayersExpr {
	"""
	Layer names to include.
	"""
	names: [String!]!
	"""
	Filter evaluated within the layer-restricted view.
	"""
	expr: EdgeFilter!
}

type EdgeSchema {
	"""
	Returns the type of source for these edges
	"""
	srcType: String!
	"""
	Returns the type of destination for these edges
	"""
	dstType: String!
	"""
	Returns the list of property schemas for edges connecting these types of nodes
	"""
	properties: [PropertySchema!]!
	"""
	Returns the list of metadata schemas for edges connecting these types of nodes
	"""
	metadata: [PropertySchema!]!
}

input EdgeSortBy {
	"""
	Reverse order
	"""
	reverse: Boolean
	"""
	Source node
	"""
	src: Boolean
	"""
	Destination
	"""
	dst: Boolean
	"""
	Time
	"""
	time: SortByTime
	"""
	Property
	"""
	property: String
}

"""
Restricts edge evaluation to a single time bound and applies a nested `EdgeFilter`.

Used by `At`, `Before`, and `After` edge filters.
"""
input EdgeTimeExpr {
	"""
	Reference time for the operation.
	"""
	time: TimeInput!
	"""
	Filter evaluated within the restricted time scope.
	"""
	expr: EdgeFilter!
}

"""
Applies a unary edge-view operation and then evaluates a nested `EdgeFilter`.

Used by `Latest` and `SnapshotLatest` edge filters.
"""
input EdgeUnaryExpr {
	"""
	Filter evaluated after applying the unary operation.
	"""
	expr: EdgeFilter!
}

input EdgeViewCollection @oneOf {
	"""
	Contains only the default layer.
	"""
	defaultLayer: Boolean
	"""
	Latest time.
	"""
	latest: Boolean
	"""
	Snapshot at latest time.
	"""
	snapshotLatest: Boolean
	"""
	Snapshot at specified time.
	"""
	snapshotAt: TimeInput
	"""
	List of included layers.
	"""
	layers: [String!]
	"""
	List of excluded layers.
	"""
	excludeLayers: [String!]
	"""
	Single excluded layer.
	"""
	excludeLayer: String
	"""
	Window between a start and end time.
	"""
	window: Window
	"""
	View at a specified time.
	"""
	at: TimeInput
	"""
	View before a specified time (end exclusive).
	"""
	before: TimeInput
	"""
	View after a specified time (start exclusive).
	"""
	after: TimeInput
	"""
	Shrink a Window to a specified start and end time.
	"""
	shrinkWindow: Window
	"""
	Set the window start to a specified time.
	"""
	shrinkStart: TimeInput
	"""
	Set the window end to a specified time.
	"""
	shrinkEnd: TimeInput
	"""
	Edge filter
	"""
	edgeFilter: EdgeFilter
}

"""
Restricts edge evaluation to a time window and applies a nested `EdgeFilter`.

Used by `GqlEdgeFilter::Window`.

The window is inclusive of `start` and exclusive of `end`.
"""
input EdgeWindowExpr {
	"""
	Window start time (inclusive).
	"""
	start: TimeInput!
	"""
	Window end time (exclusive).
	"""
	end: TimeInput!
	"""
	Filter evaluated within the restricted window.
	"""
	expr: EdgeFilter!
}

type EdgeWindowSet {
	count: Int!
	"""
	Fetch one page with a number of items up to a specified limit, optionally offset by a specified amount.
	The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [Edge!]!
	list: [Edge!]!
}

type Edges {
	"""
	Returns a collection containing only edges in the default edge layer.
	"""
	defaultLayer: Edges!
	"""
	Returns a collection containing only edges belonging to the listed layers.
	"""
	layers(names: [String!]!): Edges!
	"""
	Returns a collection containing edges belonging to all layers except the excluded list of layers.
	"""
	excludeLayers(names: [String!]!): Edges!
	"""
	Returns a collection containing edges belonging to the specified layer.
	"""
	layer(name: String!): Edges!
	"""
	Returns a collection containing edges belonging to all layers except the excluded layer specified.
	"""
	excludeLayer(name: String!): Edges!
	"""
	Creates a WindowSet with the given window duration and optional step using a rolling window. A rolling window is a window that moves forward by step size at each iteration.
	
	Returns a collection of collections. This means that item in the window set is a collection of edges.
	
	alignment_unit optionally aligns the windows to the specified unit. "Unaligned" can be passed for no alignment.
	If unspecified (i.e. by default), alignment is done on the smallest unit of time in the step (or window if no step is passed).
	e.g. "1 month and 1 day" will align at the start of the day.
	Note that passing a step larger than window while alignment_unit is not "Unaligned" may lead to some entries appearing before
	the start of the first window and/or after the end of the last window (i.e. not included in any window).
	"""
	rolling(window: WindowDuration!, step: WindowDuration, alignmentUnit: AlignmentUnit): EdgesWindowSet!
	"""
	Creates a WindowSet with the given step size using an expanding window. An expanding window is a window that grows by step size at each iteration.
	
	Returns a collection of collections. This means that item in the window set is a collection of edges.
	
	alignment_unit optionally aligns the windows to the specified unit. "Unaligned" can be passed for no alignment.
	If unspecified (i.e. by default), alignment is done on the smallest unit of time in the step.
	e.g. "1 month and 1 day" will align at the start of the day.
	"""
	expanding(step: WindowDuration!, alignmentUnit: AlignmentUnit): EdgesWindowSet!
	"""
	Creates a view of the Edge including all events between the specified start (inclusive) and end (exclusive).
	"""
	window(start: TimeInput!, end: TimeInput!): Edges!
	"""
	Creates a view of the Edge including all events at a specified time.
	"""
	at(time: TimeInput!): Edges!
	latest: Edges!
	"""
	Creates a view of the Edge including all events that are valid at time. This is equivalent to before(time + 1) for Graph and at(time) for PersistentGraph.
	"""
	snapshotAt(time: TimeInput!): Edges!
	"""
	Creates a view of the Edge including all events that are valid at the latest time. This is equivalent to a no-op for Graph and latest() for PersistentGraph.
	"""
	snapshotLatest: Edges!
	"""
	Creates a view of the Edge including all events before a specified end (exclusive).
	"""
	before(time: TimeInput!): Edges!
	"""
	Creates a view of the Edge including all events after a specified start (exclusive).
	"""
	after(time: TimeInput!): Edges!
	"""
	Shrinks both the start and end of the window.
	"""
	shrinkWindow(start: TimeInput!, end: TimeInput!): Edges!
	"""
	Set the start of the window.
	"""
	shrinkStart(start: TimeInput!): Edges!
	"""
	Set the end of the window.
	"""
	shrinkEnd(end: TimeInput!): Edges!
	"""
	Takes a specified selection of views and applies them in order given.
	"""
	applyViews(views: [EdgesViewCollection!]!): Edges!
	"""
	Returns an edge object for each update within the original edge.
	"""
	explode: Edges!
	"""
	Returns an edge object for each layer within the original edge.
	
	Each new edge object contains only updates from the respective layers.
	"""
	explodeLayers: Edges!
	"""
	Specify a sort order from: source, destination, property, time. You can also reverse the ordering.
	"""
	sorted(sortBys: [EdgeSortBy!]!): Edges!
	"""
	Returns the start time of the window or none if there is no window.
	"""
	start: EventTime!
	"""
	Returns the end time of the window or none if there is no window.
	"""
	end: EventTime!
	"""
	Returns the number of edges.
	
	Returns:
	int:
	"""
	count: Int!
	"""
	Fetch one page with a number of items up to a specified limit, optionally offset by a specified amount.
	The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [Edge!]!
	"""
	Returns a list of all objects in the current selection of the collection. You should filter the collection first then call list.
	"""
	list: [Edge!]!
	"""
	Returns a filtered view that applies to list down the chain
	"""
	filter(expr: EdgeFilter!): Edges!
	"""
	Returns filtered list of edges
	"""
	select(expr: EdgeFilter!): Edges!
}

input EdgesViewCollection @oneOf {
	"""
	Contains only the default layer.
	"""
	defaultLayer: Boolean
	"""
	Latest time.
	"""
	latest: Boolean
	"""
	Snapshot at latest time.
	"""
	snapshotLatest: Boolean
	"""
	Snapshot at specified time.
	"""
	snapshotAt: TimeInput
	"""
	List of included layers.
	"""
	layers: [String!]
	"""
	List of excluded layers.
	"""
	excludeLayers: [String!]
	"""
	Single excluded layer.
	"""
	excludeLayer: String
	"""
	Window between a start and end time.
	"""
	window: Window
	"""
	View at a specified time.
	"""
	at: TimeInput
	"""
	View before a specified time (end exclusive).
	"""
	before: TimeInput
	"""
	View after a specified time (start exclusive).
	"""
	after: TimeInput
	"""
	Shrink a Window to a specified start and end time.
	"""
	shrinkWindow: Window
	"""
	Set the window start to a specified time.
	"""
	shrinkStart: TimeInput
	"""
	Set the window end to a specified time.
	"""
	shrinkEnd: TimeInput
	"""
	Edge filter
	"""
	edgeFilter: EdgeFilter
}

type EdgesWindowSet {
	count: Int!
	"""
	Fetch one page with a number of items up to a specified limit, optionally offset by a specified amount.
	The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [Edges!]!
	list: [Edges!]!
}

"""
Raphtory’s EventTime.
Represents a unique timepoint in the graph’s history as (timestamp, event_id).

- timestamp: Number of milliseconds since the Unix epoch.
- event_id: ID used for ordering between equal timestamps.

Instances of EventTime may or may not contain time information.
This is relevant for functions that may not return data (such as earliest_time and latest_time) because the data is unavailable.
When empty, time operations (such as timestamp, datetime, and event_id) will return None.
"""
type EventTime {
	"""
	Get the timestamp in milliseconds since the Unix epoch.
	"""
	timestamp: Int
	"""
	Get the event id for the EventTime. Used for ordering within the same timestamp.
	"""
	eventId: Int
	"""
	Access a datetime representation of the EventTime as a String.
	Useful for converting millisecond timestamps into easily readable datetime strings.
	Optionally, a format string can be passed to format the output.
	Defaults to RFC 3339 if not provided (e.g., "2023-12-25T10:30:45.123Z").
	Refer to chrono::format::strftime for formatting specifiers and escape sequences.
	Raises an error if a time conversion fails.
	"""
	datetime(formatString: String): String
}

type Graph {
	"""
	Returns the names of all layers in the graphview.
	"""
	uniqueLayers: [String!]!
	"""
	Returns a view containing only the default layer.
	"""
	defaultLayer: Graph!
	"""
	Returns a view containing all the specified layers.
	"""
	layers(names: [String!]!): Graph!
	"""
	Returns a view containing all layers except the specified excluded layers.
	"""
	excludeLayers(names: [String!]!): Graph!
	"""
	Returns a view containing the layer specified.
	"""
	layer(name: String!): Graph!
	"""
	Returns a view containing all layers except the specified excluded layer.
	"""
	excludeLayer(name: String!): Graph!
	"""
	Returns a subgraph of a specified set of nodes which contains only the edges that connect nodes of the subgraph to each other.
	"""
	subgraph(nodes: [String!]!): Graph!
	"""
	Returns a view of the graph that only includes valid edges.
	"""
	valid: Graph!
	"""
	Returns a subgraph filtered by the specified node types.
	"""
	subgraphNodeTypes(nodeTypes: [String!]!): Graph!
	"""
	Returns a subgraph containing all nodes except the specified excluded nodes.
	"""
	excludeNodes(nodes: [String!]!): Graph!
	"""
	Creates a rolling window with the specified window size and an optional step.
	
	A rolling window is a window that moves forward by step size at each iteration.
	
	alignment_unit optionally aligns the windows to the specified unit. "Unaligned" can be passed for no alignment.
	If unspecified (i.e. by default), alignment is done on the smallest unit of time in the step (or window if no step is passed).
	e.g. "1 month and 1 day" will align at the start of the day.
	Note that passing a step larger than window while alignment_unit is not "Unaligned" may lead to some entries appearing before
	the start of the first window and/or after the end of the last window (i.e. not included in any window).
	"""
	rolling(window: WindowDuration!, step: WindowDuration, alignmentUnit: AlignmentUnit): GraphWindowSet!
	"""
	Creates an expanding window with the specified step size.
	
	An expanding window is a window that grows by step size at each iteration.
	
	alignment_unit optionally aligns the windows to the specified unit. "Unaligned" can be passed for no alignment.
	If unspecified (i.e. by default), alignment is done on the smallest unit of time in the step.
	e.g. "1 month and 1 day" will align at the start of the day.
	"""
	expanding(step: WindowDuration!, alignmentUnit: AlignmentUnit): GraphWindowSet!
	"""
	Return a graph containing only the activity between start and end, by default raphtory stores times in milliseconds from the unix epoch.
	"""
	window(start: TimeInput!, end: TimeInput!): Graph!
	"""
	Creates a view including all events at a specified time.
	"""
	at(time: TimeInput!): Graph!
	"""
	Creates a view including all events at the latest time.
	"""
	latest: Graph!
	"""
	Create a view including all events that are valid at the specified time.
	"""
	snapshotAt(time: TimeInput!): Graph!
	"""
	Create a view including all events that are valid at the latest time.
	"""
	snapshotLatest: Graph!
	"""
	Create a view including all events before a specified end (exclusive).
	"""
	before(time: TimeInput!): Graph!
	"""
	Create a view including all events after a specified start (exclusive).
	"""
	after(time: TimeInput!): Graph!
	"""
	Shrink both the start and end of the window.
	"""
	shrinkWindow(start: TimeInput!, end: TimeInput!): Graph!
	"""
	Set the start of the window to the larger of the specified value or current start.
	"""
	shrinkStart(start: TimeInput!): Graph!
	"""
	Set the end of the window to the smaller of the specified value or current end.
	"""
	shrinkEnd(end: TimeInput!): Graph!
	"""
	Returns the timestamp for the creation of the graph.
	"""
	created: Int!
	"""
	Returns the graph's last opened timestamp according to system time.
	"""
	lastOpened: Int!
	"""
	Returns the graph's last updated timestamp.
	"""
	lastUpdated: Int!
	"""
	Returns the time entry of the earliest activity in the graph.
	"""
	earliestTime: EventTime!
	"""
	Returns the time entry of the latest activity in the graph.
	"""
	latestTime: EventTime!
	"""
	Returns the start time of the window. Errors if there is no window.
	"""
	start: EventTime!
	"""
	Returns the end time of the window. Errors if there is no window.
	"""
	end: EventTime!
	"""
	Returns the earliest time that any edge in this graph is valid.
	"""
	earliestEdgeTime(includeNegative: Boolean): EventTime!
	"""
	Returns the latest time that any edge in this graph is valid.
	"""
	latestEdgeTime(includeNegative: Boolean): EventTime!
	"""
	Returns the number of edges in the graph.
	
	Returns:
	int:
	"""
	countEdges: Int!
	"""
	Returns the number of temporal edges in the graph.
	"""
	countTemporalEdges: Int!
	"""
	Returns the number of nodes in the graph.
	
	Optionally takes a list of node ids to return a subset.
	"""
	countNodes: Int!
	"""
	Returns true if the graph contains the specified node.
	"""
	hasNode(name: String!): Boolean!
	"""
	Returns true if the graph contains the specified edge. Edges are specified by providing a source and destination node id. You can restrict the search to a specified layer.
	"""
	hasEdge(src: String!, dst: String!, layer: String): Boolean!
	"""
	Gets the node with the specified id.
	"""
	node(name: String!): Node
	"""
	Gets (optionally a subset of) the nodes in the graph.
	"""
	nodes(select: NodeFilter): Nodes!
	"""
	Gets the edge with the specified source and destination nodes.
	"""
	edge(src: String!, dst: String!): Edge
	"""
	Gets the edges in the graph.
	"""
	edges(select: EdgeFilter): Edges!
	"""
	Returns the properties of the graph.
	"""
	properties: Properties!
	"""
	Returns the metadata of the graph.
	"""
	metadata: Metadata!
	"""
	Returns the graph name.
	"""
	name: String!
	"""
	Returns path of graph.
	"""
	path: String!
	"""
	Returns namespace of graph.
	"""
	namespace: String!
	"""
	Returns the graph schema.
	"""
	schema: GraphSchema!
	algorithms: GraphAlgorithmPlugin!
	sharedNeighbours(selectedNodes: [String!]!): [Node!]!
	"""
	Export all nodes and edges from this graph view to another existing graph
	"""
	exportTo(path: String!): Boolean!
	filter(expr: GraphFilter): Graph!
	filterNodes(expr: NodeFilter!): Graph!
	filterEdges(expr: EdgeFilter!): Graph!
	"""
	(Experimental) Get index specification.
	"""
	getIndexSpec: IndexSpec!
	"""
	(Experimental) Searches for nodes which match the given filter expression.
	
	Uses Tantivy's exact search.
	"""
	searchNodes(filter: NodeFilter!, limit: Int!, offset: Int!): [Node!]!
	"""
	(Experimental) Searches the index for edges which match the given filter expression.
	
	Uses Tantivy's exact search.
	"""
	searchEdges(filter: EdgeFilter!, limit: Int!, offset: Int!): [Edge!]!
	"""
	Returns the specified graph view or if none is specified returns the default view.
	This allows you to specify multiple operations together.
	"""
	applyViews(views: [GraphViewCollection!]!): Graph!
}

type GraphAlgorithmPlugin {
	pagerank(iterCount: Int!, threads: Int, tol: Float): [PagerankOutput!]!
	shortest_path(source: String!, targets: [String!]!, direction: String): [ShortestPathOutput!]!
}

"""
GraphQL input type for restricting a graph view.

`GraphFilter` controls the **evaluation scope** for subsequent node/edge filters:
- time windows (`Window`)
- time points (`At`)
- open-ended ranges (`Before`, `After`)
- latest evaluation (`Latest`)
- snapshots (`SnapshotAt`, `SnapshotLatest`)
- layer membership (`Layers`)

These filters can be nested via the `expr` field on the corresponding
`*Expr` input objects to form pipelines.
"""
input GraphFilter @oneOf {
	"""
	Restrict evaluation to a time window (inclusive start, exclusive end).
	"""
	window: GraphWindowExpr
	"""
	Restrict evaluation to a single point in time.
	"""
	at: GraphTimeExpr
	"""
	Restrict evaluation to times strictly before the given time.
	"""
	before: GraphTimeExpr
	"""
	Restrict evaluation to times strictly after the given time.
	"""
	after: GraphTimeExpr
	"""
	Evaluate against the latest available state.
	"""
	latest: GraphUnaryExpr
	"""
	Evaluate against a snapshot of the graph at a given time.
	"""
	snapshotAt: GraphTimeExpr
	"""
	Evaluate against the most recent snapshot of the graph.
	"""
	snapshotLatest: GraphUnaryExpr
	"""
	Restrict evaluation to one or more layers.
	"""
	layers: GraphLayersExpr
}

"""
Graph view restriction by layer membership, optionally chaining another `GraphFilter`.

Used by `GqlGraphFilter::Layers`.
"""
input GraphLayersExpr {
	"""
	Layer names to include.
	"""
	names: [String!]!
	"""
	Optional nested filter applied after the layer restriction.
	"""
	expr: GraphFilter
}

type GraphSchema {
	nodes: [NodeSchema!]!
	layers: [LayerSchema!]!
}

"""
Graph view restriction to a single time bound, optionally chaining another `GraphFilter`.

Used by `At`, `Before`, and `After` graph filters.

Example:
`{ At: { time: 5, expr: { Layers: { names: ["L1"] } } } }`
"""
input GraphTimeExpr {
	"""
	Reference time for the operation.
	"""
	time: TimeInput!
	"""
	Optional nested filter applied after the time restriction.
	"""
	expr: GraphFilter
}

enum GraphType {
	"""
	Persistent.
	"""
	PERSISTENT
	"""
	Event.
	"""
	EVENT
}

"""
Graph view restriction that takes only a nested expression.

Used for unary view operations like `Latest` and `SnapshotLatest`.
"""
input GraphUnaryExpr {
	"""
	Optional nested filter applied after the unary operation.
	"""
	expr: GraphFilter
}

input GraphViewCollection @oneOf {
	"""
	Contains only the default layer.
	"""
	defaultLayer: Boolean
	"""
	List of included layers.
	"""
	layers: [String!]
	"""
	List of excluded layers.
	"""
	excludeLayers: [String!]
	"""
	Single excluded layer.
	"""
	excludeLayer: String
	"""
	Subgraph nodes.
	"""
	subgraph: [String!]
	"""
	Subgraph node types.
	"""
	subgraphNodeTypes: [String!]
	"""
	List of excluded nodes.
	"""
	excludeNodes: [String!]
	"""
	Valid state.
	"""
	valid: Boolean
	"""
	Window between a start and end time.
	"""
	window: Window
	"""
	View at a specified time.
	"""
	at: TimeInput
	"""
	View at the latest time.
	"""
	latest: Boolean
	"""
	Snapshot at specified time.
	"""
	snapshotAt: TimeInput
	"""
	Snapshot at latest time.
	"""
	snapshotLatest: Boolean
	"""
	View before a specified time (end exclusive).
	"""
	before: TimeInput
	"""
	View after a specified time (start exclusive).
	"""
	after: TimeInput
	"""
	Shrink a Window to a specified start and end time.
	"""
	shrinkWindow: Window
	"""
	Set the window start to a specified time.
	"""
	shrinkStart: TimeInput
	"""
	Set the window end to a specified time.
	"""
	shrinkEnd: TimeInput
	"""
	Node filter.
	"""
	nodeFilter: NodeFilter
	"""
	Edge filter.
	"""
	edgeFilter: EdgeFilter
}

"""
Graph view restriction to a time window, optionally chaining another `GraphFilter`.

Used by `GqlGraphFilter::Window`.

- `start` and `end` define the window (inclusive start, exclusive end).
- `expr` optionally nests another graph filter to apply *within* this window.

Example (GraphQL):
```graphql
{ Window: { start: 0, end: 10, expr: { Layers: { names: ["A"] } } } }
```
"""
input GraphWindowExpr {
	"""
	Window start time (inclusive).
	"""
	start: TimeInput!
	"""
	Window end time (exclusive).
	"""
	end: TimeInput!
	"""
	Optional nested filter applied after the window restriction.
	"""
	expr: GraphFilter
}

type GraphWindowSet {
	"""
	Returns the number of items.
	"""
	count: Int!
	"""
	Fetch one page with a number of items up to a specified limit, optionally offset by a specified amount.
	The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [Graph!]!
	list: [Graph!]!
}

"""
History of updates for an object in Raphtory.
Provides access to temporal properties.
"""
type History {
	"""
	Get the earliest time entry associated with this history or None if the history is empty.
	"""
	earliestTime: EventTime!
	"""
	Get the latest time entry associated with this history or None if the history is empty.
	"""
	latestTime: EventTime!
	"""
	List all time entries present in this history.
	"""
	list: [EventTime!]!
	"""
	List all time entries present in this history in reverse order.
	"""
	listRev: [EventTime!]!
	"""
	Fetch one page of EventTime entries with a number of items up to a specified limit,
	optionally offset by a specified amount. The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [EventTime!]!
	"""
	Fetch one page of EventTime entries with a number of items up to a specified limit,
	optionally offset by a specified amount. The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page_rev(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	pageRev(limit: Int!, offset: Int, pageIndex: Int): [EventTime!]!
	"""
	Returns True if the history is empty.
	"""
	isEmpty: Boolean!
	"""
	Get the number of entries contained in the history.
	"""
	count: Int!
	"""
	Returns a HistoryTimestamp object which accesses timestamps (milliseconds since the Unix epoch)
	instead of EventTime entries.
	"""
	timestamps: HistoryTimestamp!
	"""
	Returns a HistoryDateTime object which accesses datetimes instead of EventTime entries.
	Useful for converting millisecond timestamps into easily readable datetime strings.
	Optionally, a format string can be passed to format the output. Defaults to RFC 3339 if not provided (e.g., "2023-12-25T10:30:45.123Z").
	Refer to chrono::format::strftime for formatting specifiers and escape sequences.
	"""
	datetimes(formatString: String): HistoryDateTime!
	"""
	Returns a HistoryEventId object which accesses event ids of EventTime entries.
	They are used for ordering within the same timestamp.
	"""
	eventId: HistoryEventId!
	"""
	Returns an Intervals object which calculates the intervals between consecutive EventTime timestamps.
	"""
	intervals: Intervals!
}

"""
History object that provides access to datetimes instead of `EventTime` entries.
"""
type HistoryDateTime {
	"""
	List all datetimes formatted as strings.
	If filter_broken is set to True, time conversion errors will be ignored. If set to False, a TimeError
	will be raised on time conversion error. Defaults to False.
	"""
	list(filterBroken: Boolean): [String!]!
	"""
	List all datetimes formatted as strings in reverse chronological order.
	If filter_broken is set to True, time conversion errors will be ignored. If set to False, a TimeError
	will be raised on time conversion error. Defaults to False.
	"""
	listRev(filterBroken: Boolean): [String!]!
	"""
	Fetch one page of datetimes formatted as string with a number of items up to a specified limit,
	optionally offset by a specified amount. The page_index sets the number of pages to skip (defaults to 0).
	If filter_broken is set to True, time conversion errors will be ignored. If set to False, a TimeError
	will be raised on time conversion error. Defaults to False.
	
	For example, if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int, filterBroken: Boolean): [String!]!
	"""
	Fetch one page of datetimes formatted as string in reverse chronological order with a number of items up to a specified limit,
	optionally offset by a specified amount. The page_index sets the number of pages to skip (defaults to 0).
	If filter_broken is set to True, time conversion errors will be ignored. If set to False, a TimeError
	will be raised on time conversion error. Defaults to False.
	
	For example, if page_rev(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	pageRev(limit: Int!, offset: Int, pageIndex: Int, filterBroken: Boolean): [String!]!
}

"""
History object that provides access to event ids instead of `EventTime` entries.
"""
type HistoryEventId {
	"""
	List event ids.
	"""
	list: [Int!]!
	"""
	List event ids in reverse order.
	"""
	listRev: [Int!]!
	"""
	Fetch one page of event ids with a number of items up to a specified limit,
	optionally offset by a specified amount. The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [Int!]!
	"""
	Fetch one page of event ids in reverse chronological order with a number of items up to a specified limit,
	optionally offset by a specified amount. The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page_rev(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	pageRev(limit: Int!, offset: Int, pageIndex: Int): [Int!]!
}

"""
History object that provides access to timestamps (milliseconds since the Unix epoch) instead of `EventTime` entries.
"""
type HistoryTimestamp {
	"""
	List all timestamps.
	"""
	list: [Int!]!
	"""
	List all timestamps in reverse order.
	"""
	listRev: [Int!]!
	"""
	Fetch one page of timestamps with a number of items up to a specified limit, optionally offset by a specified amount.
	The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [Int!]!
	"""
	Fetch one page of timestamps in reverse order with a number of items up to a specified limit,
	optionally offset by a specified amount. The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page_rev(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	pageRev(limit: Int!, offset: Int, pageIndex: Int): [Int!]!
}

type IndexSpec {
	"""
	Returns node metadata.
	"""
	nodeMetadata: [String!]!
	"""
	Returns node properties.
	"""
	nodeProperties: [String!]!
	"""
	Returns edge metadata.
	"""
	edgeMetadata: [String!]!
	"""
	Returns edge properties.
	"""
	edgeProperties: [String!]!
}

input IndexSpecInput {
	"""
	Node properties.
	"""
	nodeProps: PropsInput!
	"""
	Edge properties.
	"""
	edgeProps: PropsInput!
}

input InputEdge {
	"""
	Source node.
	"""
	src: String!
	"""
	Destination node.
	"""
	dst: String!
}

"""
Provides access to the intervals between temporal entries of an object.
"""
type Intervals {
	"""
	List time intervals between consecutive timestamps in milliseconds.
	"""
	list: [Int!]!
	"""
	List millisecond time intervals between consecutive timestamps in reverse order.
	"""
	listRev: [Int!]!
	"""
	Fetch one page of intervals between consecutive timestamps with a number of items up to a specified limit,
	optionally offset by a specified amount. The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [Int!]!
	"""
	Fetch one page of intervals between consecutive timestamps in reverse order with a number of items up to a specified limit,
	optionally offset by a specified amount. The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	pageRev(limit: Int!, offset: Int, pageIndex: Int): [Int!]!
	"""
	Compute the mean interval between consecutive timestamps. Returns None if fewer than 1 timestamp.
	"""
	mean: Float
	"""
	Compute the median interval between consecutive timestamps. Returns None if fewer than 1 timestamp.
	"""
	median: Int
	"""
	Compute the maximum interval between consecutive timestamps. Returns None if fewer than 1 timestamp.
	"""
	max: Int
	"""
	Compute the minimum interval between consecutive timestamps. Returns None if fewer than 1 timestamp.
	"""
	min: Int
}

type LayerSchema {
	"""
	Returns the name of the layer with this schema
	"""
	name: String!
	"""
	Returns the list of edge schemas for this edge layer
	"""
	edges: [EdgeSchema!]!
}

type MetaGraph {
	"""
	Returns the graph name.
	"""
	name: String
	"""
	Returns path of graph.
	"""
	path: String!
	"""
	Returns the timestamp for the creation of the graph.
	"""
	created: Int!
	"""
	Returns the graph's last opened timestamp according to system time.
	"""
	lastOpened: Int!
	"""
	Returns the graph's last updated timestamp.
	"""
	lastUpdated: Int!
	"""
	Returns the number of nodes in the graph.
	"""
	nodeCount: Int!
	"""
	Returns the number of edges in the graph.
	
	Returns:
	int:
	"""
	edgeCount: Int!
	"""
	Returns the metadata of the graph.
	"""
	metadata: [Property!]!
}

type Metadata {
	"""
	Get metadata value matching the specified key.
	"""
	get(key: String!): Property
	"""
	/// Check if the key is in the metadata.
	"""
	contains(key: String!): Boolean!
	"""
	Return all metadata keys.
	"""
	keys: [String!]!
	"""
	/// Return all metadata values.
	"""
	values(keys: [String!]): [Property!]!
}

type MutRoot {
	"""
	Returns a collection of mutation plugins.
	"""
	plugins: MutationPlugin!
	"""
	Delete graph from a path on the server.
	"""
	deleteGraph(path: String!): Boolean!
	"""
	Creates a new graph.
	"""
	newGraph(path: String!, graphType: GraphType!): Boolean!
	"""
	Move graph from a path on the server to a new_path on the server.
	"""
	moveGraph(path: String!, newPath: String!, overwrite: Boolean): Boolean!
	"""
	Copy graph from a path on the server to a new_path on the server.
	"""
	copyGraph(path: String!, newPath: String!, overwrite: Boolean): Boolean!
	"""
	Upload a graph file from a path on the client using GQL multipart uploading.
	
	Returns::
	name of the new graph
	"""
	uploadGraph(path: String!, graph: Upload!, overwrite: Boolean!): String!
	"""
	Send graph bincode as base64 encoded string.
	
	Returns::
	path of the new graph
	"""
	sendGraph(path: String!, graph: String!, overwrite: Boolean!): String!
	"""
	Returns a subgraph given a set of nodes from an existing graph in the server.
	
	Returns::
	name of the new graph
	"""
	createSubgraph(parentPath: String!, nodes: [String!]!, newPath: String!, overwrite: Boolean!): String!
	"""
	(Experimental) Creates search index.
	"""
	createIndex(path: String!, indexSpec: IndexSpecInput, inRam: Boolean!): Boolean!
}

type MutableEdge {
	"""
	Use to check if adding the edge was successful.
	"""
	success: Boolean!
	"""
	Get the non-mutable edge for querying.
	"""
	edge: Edge!
	"""
	Get the mutable source node of the edge.
	"""
	src: MutableNode!
	"""
	Get the mutable destination node of the edge.
	"""
	dst: MutableNode!
	"""
	Mark the edge as deleted at time time.
	"""
	delete(time: Int!, layer: String): Boolean!
	"""
	Add metadata to the edge (errors if the value already exists).
	
	If this is called after add_edge, the layer is inherited from the add_edge and does not
	need to be specified again.
	"""
	addMetadata(properties: [PropertyInput!]!, layer: String): Boolean!
	"""
	Update metadata of the edge (existing values are overwritten).
	
	If this is called after add_edge, the layer is inherited from the add_edge and does not
	need to be specified again.
	"""
	updateMetadata(properties: [PropertyInput!]!, layer: String): Boolean!
	"""
	Add temporal property updates to the edge.
	
	If this is called after add_edge, the layer is inherited from the add_edge and does not
	need to be specified again.
	"""
	addUpdates(time: Int!, properties: [PropertyInput!], layer: String): Boolean!
}

type MutableGraph {
	"""
	Get the non-mutable graph.
	"""
	graph: Graph!
	"""
	Get mutable existing node.
	"""
	node(name: String!): MutableNode
	"""
	Add a new node or add updates to an existing node.
	"""
	addNode(time: Int!, name: String!, properties: [PropertyInput!], nodeType: String): MutableNode!
	"""
	Create a new node or fail if it already exists.
	"""
	createNode(time: Int!, name: String!, properties: [PropertyInput!], nodeType: String): MutableNode!
	"""
	Add a batch of nodes.
	"""
	addNodes(nodes: [NodeAddition!]!): Boolean!
	"""
	Get a mutable existing edge.
	"""
	edge(src: String!, dst: String!): MutableEdge
	"""
	Add a new edge or add updates to an existing edge.
	"""
	addEdge(time: Int!, src: String!, dst: String!, properties: [PropertyInput!], layer: String): MutableEdge!
	"""
	Add a batch of edges.
	"""
	addEdges(edges: [EdgeAddition!]!): Boolean!
	"""
	Mark an edge as deleted (creates the edge if it did not exist).
	"""
	deleteEdge(time: Int!, src: String!, dst: String!, layer: String): MutableEdge!
	"""
	Add temporal properties to graph.
	"""
	addProperties(t: Int!, properties: [PropertyInput!]!): Boolean!
	"""
	Add metadata to graph (errors if the property already exists).
	"""
	addMetadata(properties: [PropertyInput!]!): Boolean!
	"""
	Update metadata of the graph (overwrites existing values).
	"""
	updateMetadata(properties: [PropertyInput!]!): Boolean!
}

type MutableNode {
	"""
	Use to check if adding the node was successful.
	"""
	success: Boolean!
	"""
	Get the non-mutable Node.
	"""
	node: Node!
	"""
	Add metadata to the node (errors if the property already exists).
	"""
	addMetadata(properties: [PropertyInput!]!): Boolean!
	"""
	Set the node type (errors if the node already has a non-default type).
	"""
	setNodeType(newType: String!): Boolean!
	"""
	Update metadata of the node (overwrites existing property values).
	"""
	updateMetadata(properties: [PropertyInput!]!): Boolean!
	"""
	Add temporal property updates to the node.
	"""
	addUpdates(time: Int!, properties: [PropertyInput!]): Boolean!
}

type MutationPlugin {
	NoOps: String!
}

type Namespace {
	graphs: CollectionOfMetaGraph!
	path: String!
	parent: Namespace
	children: CollectionOfNamespace!
	items: CollectionOfNamespacedItem!
}

union NamespacedItem = Namespace | MetaGraph

"""
Raphtory graph node.
"""
type Node {
	"""
	Returns the unique id of the node.
	"""
	id: String!
	"""
	Returns the name of the node.
	"""
	name: String!
	"""
	Return a view of the node containing only the default layer.
	"""
	defaultLayer: Node!
	"""
	Return a view of node containing all layers specified.
	"""
	layers(names: [String!]!): Node!
	"""
	Returns a collection containing nodes belonging to all layers except the excluded list of layers.
	"""
	excludeLayers(names: [String!]!): Node!
	"""
	Returns a collection containing nodes belonging to the specified layer.
	"""
	layer(name: String!): Node!
	"""
	Returns a collection containing nodes belonging to all layers except the excluded layer.
	"""
	excludeLayer(name: String!): Node!
	"""
	Creates a WindowSet with the specified window size and optional step using a rolling window.
	
	A rolling window is a window that moves forward by step size at each iteration.
	
	alignment_unit optionally aligns the windows to the specified unit. "Unaligned" can be passed for no alignment.
	If unspecified (i.e. by default), alignment is done on the smallest unit of time in the step (or window if no step is passed).
	e.g. "1 month and 1 day" will align at the start of the day.
	Note that passing a step larger than window while alignment_unit is not "Unaligned" may lead to some entries appearing before
	the start of the first window and/or after the end of the last window (i.e. not included in any window).
	"""
	rolling(window: WindowDuration!, step: WindowDuration, alignmentUnit: AlignmentUnit): NodeWindowSet!
	"""
	Creates a WindowSet with the specified step size using an expanding window.
	
	An expanding window is a window that grows by step size at each iteration.
	
	alignment_unit optionally aligns the windows to the specified unit. "Unaligned" can be passed for no alignment.
	If unspecified (i.e. by default), alignment is done on the smallest unit of time in the step.
	e.g. "1 month and 1 day" will align at the start of the day.
	"""
	expanding(step: WindowDuration!, alignmentUnit: AlignmentUnit): NodeWindowSet!
	"""
	Create a view of the node including all events between the specified start (inclusive) and end (exclusive).
	"""
	window(start: TimeInput!, end: TimeInput!): Node!
	"""
	Create a view of the node including all events at a specified time.
	"""
	at(time: TimeInput!): Node!
	"""
	Create a view of the node including all events at the latest time.
	"""
	latest: Node!
	"""
	Create a view of the node including all events that are valid at the specified time.
	"""
	snapshotAt(time: TimeInput!): Node!
	"""
	Create a view of the node including all events that are valid at the latest time.
	"""
	snapshotLatest: Node!
	"""
	Create a view of the node including all events before specified end time (exclusive).
	"""
	before(time: TimeInput!): Node!
	"""
	Create a view of the node including all events after the specified start time (exclusive).
	"""
	after(time: TimeInput!): Node!
	"""
	Shrink a Window to a specified start and end time, if these are earlier and later than the current start and end respectively.
	"""
	shrinkWindow(start: TimeInput!, end: TimeInput!): Node!
	"""
	Set the start of the window to the larger of a specified start time and self.start().
	"""
	shrinkStart(start: TimeInput!): Node!
	"""
	Set the end of the window to the smaller of a specified end and self.end().
	"""
	shrinkEnd(end: TimeInput!): Node!
	applyViews(views: [NodeViewCollection!]!): Node!
	"""
	Returns the earliest time that the node exists.
	"""
	earliestTime: EventTime!
	"""
	Returns the time of the first update made to the node.
	"""
	firstUpdate: EventTime!
	"""
	Returns the latest time that the node exists.
	"""
	latestTime: EventTime!
	"""
	Returns the time of the last update made to the node.
	"""
	lastUpdate: EventTime!
	"""
	Gets the start time for the window. Errors if there is no window.
	"""
	start: EventTime!
	"""
	Gets the end time for the window. Errors if there is no window.
	"""
	end: EventTime!
	"""
	Returns a history object for the node, with time entries for node additions and changes made to node.
	"""
	history: History!
	"""
	Get the number of edge events for this node.
	"""
	edgeHistoryCount: Int!
	"""
	Check if the node is active and it's history is not empty.
	"""
	isActive: Boolean!
	"""
	Returns the type of node.
	"""
	nodeType: String
	"""
	Returns the properties of the node.
	"""
	properties: Properties!
	"""
	Returns the metadata of the node.
	"""
	metadata: Metadata!
	"""
	Returns the number of unique counter parties for this node.
	"""
	degree: Int!
	"""
	Returns the number edges with this node as the source.
	"""
	outDegree: Int!
	"""
	Returns the number edges with this node as the destination.
	"""
	inDegree: Int!
	inComponent: Nodes!
	outComponent: Nodes!
	"""
	Returns all connected edges.
	"""
	edges(select: EdgeFilter): Edges!
	"""
	Returns outgoing edges.
	"""
	outEdges(select: EdgeFilter): Edges!
	"""
	Returns incoming edges.
	"""
	inEdges(select: EdgeFilter): Edges!
	"""
	Returns neighbouring nodes.
	"""
	neighbours(select: NodeFilter): PathFromNode!
	"""
	Returns the number of neighbours that have at least one in-going edge to this node.
	"""
	inNeighbours(select: NodeFilter): PathFromNode!
	"""
	Returns the number of neighbours that have at least one out-going edge from this node.
	"""
	outNeighbours(select: NodeFilter): PathFromNode!
	filter(expr: NodeFilter!): Node!
}

input NodeAddition {
	"""
	Name.
	"""
	name: String!
	"""
	Node type.
	"""
	nodeType: String
	"""
	Metadata.
	"""
	metadata: [PropertyInput!]
	"""
	Updates.
	"""
	updates: [TemporalPropertyInput!]
}

enum NodeField {
	"""
	Node ID field.
	
	Represents the graph’s node identifier (numeric or string-backed in the API).
	"""
	NODE_ID
	"""
	Node name field.
	
	Represents the human-readable node name (string).
	"""
	NODE_NAME
	"""
	Node type field.
	
	Represents the optional node type assigned at node creation (string).
	"""
	NODE_TYPE
}

"""
Boolean expression over a built-in node field (ID, name, or type).

This is used by `NodeFieldFilterNew.where_` when filtering a specific
`NodeField`.

Supports comparisons, string predicates, and set membership.
(Presence checks and aggregations are handled via property filters instead.)
"""
input NodeFieldCondition @oneOf {
	"""
	Equality.
	"""
	eq: Value
	"""
	Inequality.
	"""
	ne: Value
	"""
	Greater-than.
	"""
	gt: Value
	"""
	Greater-than-or-equal.
	"""
	ge: Value
	"""
	Less-than.
	"""
	lt: Value
	"""
	Less-than-or-equal.
	"""
	le: Value
	"""
	String prefix match.
	"""
	startsWith: Value
	"""
	String suffix match.
	"""
	endsWith: Value
	"""
	Substring match.
	"""
	contains: Value
	"""
	Negated substring match.
	"""
	notContains: Value
	"""
	Set membership.
	"""
	isIn: Value
	"""
	Negated set membership.
	"""
	isNotIn: Value
}

"""
Filters a built-in node field (`id`, `name`, `type`) using a `NodeFieldCondition`.

Example (GraphQL):
```graphql
{ Node: { field: NodeName, where: { Contains: "ali" } } }
```
"""
input NodeFieldFilterNew {
	"""
	Which built-in field to filter.
	"""
	field: NodeField!
	"""
	Condition applied to the selected field.
	
	Exposed as `where` in GraphQL.
	"""
	where: NodeFieldCondition!
}

"""
GraphQL input type for filtering nodes.

`NodeFilter` represents a composable boolean expression evaluated
against nodes in a graph. Filters can target:

- built-in node fields (`Node` / `NodeFieldFilterNew`),
- node properties and metadata,
- temporal properties,
- temporal scope (windows, snapshots, latest),
- and layer membership,
- plus node state predicates (e.g. `IsActive`).

Filters can be combined recursively using logical operators
(`And`, `Or`, `Not`).
"""
input NodeFilter @oneOf {
	"""
	Filters a built-in node field (ID, name, or type).
	"""
	node: NodeFieldFilterNew
	"""
	Filters a node property by name and condition.
	"""
	property: PropertyFilterNew
	"""
	Filters a node metadata field by name and condition.
	
	Metadata is shared across all temporal versions of a node.
	"""
	metadata: PropertyFilterNew
	"""
	Filters a temporal node property by name and condition.
	
	Used when the property value varies over time and must be evaluated
	within a temporal context.
	"""
	temporalProperty: PropertyFilterNew
	"""
	Logical AND over multiple node filters.
	"""
	and: [NodeFilter!]
	"""
	Logical OR over multiple node filters.
	"""
	or: [NodeFilter!]
	"""
	Logical NOT over a nested node filter.
	"""
	not: NodeFilter
	"""
	Restricts evaluation to a time window (inclusive start, exclusive end).
	"""
	window: NodeWindowExpr
	"""
	Restricts evaluation to a single point in time.
	"""
	at: NodeTimeExpr
	"""
	Restricts evaluation to times strictly before the given time.
	"""
	before: NodeTimeExpr
	"""
	Restricts evaluation to times strictly after the given time.
	"""
	after: NodeTimeExpr
	"""
	Evaluates predicates against the latest available node state.
	"""
	latest: NodeUnaryExpr
	"""
	Evaluates predicates against a snapshot of the graph at a given time.
	"""
	snapshotAt: NodeTimeExpr
	"""
	Evaluates predicates against the most recent snapshot of the graph.
	"""
	snapshotLatest: NodeUnaryExpr
	"""
	Restricts evaluation to nodes belonging to one or more layers.
	"""
	layers: NodeLayersExpr
	"""
	Matches nodes that have at least one event in the current view/window.
	
	When `true`, only active nodes are matched.
	"""
	isActive: Boolean
}

"""
Restricts node evaluation to one or more layers and applies a nested `NodeFilter`.

Used by `GqlNodeFilter::Layers`.
"""
input NodeLayersExpr {
	"""
	Layer names to include.
	"""
	names: [String!]!
	"""
	Filter evaluated within the layer-restricted view.
	"""
	expr: NodeFilter!
}

type NodeSchema {
	typeName: String!
	"""
	Returns the list of property schemas for this node
	"""
	properties: [PropertySchema!]!
	metadata: [PropertySchema!]!
}

input NodeSortBy {
	"""
	Reverse order
	"""
	reverse: Boolean
	"""
	Unique Id
	"""
	id: Boolean
	"""
	Time
	"""
	time: SortByTime
	"""
	Property
	"""
	property: String
}

"""
Restricts node evaluation to a single time bound and applies a nested `NodeFilter`.

Used by `At`, `Before`, and `After` node filters.
"""
input NodeTimeExpr {
	"""
	Reference time for the operation.
	"""
	time: TimeInput!
	"""
	Filter evaluated within the restricted time scope.
	"""
	expr: NodeFilter!
}

"""
Applies a unary node-view operation and then evaluates a nested `NodeFilter`.

Used by `Latest` and `SnapshotLatest` node filters.
"""
input NodeUnaryExpr {
	"""
	Filter evaluated after applying the unary operation.
	"""
	expr: NodeFilter!
}

input NodeViewCollection @oneOf {
	"""
	Contains only the default layer.
	"""
	defaultLayer: Boolean
	"""
	View at the latest time.
	"""
	latest: Boolean
	"""
	Snapshot at latest time.
	"""
	snapshotLatest: Boolean
	"""
	Snapshot at specified time.
	"""
	snapshotAt: TimeInput
	"""
	List of included layers.
	"""
	layers: [String!]
	"""
	List of excluded layers.
	"""
	excludeLayers: [String!]
	"""
	Single excluded layer.
	"""
	excludeLayer: String
	"""
	Window between a start and end time.
	"""
	window: Window
	"""
	View at a specified time.
	"""
	at: TimeInput
	"""
	View before a specified time (end exclusive).
	"""
	before: TimeInput
	"""
	View after a specified time (start exclusive).
	"""
	after: TimeInput
	"""
	Shrink a Window to a specified start and end time.
	"""
	shrinkWindow: Window
	"""
	Set the window start to a specified time.
	"""
	shrinkStart: TimeInput
	"""
	Set the window end to a specified time.
	"""
	shrinkEnd: TimeInput
	"""
	Node filter.
	"""
	nodeFilter: NodeFilter
}

"""
Restricts node evaluation to a time window and applies a nested `NodeFilter`.

Used by `GqlNodeFilter::Window`.

The window is inclusive of `start` and exclusive of `end`.
"""
input NodeWindowExpr {
	"""
	Window start time (inclusive).
	"""
	start: TimeInput!
	"""
	Window end time (exclusive).
	"""
	end: TimeInput!
	"""
	Filter evaluated within the restricted window.
	"""
	expr: NodeFilter!
}

type NodeWindowSet {
	count: Int!
	"""
	Fetch one page with a number of items up to a specified limit, optionally offset by a specified amount.
	The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [Node!]!
	list: [Node!]!
}

type Nodes {
	"""
	Return a view of the nodes containing only the default edge layer.
	"""
	defaultLayer: Nodes!
	"""
	Return a view of the nodes containing all layers specified.
	"""
	layers(names: [String!]!): Nodes!
	"""
	Return a view of the nodes containing all layers except those specified.
	"""
	excludeLayers(names: [String!]!): Nodes!
	"""
	Return a view of the nodes containing the specified layer.
	"""
	layer(name: String!): Nodes!
	"""
	Return a view of the nodes containing all layers except those specified.
	"""
	excludeLayer(name: String!): Nodes!
	"""
	Creates a WindowSet with the specified window size and optional step using a rolling window.
	
	A rolling window is a window that moves forward by step size at each iteration.
	
	alignment_unit optionally aligns the windows to the specified unit. "Unaligned" can be passed for no alignment.
	If unspecified (i.e. by default), alignment is done on the smallest unit of time in the step (or window if no step is passed).
	e.g. "1 month and 1 day" will align at the start of the day.
	Note that passing a step larger than window while alignment_unit is not "Unaligned" may lead to some entries appearing before
	the start of the first window and/or after the end of the last window (i.e. not included in any window).
	"""
	rolling(window: WindowDuration!, step: WindowDuration, alignmentUnit: AlignmentUnit): NodesWindowSet!
	"""
	Creates a WindowSet with the specified step size using an expanding window.
	
	An expanding window is a window that grows by step size at each iteration.
	
	alignment_unit optionally aligns the windows to the specified unit. "Unaligned" can be passed for no alignment.
	If unspecified (i.e. by default), alignment is done on the smallest unit of time in the step.
	e.g. "1 month and 1 day" will align at the start of the day.
	"""
	expanding(step: WindowDuration!, alignmentUnit: AlignmentUnit): NodesWindowSet!
	"""
	Create a view of the node including all events between the specified start (inclusive) and end (exclusive).
	"""
	window(start: TimeInput!, end: TimeInput!): Nodes!
	"""
	Create a view of the nodes including all events at a specified time.
	"""
	at(time: TimeInput!): Nodes!
	"""
	Create a view of the nodes including all events at the latest time.
	"""
	latest: Nodes!
	"""
	Create a view of the nodes including all events that are valid at the specified time.
	"""
	snapshotAt(time: TimeInput!): Nodes!
	"""
	Create a view of the nodes including all events that are valid at the latest time.
	"""
	snapshotLatest: Nodes!
	"""
	Create a view of the nodes including all events before specified end time (exclusive).
	"""
	before(time: TimeInput!): Nodes!
	"""
	Create a view of the nodes including all events after the specified start time (exclusive).
	"""
	after(time: TimeInput!): Nodes!
	"""
	Shrink both the start and end of the window.
	"""
	shrinkWindow(start: TimeInput!, end: TimeInput!): Nodes!
	"""
	Set the start of the window to the larger of a specified start time and self.start().
	"""
	shrinkStart(start: TimeInput!): Nodes!
	"""
	Set the end of the window to the smaller of a specified end and self.end().
	"""
	shrinkEnd(end: TimeInput!): Nodes!
	"""
	Filter nodes by node type.
	"""
	typeFilter(nodeTypes: [String!]!): Nodes!
	applyViews(views: [NodesViewCollection!]!): Nodes!
	sorted(sortBys: [NodeSortBy!]!): Nodes!
	"""
	Returns the start time of the window. Errors if there is no window.
	"""
	start: EventTime!
	"""
	Returns the end time of the window. Errors if there is no window.
	"""
	end: EventTime!
	count: Int!
	"""
	Fetch one page with a number of items up to a specified limit, optionally offset by a specified amount.
	The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [Node!]!
	list: [Node!]!
	"""
	Returns a view of the node ids.
	"""
	ids: [String!]!
	"""
	Returns a filtered view that applies to list down the chain
	"""
	filter(expr: NodeFilter!): Nodes!
	"""
	Returns filtered list of nodes
	"""
	select(expr: NodeFilter!): Nodes!
}

input NodesViewCollection @oneOf {
	"""
	Contains only the default layer.
	"""
	defaultLayer: Boolean
	"""
	View at the latest time.
	"""
	latest: Boolean
	"""
	Snapshot at latest time.
	"""
	snapshotLatest: Boolean
	"""
	List of included layers.
	"""
	layers: [String!]
	"""
	List of excluded layers.
	"""
	excludeLayers: [String!]
	"""
	Single excluded layer.
	"""
	excludeLayer: String
	"""
	Window between a start and end time.
	"""
	window: Window
	"""
	View at a specified time.
	"""
	at: TimeInput
	"""
	Snapshot at specified time.
	"""
	snapshotAt: TimeInput
	"""
	View before a specified time (end exclusive).
	"""
	before: TimeInput
	"""
	View after a specified time (start exclusive).
	"""
	after: TimeInput
	"""
	Shrink a Window to a specified start and end time.
	"""
	shrinkWindow: Window
	"""
	Set the window start to a specified time.
	"""
	shrinkStart: TimeInput
	"""
	Set the window end to a specified time.
	"""
	shrinkEnd: TimeInput
	"""
	Node filter.
	"""
	nodeFilter: NodeFilter
	"""
	List of types.
	"""
	typeFilter: [String!]
}

type NodesWindowSet {
	count: Int!
	"""
	Fetch one page with a number of items up to a specified limit, optionally offset by a specified amount.
	The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [Nodes!]!
	list: [Nodes!]!
}

input ObjectEntry {
	"""
	Key.
	"""
	key: String!
	"""
	Value.
	"""
	value: Value!
}

"""
PageRank score.
"""
type PagerankOutput {
	name: String!
	rank: Float!
}

type PathFromNode {
	"""
	Returns a view of PathFromNode containing the specified layer, errors if the layer does not exist.
	"""
	layers(names: [String!]!): PathFromNode!
	"""
	Return a view of PathFromNode containing all layers except the specified excluded layers, errors if any of the layers do not exist.
	"""
	excludeLayers(names: [String!]!): PathFromNode!
	"""
	Return a view of PathFromNode containing the layer specified layer, errors if the layer does not exist.
	"""
	layer(name: String!): PathFromNode!
	"""
	Return a view of PathFromNode containing all layers except the specified excluded layers, errors if any of the layers do not exist.
	"""
	excludeLayer(name: String!): PathFromNode!
	"""
	Creates a WindowSet with the given window size and optional step using a rolling window.
	
	A rolling window is a window that moves forward by step size at each iteration.
	
	alignment_unit optionally aligns the windows to the specified unit. "Unaligned" can be passed for no alignment.
	If unspecified (i.e. by default), alignment is done on the smallest unit of time in the step (or window if no step is passed).
	e.g. "1 month and 1 day" will align at the start of the day.
	Note that passing a step larger than window while alignment_unit is not "Unaligned" may lead to some entries appearing before
	the start of the first window and/or after the end of the last window (i.e. not included in any window).
	"""
	rolling(window: WindowDuration!, step: WindowDuration, alignmentUnit: AlignmentUnit): PathFromNodeWindowSet!
	"""
	Creates a WindowSet with the given step size using an expanding window.
	
	An expanding window is a window that grows by step size at each iteration.
	
	alignment_unit optionally aligns the windows to the specified unit. "Unaligned" can be passed for no alignment.
	If unspecified (i.e. by default), alignment is done on the smallest unit of time in the step.
	e.g. "1 month and 1 day" will align at the start of the day.
	"""
	expanding(step: WindowDuration!, alignmentUnit: AlignmentUnit): PathFromNodeWindowSet!
	"""
	Create a view of the PathFromNode including all events between a specified start (inclusive) and end (exclusive).
	"""
	window(start: TimeInput!, end: TimeInput!): PathFromNode!
	"""
	Create a view of the PathFromNode including all events at time.
	"""
	at(time: TimeInput!): PathFromNode!
	"""
	Create a view of the PathFromNode including all events that are valid at the latest time.
	"""
	snapshotLatest: PathFromNode!
	"""
	Create a view of the PathFromNode including all events that are valid at the specified time.
	"""
	snapshotAt(time: TimeInput!): PathFromNode!
	"""
	Create a view of the PathFromNode including all events at the latest time.
	"""
	latest: PathFromNode!
	"""
	Create a view of the PathFromNode including all events before the specified end (exclusive).
	"""
	before(time: TimeInput!): PathFromNode!
	"""
	Create a view of the PathFromNode including all events after the specified start (exclusive).
	"""
	after(time: TimeInput!): PathFromNode!
	"""
	Shrink both the start and end of the window.
	"""
	shrinkWindow(start: TimeInput!, end: TimeInput!): PathFromNode!
	"""
	Set the start of the window to the larger of the specified start and self.start().
	"""
	shrinkStart(start: TimeInput!): PathFromNode!
	"""
	Set the end of the window to the smaller of the specified end and self.end().
	"""
	shrinkEnd(end: TimeInput!): PathFromNode!
	"""
	Filter nodes by type.
	"""
	typeFilter(nodeTypes: [String!]!): PathFromNode!
	"""
	Returns the earliest time that this PathFromNode is valid or None if the PathFromNode is valid for all times.
	"""
	start: EventTime!
	"""
	Returns the latest time that this PathFromNode is valid or None if the PathFromNode is valid for all times.
	"""
	end: EventTime!
	count: Int!
	"""
	Fetch one page with a number of items up to a specified limit, optionally offset by a specified amount.
	The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [Node!]!
	list: [Node!]!
	"""
	Returns the node ids.
	"""
	ids: [String!]!
	"""
	Takes a specified selection of views and applies them in given order.
	"""
	applyViews(views: [PathFromNodeViewCollection!]!): PathFromNode!
	"""
	Returns a filtered view that applies to list down the chain
	"""
	filter(expr: NodeFilter!): PathFromNode!
	"""
	Returns filtered list of neighbour nodes
	"""
	select(expr: NodeFilter!): PathFromNode!
}

input PathFromNodeViewCollection @oneOf {
	"""
	Latest time.
	"""
	latest: Boolean
	"""
	Latest snapshot.
	"""
	snapshotLatest: Boolean
	"""
	Time.
	"""
	snapshotAt: TimeInput
	"""
	List of layers.
	"""
	layers: [String!]
	"""
	List of excluded layers.
	"""
	excludeLayers: [String!]
	"""
	Single layer to exclude.
	"""
	excludeLayer: String
	"""
	Window between a start and end time.
	"""
	window: Window
	"""
	View at a specified time.
	"""
	at: TimeInput
	"""
	View before a specified time (end exclusive).
	"""
	before: TimeInput
	"""
	View after a specified time (start exclusive).
	"""
	after: TimeInput
	"""
	Shrink a Window to a specified start and end time.
	"""
	shrinkWindow: Window
	"""
	Set the window start to a specified time.
	"""
	shrinkStart: TimeInput
	"""
	Set the window end to a specified time.
	"""
	shrinkEnd: TimeInput
}

type PathFromNodeWindowSet {
	count: Int!
	"""
	Fetch one page with a number of items up to a specified limit, optionally offset by a specified amount.
	The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [PathFromNode!]!
	list: [PathFromNode!]!
}

"""
Boolean expression over a property value.

`PropCondition` is used inside `PropertyFilterNew.where` to describe
how a property’s value should be matched.

It supports:
- comparisons (`Eq`, `Gt`, `Le`, …),
- string predicates (`Contains`, `StartsWith`, …),
- set membership (`IsIn`, `IsNotIn`),
- presence checks (`IsSome`, `IsNone`),
- boolean composition (`And`, `Or`, `Not`),
- and list/aggregate qualifiers (`First`, `Sum`, `Len`, …).

Notes:
- `Value` is interpreted according to the property’s type.
- Aggregators/qualifiers like `Sum` and `Len` apply when the underlying
property is list-like or aggregatable (depending on your engine rules).
"""
input PropCondition @oneOf {
	"""
	Equality: property value equals the given value.
	"""
	eq: Value
	"""
	Inequality: property value does not equal the given value.
	"""
	ne: Value
	"""
	Greater-than: property value is greater than the given value.
	"""
	gt: Value
	"""
	Greater-than-or-equal: property value is >= the given value.
	"""
	ge: Value
	"""
	Less-than: property value is less than the given value.
	"""
	lt: Value
	"""
	Less-than-or-equal: property value is <= the given value.
	"""
	le: Value
	"""
	String prefix match against the property's string representation.
	"""
	startsWith: Value
	"""
	String suffix match against the property's string representation.
	"""
	endsWith: Value
	"""
	Substring match against the property's string representation.
	"""
	contains: Value
	"""
	Negated substring match against the property's string representation.
	"""
	notContains: Value
	"""
	Set membership: property value is contained in the given list of values.
	"""
	isIn: Value
	"""
	Negated set membership: property value is not contained in the given list of values.
	"""
	isNotIn: Value
	"""
	Presence check: property value is present (not null/missing).
	
	When set to `true`, requires the property to exist.
	"""
	isSome: Boolean
	"""
	Absence check: property value is missing / null.
	
	When set to `true`, requires the property to be missing.
	"""
	isNone: Boolean
	"""
	Logical AND over nested conditions.
	"""
	and: [PropCondition!]
	"""
	Logical OR over nested conditions.
	"""
	or: [PropCondition!]
	"""
	Logical NOT over a nested condition.
	"""
	not: PropCondition
	"""
	Applies the nested condition to the **first** element of a list-like property.
	"""
	first: PropCondition
	"""
	Applies the nested condition to the **last** element of a list-like property.
	"""
	last: PropCondition
	"""
	Requires that **any** element of a list-like property matches the nested condition.
	"""
	any: PropCondition
	"""
	Requires that **all** elements of a list-like property match the nested condition.
	"""
	all: PropCondition
	"""
	Applies the nested condition to the **sum** of a numeric list-like property.
	"""
	sum: PropCondition
	"""
	Applies the nested condition to the **average** of a numeric list-like property.
	"""
	avg: PropCondition
	"""
	Applies the nested condition to the **minimum** element of a list-like property.
	"""
	min: PropCondition
	"""
	Applies the nested condition to the **maximum** element of a list-like property.
	"""
	max: PropCondition
	"""
	Applies the nested condition to the **length** of a list-like property.
	"""
	len: PropCondition
}

type Properties {
	"""
	Get property value matching the specified key.
	"""
	get(key: String!): Property
	"""
	Check if the key is in the properties.
	"""
	contains(key: String!): Boolean!
	"""
	Return all property keys.
	"""
	keys: [String!]!
	"""
	Return all property values.
	"""
	values(keys: [String!]): [Property!]!
	temporal: TemporalProperties!
}

type Property {
	key: String!
	asString: String!
	value: PropertyOutput!
}

"""
Filters an entity property or metadata field by name and condition.

This input is used by both node and edge filters when targeting
a specific property key (or metadata key) and applying a `PropCondition`.

Fields:
- `name`: The property key to query.
- `where_`: The condition to apply to that property’s value.

Example (GraphQL):
```graphql
{ Property: { name: "weight", where: { Gt: 0.5 } } }
```
"""
input PropertyFilterNew {
	"""
	Property (or metadata) key.
	"""
	name: String!
	"""
	Condition applied to the property value.
	
	Exposed as `where` in GraphQL.
	"""
	where: PropCondition!
}

input PropertyInput {
	"""
	Key.
	"""
	key: String!
	"""
	Value.
	"""
	value: Value!
}

scalar PropertyOutput

type PropertySchema {
	key: String!
	propertyType: String!
	variants: [String!]!
}

type PropertyTuple {
	time: EventTime!
	asString: String!
	value: PropertyOutput!
}

input PropsInput @oneOf {
	"""
	All properties and metadata.
	"""
	all: AllPropertySpec
	"""
	Some properties and metadata.
	"""
	some: SomePropertySpec
}

type QueryPlugin {
	NoOps: String!
}

type QueryRoot {
	"""
	Hello world demo
	"""
	hello: String!
	"""
	Returns a graph
	"""
	graph(path: String!): Graph!
	"""
	Update graph query, has side effects to update graph state
	
	Returns:: GqlMutableGraph
	"""
	updateGraph(path: String!): MutableGraph!
	"""
	Create vectorised graph in the format used for queries
	
	Returns:: GqlVectorisedGraph
	"""
	vectorisedGraph(path: String!): VectorisedGraph
	"""
	Returns all namespaces using recursive search
	
	Returns::  List of namespaces on root
	"""
	namespaces: CollectionOfNamespace!
	"""
	Returns a specific namespace at a given path
	
	Returns:: Namespace or error if no namespace found
	"""
	namespace(path: String!): Namespace!
	"""
	Returns root namespace
	
	Returns::  Root namespace
	"""
	root: Namespace!
	"""
	Returns a plugin.
	"""
	plugins: QueryPlugin!
	"""
	Encodes graph and returns as string
	
	Returns:: Base64 url safe encoded string
	"""
	receiveGraph(path: String!): String!
	version: String!
}

type ShortestPathOutput {
	target: String!
	nodes: [String!]!
}

"""
SomePropertySpec object containing lists of metadata and property names.
"""
input SomePropertySpec {
	"""
	List of metadata.
	"""
	metadata: [String!]!
	"""
	List of properties.
	"""
	properties: [String!]!
}

enum SortByTime {
	"""
	Latest time
	"""
	LATEST
	"""
	Earliest time
	"""
	EARLIEST
}

type TemporalProperties {
	"""
	Get property value matching the specified key.
	"""
	get(key: String!): TemporalProperty
	"""
	Check if the key is in the properties.
	"""
	contains(key: String!): Boolean!
	"""
	Return all property keys.
	"""
	keys: [String!]!
	"""
	Return all property values.
	"""
	values(keys: [String!]): [TemporalProperty!]!
}

type TemporalProperty {
	"""
	Key of a property.
	"""
	key: String!
	history: History!
	"""
	Return the values of the properties.
	"""
	values: [String!]!
	at(t: TimeInput!): String
	latest: String
	unique: [String!]!
	orderedDedupe(latestTime: Boolean!): [PropertyTuple!]!
}

input TemporalPropertyInput {
	"""
	Time.
	"""
	time: Int!
	"""
	Properties.
	"""
	properties: [PropertyInput!]
}

"""
Input for primary time component. Expects Int, DateTime formatted String, or Object { timestamp, eventId }
where the timestamp is either an Int or a DateTime formatted String, and eventId is a non-negative Int.
Valid string formats are RFC3339, RFC2822, %Y-%m-%d, %Y-%m-%dT%H:%M:%S%.3f, %Y-%m-%dT%H:%M:%S%,
%Y-%m-%d %H:%M:%S%.3f and %Y-%m-%d %H:%M:%S%.
"""
scalar TimeInput

"""
A multipart file upload
"""
scalar Upload

input Value @oneOf {
	"""
	8 bit unsigned integer.
	"""
	u8: Int
	"""
	16 bit unsigned integer.
	"""
	u16: Int
	"""
	32 bit unsigned integer.
	"""
	u32: Int
	"""
	64 bit unsigned integer.
	"""
	u64: Int
	"""
	32 bit signed integer.
	"""
	i32: Int
	"""
	64 bit signed integer.
	"""
	i64: Int
	"""
	32 bit float.
	"""
	f32: Float
	"""
	64 bit float.
	"""
	f64: Float
	"""
	String.
	"""
	str: String
	"""
	Boolean.
	"""
	bool: Boolean
	"""
	List.
	"""
	list: [Value!]
	"""
	Object.
	"""
	object: [ObjectEntry!]
}

type VectorSelection {
	"""
	Returns a list of nodes in the current selection.
	"""
	nodes: [Node!]!
	"""
	Returns a list of edges in the current selection.
	"""
	edges: [Edge!]!
	"""
	Returns a list of documents in the current selection.
	"""
	getDocuments: [Document!]!
	"""
	Adds all the documents associated with the specified nodes to the current selection.
	
	Documents added by this call are assumed to have a score of 0.
	"""
	addNodes(nodes: [String!]!): VectorSelection!
	"""
	Adds all the documents associated with the specified edges to the current selection.
	
	Documents added by this call are assumed to have a score of 0.
	"""
	addEdges(edges: [InputEdge!]!): VectorSelection!
	"""
	Add all the documents a specified number of hops away to the selection.
	
	Two documents A and B are considered to be 1 hop away of each other if they are on the same entity or if they are on the same node and edge pair.
	"""
	expand(hops: Int!, window: VectorisedGraphWindow): VectorSelection!
	"""
	Adds documents, from the set of one hop neighbours to the current selection, to the selection based on their similarity score with the specified query. This function loops so that the set of one hop neighbours expands on each loop and number of documents added is determined by the specified limit.
	"""
	expandEntitiesBySimilarity(query: String!, limit: Int!, window: VectorisedGraphWindow): VectorSelection!
	"""
	Add the adjacent nodes with higher score for query to the selection up to a specified limit. This function loops like expand_entities_by_similarity but is restricted to nodes.
	"""
	expandNodesBySimilarity(query: String!, limit: Int!, window: VectorisedGraphWindow): VectorSelection!
	"""
	Add the adjacent edges with higher score for query to the selection up to a specified limit. This function loops like expand_entities_by_similarity but is restricted to edges.
	"""
	expandEdgesBySimilarity(query: String!, limit: Int!, window: VectorisedGraphWindow): VectorSelection!
}

type VectorisedGraph {
	"""
	Returns an empty selection of documents.
	"""
	emptySelection: VectorSelection!
	"""
	Search the top scoring entities according to a specified query returning no more than a specified limit of entities.
	"""
	entitiesBySimilarity(query: String!, limit: Int!, window: VectorisedGraphWindow): VectorSelection!
	"""
	Search the top scoring nodes according to a specified query returning no more than a specified limit of nodes.
	"""
	nodesBySimilarity(query: String!, limit: Int!, window: VectorisedGraphWindow): VectorSelection!
	"""
	Search the top scoring edges according to a specified query returning no more than a specified limit of edges.
	"""
	edgesBySimilarity(query: String!, limit: Int!, window: VectorisedGraphWindow): VectorSelection!
}

input VectorisedGraphWindow {
	"""
	Start time.
	"""
	start: Int!
	"""
	End time.
	"""
	end: Int!
}

input Window {
	"""
	Window start time.
	"""
	start: TimeInput!
	"""
	Window end time.
	"""
	end: TimeInput!
}

input WindowDuration @oneOf {
	"""
	Duration of window period.
	
	Choose from:
	"""
	duration: String
	"""
	Time.
	"""
	epoch: Int
}

"""
Directs the executor to include this field or fragment only when the `if` argument is true.
"""
directive @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
"""
Indicates that an Input Object is a OneOf Input Object (and thus requires exactly one of its field be provided)
"""
directive @oneOf on INPUT_OBJECT
"""
Directs the executor to skip this field or fragment when the `if` argument is true.
"""
directive @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
"""
Provides a scalar specification URL for specifying the behavior of custom scalar types.
"""
directive @specifiedBy(url: String!) on SCALAR
schema {
	query: QueryRoot
	mutation: MutRoot
}

