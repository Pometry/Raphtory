enum AllPropertySpec {
	ALL
	ALL_METADATA
	ALL_PROPERTIES
}


type CollectionOfMetaGraph {
	list: [MetaGraph!]!
	"""
	Fetch one "page" of items, optionally offset by a specified amount.
	
	* `limit` - The size of the page (number of items to fetch).
	* `offset` - The number of items to skip (defaults to 0).
	* `page_index` - The number of pages (of size `limit`) to skip (defaults to 0).
	
	e.g. if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [MetaGraph!]!
	count: Int!
}

type CollectionOfNamespace {
	list: [Namespace!]!
	"""
	Fetch one "page" of items, optionally offset by a specified amount.
	
	* `limit` - The size of the page (number of items to fetch).
	* `offset` - The number of items to skip (defaults to 0).
	* `page_index` - The number of pages (of size `limit`) to skip (defaults to 0).
	
	e.g. if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [Namespace!]!
	count: Int!
}

type CollectionOfNamespacedItem {
	list: [NamespacedItem!]!
	"""
	Fetch one "page" of items, optionally offset by a specified amount.
	
	* `limit` - The size of the page (number of items to fetch).
	* `offset` - The number of items to skip (defaults to 0).
	* `page_index` - The number of pages (of size `limit`) to skip (defaults to 0).
	
	e.g. if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [NamespacedItem!]!
	count: Int!
}

union DocumentEntity = Node | Edge

type Edge {
	defaultLayer: Edge!
	layers(names: [String!]!): Edge!
	excludeLayers(names: [String!]!): Edge!
	layer(name: String!): Edge!
	excludeLayer(name: String!): Edge!
	rolling(window: WindowDuration!, step: WindowDuration): EdgeWindowSet!
	expanding(step: WindowDuration!): EdgeWindowSet!
	window(start: TimeInput!, end: TimeInput!): Edge!
	at(time: TimeInput!): Edge!
	latest: Edge!
	snapshotAt(time: TimeInput!): Edge!
	snapshotLatest: Edge!
	before(time: TimeInput!): Edge!
	after(time: TimeInput!): Edge!
	shrinkWindow(start: TimeInput!, end: TimeInput!): Edge!
	shrinkStart(start: TimeInput!): Edge!
	shrinkEnd(end: TimeInput!): Edge!
	applyViews(views: [EdgeViewCollection!]!): Edge!
	earliestTime: TimeIndexEntry
	firstUpdate: TimeIndexEntry
	latestTime: TimeIndexEntry
	lastUpdate: TimeIndexEntry
	time: TimeIndexEntry!
	start: TimeIndexEntry
	end: TimeIndexEntry
	src: Node!
	dst: Node!
	nbr: Node!
	id: [String!]!
	properties: Properties!
	metadata: Metadata!
	layerNames: [String!]!
	layerName: String!
	explode: Edges!
	explodeLayers: Edges!
	history: History!
	deletions: History!
	isValid: Boolean!
	isActive: Boolean!
	isDeleted: Boolean!
	isSelfLoop: Boolean!
}

input EdgeAddition {
	src: String!
	dst: String!
	layer: String
	metadata: [PropertyInput!]
	updates: [TemporalPropertyInput!]
}

input EdgeFilter @oneOf {
	src: NodeFieldFilter
	dst: NodeFieldFilter
	property: PropertyFilterExpr
	metadata: MetadataFilterExpr
	temporalProperty: TemporalPropertyFilterExpr
	and: [EdgeFilter!]
	or: [EdgeFilter!]
	not: EdgeFilter
}

type EdgeSchema {
	"""
	Returns the type of source for these edges
	"""
	srcType: String!
	"""
	Returns the type of destination for these edges
	"""
	dstType: String!
	"""
	Returns the list of property schemas for edges connecting these types of nodes
	"""
	properties: [PropertySchema!]!
	metadata: [PropertySchema!]!
}

input EdgeSortBy {
	reverse: Boolean
	src: Boolean
	dst: Boolean
	time: SortByTime
	property: String
}

input EdgeViewCollection @oneOf {
	defaultLayer: Boolean
	latest: Boolean
	snapshotLatest: Boolean
	snapshotAt: TimeInput
	layers: [String!]
	excludeLayers: [String!]
	layer: String
	excludeLayer: String
	window: Window
	at: TimeInput
	before: TimeInput
	after: TimeInput
	shrinkWindow: Window
	shrinkStart: TimeInput
	shrinkEnd: TimeInput
}

type EdgeWindowSet {
	count: Int!
	"""
	Fetch one "page" of items, optionally offset by a specified amount.
	
	* `limit` - The size of the page (number of items to fetch).
	* `offset` - The number of items to skip (defaults to 0).
	* `page_index` - The number of pages (of size `limit`) to skip (defaults to 0).
	
	e.g. if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [Edge!]!
	list: [Edge!]!
}

type Edges {
	defaultLayer: Edges!
	layers(names: [String!]!): Edges!
	excludeLayers(names: [String!]!): Edges!
	layer(name: String!): Edges!
	excludeLayer(name: String!): Edges!
	rolling(window: WindowDuration!, step: WindowDuration): EdgesWindowSet!
	expanding(step: WindowDuration!): EdgesWindowSet!
	window(start: TimeInput!, end: TimeInput!): Edges!
	at(time: TimeInput!): Edges!
	latest: Edges!
	snapshotAt(time: TimeInput!): Edges!
	snapshotLatest: Edges!
	before(time: TimeInput!): Edges!
	after(time: TimeInput!): Edges!
	shrinkWindow(start: TimeInput!, end: TimeInput!): Edges!
	shrinkStart(start: TimeInput!): Edges!
	shrinkEnd(end: TimeInput!): Edges!
	applyViews(views: [EdgesViewCollection!]!): Edges!
	explode: Edges!
	explodeLayers: Edges!
	sorted(sortBys: [EdgeSortBy!]!): Edges!
	start: TimeIndexEntry
	end: TimeIndexEntry
	count: Int!
	"""
	Fetch one "page" of items, optionally offset by a specified amount.
	
	* `limit` - The size of the page (number of items to fetch).
	* `offset` - The number of items to skip (defaults to 0).
	* `page_index` - The number of pages (of size `limit`) to skip (defaults to 0).
	
	e.g. if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [Edge!]!
	list: [Edge!]!
}

input EdgesViewCollection @oneOf {
	defaultLayer: Boolean
	latest: Boolean
	snapshotLatest: Boolean
	snapshotAt: TimeInput
	layers: [String!]
	excludeLayers: [String!]
	layer: String
	excludeLayer: String
	window: Window
	at: TimeInput
	before: TimeInput
	after: TimeInput
	shrinkWindow: Window
	shrinkStart: TimeInput
	shrinkEnd: TimeInput
}

type EdgesWindowSet {
	count: Int!
	"""
	Fetch one "page" of items, optionally offset by a specified amount.
	
	* `limit` - The size of the page (number of items to fetch).
	* `offset` - The number of items to skip (defaults to 0).
	* `page_index` - The number of pages (of size `limit`) to skip (defaults to 0).
	
	e.g. if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [Edges!]!
	list: [Edges!]!
}


type GqlDocument {
	entity: DocumentEntity!
	content: String!
	embedding: [Float!]!
	score: Float!
}

type GqlIndexSpec {
	nodeMetadata: [String!]!
	nodeProperties: [String!]!
	edgeMetadata: [String!]!
	edgeProperties: [String!]!
}

type GqlVectorSelection {
	nodes: [Node!]!
	edges: [Edge!]!
	getDocuments: [GqlDocument!]!
	addNodes(nodes: [String!]!): GqlVectorSelection!
	addEdges(edges: [InputEdge!]!): GqlVectorSelection!
	expand(hops: Int!, window: VectorisedGraphWindow): GqlVectorSelection!
	expandEntitiesBySimilarity(query: String!, limit: Int!, window: VectorisedGraphWindow): GqlVectorSelection!
	expandNodesBySimilarity(query: String!, limit: Int!, window: VectorisedGraphWindow): GqlVectorSelection!
	expandEdgesBySimilarity(query: String!, limit: Int!, window: VectorisedGraphWindow): GqlVectorSelection!
}

type Graph {
	uniqueLayers: [String!]!
	defaultLayer: Graph!
	layers(names: [String!]!): Graph!
	excludeLayers(names: [String!]!): Graph!
	layer(name: String!): Graph!
	excludeLayer(name: String!): Graph!
	subgraph(nodes: [String!]!): Graph!
	valid: Graph!
	subgraphNodeTypes(nodeTypes: [String!]!): Graph!
	excludeNodes(nodes: [String!]!): Graph!
	rolling(window: WindowDuration!, step: WindowDuration): GraphWindowSet!
	expanding(step: WindowDuration!): GraphWindowSet!
	"""
	Return a graph containing only the activity between `start` and `end` measured as milliseconds from epoch
	"""
	window(start: TimeInput!, end: TimeInput!): Graph!
	at(time: TimeInput!): Graph!
	latest: Graph!
	snapshotAt(time: TimeInput!): Graph!
	snapshotLatest: Graph!
	before(time: TimeInput!): Graph!
	after(time: TimeInput!): Graph!
	shrinkWindow(start: TimeInput!, end: TimeInput!): Graph!
	shrinkStart(start: TimeInput!): Graph!
	shrinkEnd(end: TimeInput!): Graph!
	created: Int!
	lastOpened: Int!
	lastUpdated: Int!
	earliestTime: TimeIndexEntry
	latestTime: TimeIndexEntry
	start: TimeIndexEntry
	end: TimeIndexEntry
	earliestEdgeTime(includeNegative: Boolean): TimeIndexEntry
	latestEdgeTime(includeNegative: Boolean): TimeIndexEntry
	countEdges: Int!
	countTemporalEdges: Int!
	countNodes: Int!
	hasNode(name: String!): Boolean!
	hasEdge(src: String!, dst: String!, layer: String): Boolean!
	node(name: String!): Node
	"""
	query (optionally a subset of) the nodes in the graph
	"""
	nodes(ids: [String!]): Nodes!
	edge(src: String!, dst: String!): Edge
	edges: Edges!
	properties: Properties!
	metadata: Metadata!
	name: String!
	path: String!
	namespace: String!
	schema: GraphSchema!
	algorithms: GraphAlgorithmPlugin!
	sharedNeighbours(selectedNodes: [String!]!): [Node!]!
	"""
	Export all nodes and edges from this graph view to another existing graph
	"""
	exportTo(path: String!): Boolean!
	nodeFilter(filter: NodeFilter!): Graph!
	edgeFilter(filter: EdgeFilter!): Graph!
	getIndexSpec: GqlIndexSpec!
	searchNodes(filter: NodeFilter!, limit: Int!, offset: Int!): [Node!]!
	searchEdges(filter: EdgeFilter!, limit: Int!, offset: Int!): [Edge!]!
	applyViews(views: [GraphViewCollection!]!): Graph!
}

type GraphAlgorithmPlugin {
	pagerank(iterCount: Int!, threads: Int, tol: Float): [PagerankOutput!]!
	shortest_path(source: String!, targets: [String!]!, direction: String): [ShortestPathOutput!]!
}

type GraphSchema {
	nodes: [NodeSchema!]!
	layers: [LayerSchema!]!
}

enum GraphType {
	PERSISTENT
	EVENT
}

input GraphViewCollection @oneOf {
	defaultLayer: Boolean
	layers: [String!]
	excludeLayers: [String!]
	layer: String
	excludeLayer: String
	subgraph: [String!]
	subgraphNodeTypes: [String!]
	excludeNodes: [String!]
	valid: Boolean
	window: Window
	at: TimeInput
	latest: Boolean
	snapshotAt: TimeInput
	snapshotLatest: Boolean
	before: TimeInput
	after: TimeInput
	shrinkWindow: Window
	shrinkStart: TimeInput
	shrinkEnd: TimeInput
	nodeFilter: NodeFilter
	edgeFilter: EdgeFilter
}

type GraphWindowSet {
	count: Int!
	"""
	Fetch one "page" of items, optionally offset by a specified amount.
	
	* `limit` - The size of the page (number of items to fetch).
	* `offset` - The number of items to skip (defaults to 0).
	* `page_index` - The number of pages (of size `limit`) to skip (defaults to 0).
	
	e.g. if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [Graph!]!
	list: [Graph!]!
}

"""
History of updates for an object in Raphtory.
Provides access to temporal properties.
"""
type History {
	"""
	Get the earliest time entry associated with this history or None if the history is empty.
	"""
	earliestTime: TimeIndexEntry
	"""
	Get the latest time entry associated with this history or None if the history is empty.
	"""
	latestTime: TimeIndexEntry
	"""
	List all time entries present in this history.
	"""
	list: [TimeIndexEntry!]!
	"""
	List all time entries present in this history in reverse order.
	"""
	listRev: [TimeIndexEntry!]!
	"""
	Fetch one page of TimeIndexEntry entries with a number of items up to a specified limit,
	optionally offset by a specified amount. The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [TimeIndexEntry!]!
	"""
	Fetch one page of TimeIndexEntry entries with a number of items up to a specified limit,
	optionally offset by a specified amount. The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page_rev(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	pageRev(limit: Int!, offset: Int, pageIndex: Int): [TimeIndexEntry!]!
	"""
	Returns True if the history is empty.
	"""
	isEmpty: Boolean!
	"""
	Get the number of entries contained in the history.
	"""
	count: Int!
	"""
	Returns a HistoryTimestamp object which accesses timestamps as Unix epochs in milliseconds
	instead of TimeIndexEntry entries.
	"""
	timestamps: HistoryTimestamp!
	"""
	Returns a HistoryDateTime object which accesses datetimes instead of TimeIndexEntry entries.
	Useful for converting millisecond timestamps into easily readable datetime strings.
	Optionally, a format string can be passed to format the output. Defaults to RFC 3339 if not provided (e.g., "2023-12-25T10:30:45.123Z").
	Refer to chrono::format::strftime for formatting specifiers and escape sequences.
	"""
	datetimes(formatString: String): HistoryDateTime!
	"""
	Returns a HistorySecondaryIndex object which accesses secondary indices of TimeIndexEntry entries.
	They are used for ordering within the same timestamp.
	"""
	secondaryIndex: HistorySecondaryIndex!
	"""
	Returns an Intervals object which calculates the intervals between consecutive TimeIndexEntry timestamps.
	"""
	intervals: Intervals!
}

"""
History object that provides access to datetimes instead of `TimeIndexEntry` entries.
"""
type HistoryDateTime {
	"""
	List all datetimes formatted as strings.
	If filter_broken is set to True, time conversion errors will be ignored. If set to False, a TimeError
	will be raised on time conversion error. Defaults to False.
	"""
	list(filterBroken: Boolean): [String!]!
	"""
	List all datetimes formatted as strings in reverse chronological order.
	If filter_broken is set to True, time conversion errors will be ignored. If set to False, a TimeError
	will be raised on time conversion error. Defaults to False.
	"""
	listRev(filterBroken: Boolean): [String!]!
	"""
	Fetch one page of datetimes formatted as string with a number of items up to a specified limit,
	optionally offset by a specified amount. The page_index sets the number of pages to skip (defaults to 0).
	If filter_broken is set to True, time conversion errors will be ignored. If set to False, a TimeError
	will be raised on time conversion error. Defaults to False.
	
	For example, if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int, filterBroken: Boolean): [String!]!
	"""
	Fetch one page of datetimes formatted as string in reverse chronological order with a number of items up to a specified limit,
	optionally offset by a specified amount. The page_index sets the number of pages to skip (defaults to 0).
	If filter_broken is set to True, time conversion errors will be ignored. If set to False, a TimeError
	will be raised on time conversion error. Defaults to False.
	
	For example, if page_rev(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	pageRev(limit: Int!, offset: Int, pageIndex: Int, filterBroken: Boolean): [String!]!
}

"""
History object that provides access to secondary indices instead of `TimeIndexEntry` entries.
"""
type HistorySecondaryIndex {
	"""
	List secondary indices.
	"""
	list: [Int!]!
	"""
	List secondary indices in reverse order.
	"""
	listRev: [Int!]!
	"""
	Fetch one page of secondary indices with a number of items up to a specified limit,
	optionally offset by a specified amount. The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [Int!]!
	"""
	Fetch one page of secondary indices in reverse chronological order with a number of items up to a specified limit,
	optionally offset by a specified amount. The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page_rev(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	pageRev(limit: Int!, offset: Int, pageIndex: Int): [Int!]!
}

"""
History object that provides access to timestamps (as Unix epochs in milliseconds) instead of `TimeIndexEntry` entries.
"""
type HistoryTimestamp {
	"""
	List all timestamps.
	"""
	list: [Int!]!
	"""
	List all timestamps in reverse order.
	"""
	listRev: [Int!]!
	"""
	Fetch one page of timestamps with a number of items up to a specified limit, optionally offset by a specified amount.
	The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [Int!]!
	"""
	Fetch one page of timestamps in reverse order with a number of items up to a specified limit,
	optionally offset by a specified amount. The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page_rev(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	pageRev(limit: Int!, offset: Int, pageIndex: Int): [Int!]!
}


input IndexSpecInput {
	nodeProps: PropsInput!
	edgeProps: PropsInput!
}

"""
Input for indexed time entries.
"""
input IndexedTimeInput {
	time: SimpleTimeInput!
	secondaryIndex: Int!
}

input InputEdge {
	src: String!
	dst: String!
}


"""
Provides access to the intervals between temporal entries of an object.
"""
type Intervals {
	"""
	List time intervals between consecutive timestamps in milliseconds.
	"""
	list: [Int!]!
	"""
	List millisecond time intervals between consecutive timestamps in reverse order.
	"""
	listRev: [Int!]!
	"""
	Fetch one page of intervals between consecutive timestamps with a number of items up to a specified limit,
	optionally offset by a specified amount. The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [Int!]!
	"""
	Fetch one page of intervals between consecutive timestamps in reverse order with a number of items up to a specified limit,
	optionally offset by a specified amount. The page_index sets the number of pages to skip (defaults to 0).
	
	For example, if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	pageRev(limit: Int!, offset: Int, pageIndex: Int): [Int!]!
	"""
	Compute the mean interval between consecutive timestamps. Returns None if fewer than 1 timestamp.
	"""
	mean: Float
	"""
	Compute the median interval between consecutive timestamps. Returns None if fewer than 1 timestamp.
	"""
	median: Int
	"""
	Compute the maximum interval between consecutive timestamps. Returns None if fewer than 1 timestamp.
	"""
	max: Int
	"""
	Compute the minimum interval between consecutive timestamps. Returns None if fewer than 1 timestamp.
	"""
	min: Int
}

type LayerSchema {
	"""
	Returns the name of the layer with this schema
	"""
	name: String!
	"""
	Returns the list of edge schemas for this edge layer
	"""
	edges: [EdgeSchema!]!
}

type MetaGraph {
	name: String
	path: String!
	created: Int!
	lastOpened: Int!
	lastUpdated: Int!
	nodeCount: Int!
	edgeCount: Int!
	metadata: [Property!]!
}

type Metadata {
	get(key: String!): Property
	contains(key: String!): Boolean!
	keys: [String!]!
	values(keys: [String!]): [Property!]!
}

input MetadataFilterExpr {
	name: String!
	operator: Operator!
	value: Value
}

type MutRoot {
	plugins: MutationPlugin!
	deleteGraph(path: String!): Boolean!
	newGraph(path: String!, graphType: GraphType!): Boolean!
	moveGraph(path: String!, newPath: String!): Boolean!
	copyGraph(path: String!, newPath: String!): Boolean!
	"""
	Use GQL multipart upload to send new graphs to server
	
	Returns::
	name of the new graph
	"""
	uploadGraph(path: String!, graph: Upload!, overwrite: Boolean!): String!
	"""
	Send graph bincode as base64 encoded string
	
	Returns::
	path of the new graph
	"""
	sendGraph(path: String!, graph: String!, overwrite: Boolean!): String!
	"""
	Create a subgraph out of some existing graph in the server
	
	Returns::
	name of the new graph
	"""
	createSubgraph(parentPath: String!, nodes: [String!]!, newPath: String!, overwrite: Boolean!): String!
	createIndex(path: String!, indexSpec: IndexSpecInput, inRam: Boolean!): Boolean!
}

type MutableEdge {
	"""
	Use to check if adding the edge was successful
	"""
	success: Boolean!
	"""
	Get the non-mutable edge for querying
	"""
	edge: Edge!
	"""
	Get the mutable source node of the edge
	"""
	src: MutableNode!
	"""
	Get the mutable destination node of the edge
	"""
	dst: MutableNode!
	"""
	Mark the edge as deleted at time `time`
	"""
	delete(time: Int!, layer: String): Boolean!
	"""
	Add metadata to the edge (errors if the value already exists)
	
	If this is called after `add_edge`, the layer is inherited from the `add_edge` and does not
	need to be specified again.
	"""
	addMetadata(properties: [PropertyInput!]!, layer: String): Boolean!
	"""
	Update metadata of the edge (existing values are overwritten)
	
	If this is called after `add_edge`, the layer is inherited from the `add_edge` and does not
	need to be specified again.
	"""
	updateMetadata(properties: [PropertyInput!]!, layer: String): Boolean!
	"""
	Add temporal property updates to the edge
	
	If this is called after `add_edge`, the layer is inherited from the `add_edge` and does not
	need to be specified again.
	"""
	addUpdates(time: Int!, properties: [PropertyInput!], layer: String): Boolean!
}

type MutableGraph {
	"""
	Get the non-mutable graph
	"""
	graph: Graph!
	"""
	Get mutable existing node
	"""
	node(name: String!): MutableNode
	"""
	Add a new node or add updates to an existing node
	"""
	addNode(time: Int!, name: String!, properties: [PropertyInput!], nodeType: String): MutableNode!
	"""
	Create a new node or fail if it already exists
	"""
	createNode(time: Int!, name: String!, properties: [PropertyInput!], nodeType: String): MutableNode!
	"""
	Add a batch of nodes
	"""
	addNodes(nodes: [NodeAddition!]!): Boolean!
	"""
	Get a mutable existing edge
	"""
	edge(src: String!, dst: String!): MutableEdge
	"""
	Add a new edge or add updates to an existing edge
	"""
	addEdge(time: Int!, src: String!, dst: String!, properties: [PropertyInput!], layer: String): MutableEdge!
	"""
	Add a batch of edges
	"""
	addEdges(edges: [EdgeAddition!]!): Boolean!
	"""
	Mark an edge as deleted (creates the edge if it did not exist)
	"""
	deleteEdge(time: Int!, src: String!, dst: String!, layer: String): MutableEdge!
	"""
	Add temporal properties to graph
	"""
	addProperties(t: Int!, properties: [PropertyInput!]!): Boolean!
	"""
	Add metadata to graph (errors if the property already exists)
	"""
	addMetadata(properties: [PropertyInput!]!): Boolean!
	"""
	Update metadata of the graph (overwrites existing values)
	"""
	updateMetadata(properties: [PropertyInput!]!): Boolean!
}

type MutableNode {
	"""
	Use to check if adding the node was successful
	"""
	success: Boolean!
	"""
	Get the non-mutable `Node`
	"""
	node: Node!
	"""
	Add metadata to the node (errors if the property already exists)
	"""
	addMetadata(properties: [PropertyInput!]!): Boolean!
	"""
	Set the node type (errors if the node already has a non-default type)
	"""
	setNodeType(newType: String!): Boolean!
	"""
	Update metadata of the node (overwrites existing property values)
	"""
	updateMetadata(properties: [PropertyInput!]!): Boolean!
	"""
	Add temporal property updates to the node
	"""
	addUpdates(time: Int!, properties: [PropertyInput!]): Boolean!
}

type MutationPlugin {
	NoOps: String!
}

type Namespace {
	graphs: CollectionOfMetaGraph!
	path: String!
	parent: Namespace
	children: CollectionOfNamespace!
	items: CollectionOfNamespacedItem!
}

union NamespacedItem = Namespace | MetaGraph

type Node {
	id: String!
	name: String!
	defaultLayer: Node!
	layers(names: [String!]!): Node!
	excludeLayers(names: [String!]!): Node!
	layer(name: String!): Node!
	excludeLayer(name: String!): Node!
	rolling(window: WindowDuration!, step: WindowDuration): NodeWindowSet!
	expanding(step: WindowDuration!): NodeWindowSet!
	window(start: TimeInput!, end: TimeInput!): Node!
	at(time: TimeInput!): Node!
	latest: Node!
	snapshotAt(time: TimeInput!): Node!
	snapshotLatest: Node!
	before(time: TimeInput!): Node!
	after(time: TimeInput!): Node!
	shrinkWindow(start: TimeInput!, end: TimeInput!): Node!
	shrinkStart(start: TimeInput!): Node!
	shrinkEnd(end: TimeInput!): Node!
	applyViews(views: [NodeViewCollection!]!): Node!
	earliestTime: TimeIndexEntry
	firstUpdate: TimeIndexEntry
	latestTime: TimeIndexEntry
	lastUpdate: TimeIndexEntry
	start: TimeIndexEntry
	end: TimeIndexEntry
	history: History!
	edgeHistoryCount: Int!
	isActive: Boolean!
	nodeType: String
	properties: Properties!
	metadata: Metadata!
	"""
	Returns the number of edges connected to this node
	"""
	degree: Int!
	"""
	Returns the number edges with this node as the source
	"""
	outDegree: Int!
	"""
	Returns the number edges with this node as the destination
	"""
	inDegree: Int!
	inComponent: Nodes!
	outComponent: Nodes!
	edges: Edges!
	outEdges: Edges!
	inEdges: Edges!
	neighbours: PathFromNode!
	inNeighbours: PathFromNode!
	outNeighbours: PathFromNode!
	nodeFilter(filter: NodeFilter!): Node!
}

input NodeAddition {
	name: String!
	nodeType: String
	metadata: [PropertyInput!]
	updates: [TemporalPropertyInput!]
}

enum NodeField {
	NODE_NAME
	NODE_TYPE
}

input NodeFieldFilter {
	field: NodeField!
	operator: Operator!
	value: Value!
}

input NodeFilter @oneOf {
	node: NodeFieldFilter
	property: PropertyFilterExpr
	metadata: MetadataFilterExpr
	temporalProperty: TemporalPropertyFilterExpr
	and: [NodeFilter!]
	or: [NodeFilter!]
	not: NodeFilter
}

type NodeSchema {
	typeName: String!
	"""
	Returns the list of property schemas for this node
	"""
	properties: [PropertySchema!]!
	metadata: [PropertySchema!]!
}

input NodeSortBy {
	reverse: Boolean
	id: Boolean
	time: SortByTime
	property: String
}

input NodeViewCollection @oneOf {
	defaultLayer: Boolean
	latest: Boolean
	snapshotLatest: Boolean
	snapshotAt: TimeInput
	layers: [String!]
	excludeLayers: [String!]
	layer: String
	excludeLayer: String
	window: Window
	at: TimeInput
	before: TimeInput
	after: TimeInput
	shrinkWindow: Window
	shrinkStart: TimeInput
	shrinkEnd: TimeInput
	nodeFilter: NodeFilter
}

type NodeWindowSet {
	count: Int!
	"""
	Fetch one "page" of items, optionally offset by a specified amount.
	
	* `limit` - The size of the page (number of items to fetch).
	* `offset` - The number of items to skip (defaults to 0).
	* `page_index` - The number of pages (of size `limit`) to skip (defaults to 0).
	
	e.g. if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [Node!]!
	list: [Node!]!
}

type Nodes {
	defaultLayer: Nodes!
	layers(names: [String!]!): Nodes!
	excludeLayers(names: [String!]!): Nodes!
	layer(name: String!): Nodes!
	excludeLayer(name: String!): Nodes!
	rolling(window: WindowDuration!, step: WindowDuration): NodesWindowSet!
	expanding(step: WindowDuration!): NodesWindowSet!
	window(start: TimeInput!, end: TimeInput!): Nodes!
	at(time: TimeInput!): Nodes!
	latest: Nodes!
	snapshotAt(time: TimeInput!): Nodes!
	snapshotLatest: Nodes!
	before(time: TimeInput!): Nodes!
	after(time: TimeInput!): Nodes!
	shrinkWindow(start: TimeInput!, end: TimeInput!): Nodes!
	shrinkStart(start: TimeInput!): Nodes!
	shrinkEnd(end: TimeInput!): Nodes!
	typeFilter(nodeTypes: [String!]!): Nodes!
	nodeFilter(filter: NodeFilter!): Nodes!
	applyViews(views: [NodesViewCollection!]!): Nodes!
	sorted(sortBys: [NodeSortBy!]!): Nodes!
	start: TimeIndexEntry
	end: TimeIndexEntry
	count: Int!
	"""
	Fetch one "page" of items, optionally offset by a specified amount.
	
	* `limit` - The size of the page (number of items to fetch).
	* `offset` - The number of items to skip (defaults to 0).
	* `page_index` - The number of pages (of size `limit`) to skip (defaults to 0).
	
	e.g. if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [Node!]!
	list: [Node!]!
	ids: [String!]!
}

input NodesViewCollection @oneOf {
	defaultLayer: Boolean
	latest: Boolean
	snapshotLatest: Boolean
	layers: [String!]
	excludeLayers: [String!]
	layer: String
	excludeLayer: String
	window: Window
	at: TimeInput
	snapshotAt: TimeInput
	before: TimeInput
	after: TimeInput
	shrinkWindow: Window
	shrinkStart: TimeInput
	shrinkEnd: TimeInput
	nodeFilter: NodeFilter
	typeFilter: [String!]
}

type NodesWindowSet {
	count: Int!
	"""
	Fetch one "page" of items, optionally offset by a specified amount.
	
	* `limit` - The size of the page (number of items to fetch).
	* `offset` - The number of items to skip (defaults to 0).
	* `page_index` - The number of pages (of size `limit`) to skip (defaults to 0).
	
	e.g. if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [Nodes!]!
	list: [Nodes!]!
}

input ObjectEntry {
	key: String!
	value: Value!
}

enum Operator {
	EQUAL
	NOT_EQUAL
	GREATER_THAN_OR_EQUAL
	LESS_THAN_OR_EQUAL
	GREATER_THAN
	LESS_THAN
	IS_NONE
	IS_SOME
	IS_IN
	IS_NOT_IN
	CONTAINS
	NOT_CONTAINS
}

type PagerankOutput {
	name: String!
	rank: Float!
}

type PathFromNode {
	layers(names: [String!]!): PathFromNode!
	excludeLayers(names: [String!]!): PathFromNode!
	layer(name: String!): PathFromNode!
	excludeLayer(name: String!): PathFromNode!
	rolling(window: WindowDuration!, step: WindowDuration): PathFromNodeWindowSet!
	expanding(step: WindowDuration!): PathFromNodeWindowSet!
	window(start: TimeInput!, end: TimeInput!): PathFromNode!
	at(time: TimeInput!): PathFromNode!
	snapshotLatest: PathFromNode!
	snapshotAt(time: TimeInput!): PathFromNode!
	latest: PathFromNode!
	before(time: TimeInput!): PathFromNode!
	after(time: TimeInput!): PathFromNode!
	shrinkWindow(start: TimeInput!, end: TimeInput!): PathFromNode!
	shrinkStart(start: TimeInput!): PathFromNode!
	shrinkEnd(end: TimeInput!): PathFromNode!
	typeFilter(nodeTypes: [String!]!): PathFromNode!
	start: TimeIndexEntry
	end: TimeIndexEntry
	count: Int!
	"""
	Fetch one "page" of items, optionally offset by a specified amount.
	
	* `limit` - The size of the page (number of items to fetch).
	* `offset` - The number of items to skip (defaults to 0).
	* `page_index` - The number of pages (of size `limit`) to skip (defaults to 0).
	
	e.g. if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [Node!]!
	list: [Node!]!
	ids: [String!]!
	applyViews(views: [PathFromNodeViewCollection!]!): PathFromNode!
}

input PathFromNodeViewCollection @oneOf {
	latest: Boolean
	snapshotLatest: Boolean
	snapshotAt: TimeInput
	layers: [String!]
	excludeLayers: [String!]
	layer: String
	excludeLayer: String
	window: Window
	at: TimeInput
	before: TimeInput
	after: TimeInput
	shrinkWindow: Window
	shrinkStart: TimeInput
	shrinkEnd: TimeInput
}

type PathFromNodeWindowSet {
	count: Int!
	"""
	Fetch one "page" of items, optionally offset by a specified amount.
	
	* `limit` - The size of the page (number of items to fetch).
	* `offset` - The number of items to skip (defaults to 0).
	* `page_index` - The number of pages (of size `limit`) to skip (defaults to 0).
	
	e.g. if page(5, 2, 1) is called, a page with 5 items, offset by 11 items (2 pages of 5 + 1),
	will be returned.
	"""
	page(limit: Int!, offset: Int, pageIndex: Int): [PathFromNode!]!
	list: [PathFromNode!]!
}

type Properties {
	get(key: String!): Property
	contains(key: String!): Boolean!
	keys: [String!]!
	values(keys: [String!]): [Property!]!
	temporal: TemporalProperties!
}

type Property {
	key: String!
	asString: String!
	value: PropertyOutput!
}

input PropertyFilterExpr {
	name: String!
	operator: Operator!
	value: Value
}

input PropertyInput {
	key: String!
	value: Value!
}

scalar PropertyOutput

type PropertySchema {
	key: String!
	propertyType: String!
	variants: [String!]!
}

type PropertyTuple {
	time: TimeIndexEntry!
	asString: String!
	value: PropertyOutput!
}

input PropsInput @oneOf {
	all: AllPropertySpec
	some: SomePropertySpec
}

type QueryPlugin {
	NoOps: String!
}

type QueryRoot {
	hello: String!
	"""
	Returns a graph
	"""
	graph(path: String!): Graph!
	updateGraph(path: String!): MutableGraph!
	vectorisedGraph(path: String!): VectorisedGraph
	namespaces: CollectionOfNamespace!
	namespace(path: String!): Namespace!
	root: Namespace!
	plugins: QueryPlugin!
	receiveGraph(path: String!): String!
}

type ShortestPathOutput {
	target: String!
	nodes: [String!]!
}

"""
Input for primary time component. Int or DateTime formatted String.
Valid formats are RFC3339, RFC2822, %Y-%m-%d, %Y-%m-%dT%H:%M:%S%.3f, %Y-%m-%dT%H:%M:%S%,
%Y-%m-%d %H:%M:%S%.3f and %Y-%m-%d %H:%M:%S%.
"""
scalar SimpleTimeInput

input SomePropertySpec {
	metadata: [String!]!
	properties: [String!]!
}

enum SortByTime {
	LATEST
	EARLIEST
}


type TemporalProperties {
	get(key: String!): TemporalProperty
	contains(key: String!): Boolean!
	keys: [String!]!
	values(keys: [String!]): [TemporalProperty!]!
}

type TemporalProperty {
	key: String!
	history: History!
	values: [String!]!
	at(t: Int!): String
	latest: String
	unique: [String!]!
	orderedDedupe(latestTime: Boolean!): [PropertyTuple!]!
}

input TemporalPropertyFilterExpr {
	name: String!
	temporal: TemporalType!
	operator: Operator!
	value: Value
}

input TemporalPropertyInput {
	time: Int!
	properties: [PropertyInput!]
}

enum TemporalType {
	ANY
	LATEST
}

"""
Time index entry with timestamp and secondary index for ordering.
"""
type TimeIndexEntry {
	"""
	Get the timestamp in milliseconds since Unix epoch.
	"""
	timestamp: Int!
	"""
	Get the secondary index for the time entry. Used for ordering within the same timestamp.
	"""
	secondaryIndex: Int!
	"""
	Access a datetime representation of the TimeIndexEntry as a String.
	Useful for converting millisecond timestamps into easily readable datetime strings.
	Optionally, a format string can be passed to format the output.
	Defaults to RFC 3339 if not provided (e.g., "2023-12-25T10:30:45.123Z").
	Refer to chrono::format::strftime for formatting specifiers and escape sequences.
	Raises TimeError if a time conversion fails.
	"""
	datetime(formatString: String): String!
}

"""
Input for simple or indexed time entries.
"""
input TimeInput @oneOf {
	simpleTime: SimpleTimeInput
	indexedTime: IndexedTimeInput
}

scalar Upload

input Value @oneOf {
	u64: Int
	i64: Int
	f64: Float
	str: String
	bool: Boolean
	list: [Value!]
	object: [ObjectEntry!]
}

type VectorisedGraph {
	emptySelection: GqlVectorSelection!
	entitiesBySimilarity(query: String!, limit: Int!, window: VectorisedGraphWindow): GqlVectorSelection!
	nodesBySimilarity(query: String!, limit: Int!, window: VectorisedGraphWindow): GqlVectorSelection!
	edgesBySimilarity(query: String!, limit: Int!, window: VectorisedGraphWindow): GqlVectorSelection!
}

input VectorisedGraphWindow {
	start: Int!
	end: Int!
}

input Window {
	start: TimeInput!
	end: TimeInput!
}

input WindowDuration @oneOf {
	duration: String
	epoch: Int
}

directive @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
directive @oneOf on INPUT_OBJECT
directive @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
directive @specifiedBy(url: String!) on SCALAR
schema {
	query: QueryRoot
	mutation: MutRoot
}
