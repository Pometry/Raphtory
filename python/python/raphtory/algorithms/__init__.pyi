###############################################################################
#                                                                             #
#                      AUTOGENERATED TYPE STUB FILE                           #
#                                                                             #
#    This file was automatically generated. Do not modify it directly.        #
#    Any changes made here may be lost when the file is regenerated.          #
#                                                                             #
###############################################################################

from typing import *
from raphtory import *
from raphtory.vectors import *
from raphtory.graphql import *
from raphtory.typing import *
from datetime import datetime
from pandas import DataFrame

def all_local_reciprocity(g: GraphView):
    """
    Local reciprocity - measure of the symmetry of relationships associated with a node

    This measures the proportion of a node's outgoing edges which are reciprocated with an incoming edge.

    Arguments:
        g (GraphView) : a directed Raphtory graph

    Returns:
        AlgorithmResult : AlgorithmResult with string keys and float values mapping each node name to its reciprocity value.

    """

def average_degree(g: GraphView):
    """
    The average (undirected) degree of all nodes in the graph.

    Note that this treats the graph as simple and undirected and is equal to twice
    the number of undirected edges divided by the number of nodes.

    Arguments:
        g (GraphView) : a Raphtory graph

    Returns:
        float : the average degree of the nodes in the graph
    """

def balance(
    g: GraphView,
    name: str = "weight",
    direction: Direction = "both",
    threads: Optional[int] = None,
) -> AlgorithmResult:
    """
    Sums the weights of edges in the graph based on the specified direction.

    This function computes the sum of edge weights based on the direction provided, and can be executed in parallel using a given number of threads.

    Arguments:
        g (GraphView): The graph view on which the operation is to be performed.
        name (str): The name of the edge property used as the weight. Defaults to "weight".
        direction (Direction): Specifies the direction of the edges to be considered for summation. Defaults to "both".
                * "out": Only consider outgoing edges.
                * "in": Only consider incoming edges.
                * "both": Consider both outgoing and incoming edges. This is the default.
        threads (int, optional): The number of threads to be used for parallel execution.

    Returns:
        AlgorithmResult: A result containing a mapping of node names to the computed sum of their associated edge weights.

    """

def betweenness_centrality(
    g: GraphView, k: Optional[int] = None, normalized: bool = True
) -> AlgorithmResult:
    """
    Computes the betweenness centrality for nodes in a given graph.

    Arguments:
        g (GraphView): A reference to the graph.
        k (int, optional): Specifies the number of nodes to consider for the centrality computation.
            All nodes are considered by default.
        normalized (bool): Indicates whether to normalize the centrality values.

    Returns:
        AlgorithmResult: Returns an `AlgorithmResult` containing the betweenness centrality of each node.
    """

def cohesive_fruchterman_reingold(
    graph, iterations=100, scale=1.0, node_start_size=1.0, cooloff_factor=0.95, dt=0.1
):
    """Cohesive version of `fruchterman_reingold` that adds virtual edges between isolated nodes"""

def connected_components(g): ...
def degree_centrality(g: GraphView, threads: Optional[int] = None) -> AlgorithmResult:
    """
    Computes the degree centrality of all nodes in the graph. The values are normalized
    by dividing each result with the maximum possible degree. Graphs with self-loops can have
    values of centrality greater than 1.

    Arguments:
        g (GraphView): The graph view on which the operation is to be performed.
        threads (int, optional): The number of threads to be used for parallel execution.

    Returns:
        AlgorithmResult: A result containing a mapping of node names to the computed sum of their associated degree centrality.
    """

def dijkstra_single_source_shortest_paths(
    g: GraphView,
    source: InputNode,
    targets: list[InputNode],
    direction: Direction = "both",
    weight: str = "weight",
) -> dict:
    """
    Finds the shortest paths from a single source to multiple targets in a graph.

    Arguments:
        g (GraphView): The graph to search in.
        source (InputNode): The source node.
        targets (list[InputNode]): A list of target nodes.
        direction (Direction): The direction of the edges to be considered for the shortest path. Defaults to "both".
        weight (str): The name of the weight property for the edges. Defaults to "weight".

    Returns:
        dict: Returns a `Dict` where the key is the target node and the value is a tuple containing the total cost and a vector of nodes representing the shortest path.

    """

def directed_graph_density(g: GraphView):
    """
    Graph density - measures how dense or sparse a graph is.

    The ratio of the number of directed edges in the graph to the total number of possible directed
    edges (given by N * (N-1) where N is the number of nodes).

    Arguments:
        g (GraphView) : a directed Raphtory graph

    Returns:
        float : Directed graph density of G.
    """

def fruchterman_reingold(
    graph: GraphView,
    iterations: int | None = 100,
    scale: float | None = 1.0,
    node_start_size: float | None = 1.0,
    cooloff_factor: float | None = 0.95,
    dt: float | None = 0.1,
):
    """
    Fruchterman Reingold layout algorithm

    Arguments:
        graph (GraphView): the graph view
        iterations (int | None): the number of iterations to run (default: 100)
        scale (float | None): the scale to apply (default: 1.0)
        node_start_size (float | None): the start node size to assign random positions (default: 1.0)
        cooloff_factor (float | None): the cool off factor for the algorithm (default: 0.95)
        dt (float | None): the time increment between iterations (default: 0.1)

    Returns:
        a dict with the position for each node as a list with two numbers [x, y]
    """

def global_clustering_coefficient(g: GraphView):
    """
    Computes the global clustering coefficient of a graph. The global clustering coefficient is
    defined as the number of triangles in the graph divided by the number of triplets in the graph.

    Note that this is also known as transitivity and is different to the average clustering coefficient.

    Arguments:
        g (GraphView) : a Raphtory graph, treated as undirected

    Returns:
        float : the global clustering coefficient of the graph

    See also:
        [`Triplet Count`](triplet_count)
    """

def global_reciprocity(g: GraphView):
    """
    Reciprocity - measure of the symmetry of relationships in a graph, the global reciprocity of
    the entire graph.
    This calculates the number of reciprocal connections (edges that go in both directions) in a
    graph and normalizes it by the total number of directed edges.

    Arguments:
        g (GraphView) : a directed Raphtory graph

    Returns:
        float : reciprocity of the graph between 0 and 1.
    """

def global_temporal_three_node_motif(g: GraphView, delta: int):
    """
    Computes the number of three edge, up-to-three node delta-temporal motifs in the graph, using the algorithm of Paranjape et al, Motifs in Temporal Networks (2017).
    We point the reader to this reference for more information on the algorithm and background, but provide a short summary below.

     Motifs included:

     Stars

     There are three classes (in the order they are outputted) of star motif on three nodes based on the switching behaviour of the edges between the two leaf nodes.

      - PRE: Stars of the form i<->j, i<->j, i<->k (ie two interactions with leaf j followed by one with leaf k)
      - MID: Stars of the form i<->j, i<->k, i<->j (ie switching interactions from leaf j to leaf k, back to j again)
      - POST: Stars of the form i<->j, i<->k, i<->k (ie one interaction with leaf j followed by two with leaf k)

     Within each of these classes is 8 motifs depending on the direction of the first to the last edge -- incoming "I" or outgoing "O".
     These are enumerated in the order III, IIO, IOI, IOO, OII, OIO, OOI, OOO (like binary with "I"-0 and "O"-1).

     Two node motifs:

     Also included are two node motifs, of which there are 8 when counted from the perspective of each node. These are characterised by the direction of each edge, enumerated
     in the above order. Note that for the global graph counts, each motif is counted in both directions (a single III motif for one node is an OOO motif for the other node).

     Triangles:

     There are 8 triangle motifs:

      1. i --> j, k --> j, i --> k
      2. i --> j, k --> j, k --> i
      3. i --> j, j --> k, i --> k
      4. i --> j, j --> k, k --> i
      5. i --> j, k --> i, j --> k
      6. i --> j, k --> i, k --> j
      7. i --> j, i --> k, j --> k
      8. i --> j, i --> k, k --> j

    Arguments:
        g (GraphView) : A directed raphtory graph
        delta (int): Maximum time difference between the first and last edge of the motif. NB if time for edges was given as a UNIX epoch, this should be given in seconds, otherwise milliseconds should be used (if edge times were given as string)

    Returns:
        list : A 40 dimensional array with the counts of each motif, given in the same order as described above. Note that the two-node motif counts are symmetrical so it may be more useful just to consider the first four elements.

    Notes:
        This is achieved by calling the local motif counting algorithm, summing the resulting arrays and dealing with overcounted motifs: the triangles (by dividing each motif count by three) and two-node motifs (dividing by two).

    """

def global_temporal_three_node_motif_multi(g: GraphView, deltas: list[int]):
    """
    Computes the global counts of three-edge up-to-three node temporal motifs for a range of timescales. See `global_temporal_three_node_motif` for an interpretation of each row returned.

    Arguments:
        g (GraphView) : A directed raphtory graph
        deltas(list[int]): A list of delta values to use.

    Returns:
        list[list[int]] : A list of 40d arrays, each array is the motif count for a particular value of delta, returned in the order that the deltas were given as input.
    """

def hits(g: GraphView, iter_count: int = 20, threads: Optional[int] = None):
    """
    HITS (Hubs and Authority) Algorithm:
    AuthScore of a node (A) = Sum of HubScore of all nodes pointing at node (A) from previous iteration /
        Sum of HubScore of all nodes in the current iteration

    HubScore of a node (A) = Sum of AuthScore of all nodes pointing away from node (A) from previous iteration /
        Sum of AuthScore of all nodes in the current iteration

    Arguments:
        g (GraphView): Graph to run the algorithm on
        iter_count (int): How many iterations to run the algorithm
        threads (int, optional): Number of threads to use

    Returns
        An AlgorithmResult object containing the mapping from node ID to the hub and authority score of the node
    """

def in_component(node: Node):
    """
    In component -- Finding the "in-component" of a node in a directed graph involves identifying all nodes that can be reached following only incoming edges.

    Arguments:
        node (Node) : The node whose in-component we wish to calculate

    Returns:
       An array containing the Nodes within the given nodes in-component
    """

def in_components(g: GraphView):
    """
    In components -- Finding the "in-component" of a node in a directed graph involves identifying all nodes that can be reached following only incoming edges.

    Arguments:
        g (GraphView) : Raphtory graph

    Returns:
        AlgorithmResult : AlgorithmResult object mapping each node to an array containing the ids of all nodes within their 'in-component'
    """

def label_propagation(g: GraphView, seed: Optional[bytes] = None) -> list[set[Node]]:
    """
    Computes components using a label propagation algorithm

    Arguments:
        g (GraphView): A reference to the graph
        seed (bytes, optional): Array of 32 bytes of u8 which is set as the rng seed

    Returns:
        list[set[Node]]: A list of sets each containing nodes that have been grouped

    """

def local_clustering_coefficient(g: GraphView, v: InputNode):
    """
    Local clustering coefficient - measures the degree to which nodes in a graph tend to cluster together.

    The proportion of pairs of neighbours of a node who are themselves connected.

    Arguments:
        g (GraphView) : Raphtory graph, can be directed or undirected but will be treated as undirected.
        v (InputNode): node id or name

    Returns:
        float : the local clustering coefficient of node v in g.
    """

def local_temporal_three_node_motifs(g: GraphView, delta: int):
    """
    Computes the number of each type of motif that each node participates in. See global_temporal_three_node_motifs for a summary of the motifs involved.

    Arguments:
        g (GraphView) : A directed raphtory graph
        delta (int): Maximum time difference between the first and last edge of the motif. NB if time for edges was given as a UNIX epoch, this should be given in seconds, otherwise milliseconds should be used (if edge times were given as string)

    Returns:
        dict : A dictionary with node ids as keys and a 40d array of motif counts as values (in the same order as the global motif counts) with the number of each motif that node participates in.

    Notes:
        For this local count, a node is counted as participating in a motif in the following way. For star motifs, only the centre node counts
       the motif. For two node motifs, both constituent nodes count the motif. For triangles, all three constituent nodes count the motif.
    """

def local_triangle_count(g: GraphView, v: InputNode):
    """
    Implementations of various graph algorithms that can be run on a graph.

    To run an algorithm simply import the module and call the function with the graph as the argument

    Local triangle count - calculates the number of triangles (a cycle of length 3) a node participates in.

    This function returns the number of pairs of neighbours of a given node which are themselves connected.

    Arguments:
        g (GraphView) : Raphtory graph, this can be directed or undirected but will be treated as undirected
        v (InputNode) : node id or name

    Returns:
        int : number of triangles associated with node v

    """

def louvain(
    graph: GraphView,
    resolution: float = 1.0,
    weight_prop: str | None = None,
    tol: None | float = None,
):
    """
    Louvain algorithm for community detection

    Arguments:
        graph (GraphView): the graph view
        resolution (float): the resolution paramter for modularity
        weight_prop (str | None): the edge property to use for weights (has to be float)
        tol (None | float): the floating point tolerance for deciding if improvements are significant (default: 1e-8)
    """

def max_degree(g: GraphView) -> int:
    """
    Returns the largest degree found in the graph

    Arguments:
        g (GraphView): The graph view on which the operation is to be performed.

    Returns:
        int: The largest degree
    """

def max_in_degree(g: GraphView):
    """
    The maximum in degree of any node in the graph.

    Arguments:
        g (GraphView) : a directed Raphtory graph

    Returns:
        int : value of the largest indegree
    """

def max_out_degree(g: GraphView):
    """
    The maximum out degree of any node in the graph.

    Arguments:
        g (GraphView) : a directed Raphtory graph

    Returns:
        int : value of the largest outdegree
    """

def min_degree(g: GraphView) -> int:
    """
    Returns the smallest degree found in the graph

    Arguments:
        g (GraphView): The graph view on which the operation is to be performed.

    Returns:
        int: The smallest degree found
    """

def min_in_degree(g: GraphView):
    """
    The minimum in degree of any node in the graph.

    Arguments:
        g (GraphView) : a directed Raphtory graph

    Returns:
        int : value of the smallest indegree
    """

def min_out_degree(g: GraphView):
    """
    The minimum out degree of any node in the graph.

    Arguments:
        g (GraphView) : a directed Raphtory graph

    Returns:
        int : value of the smallest outdegree
    """

def out_component(node: Node):
    """
    Out component -- Finding the "out-component" of a node in a directed graph involves identifying all nodes that can be reached following only outgoing edges.

    Arguments:
        node (Node) : The node whose out-component we wish to calculate

    Returns:
       An array containing the Nodes within the given nodes out-component
    """

def out_components(g: GraphView):
    """
    Out components -- Finding the "out-component" of a node in a directed graph involves identifying all nodes that can be reached following only outgoing edges.

    Arguments:
        g (GraphView) : Raphtory graph

    Returns:
        AlgorithmResult : AlgorithmResult object mapping each node to an array containing the ids of all nodes within their 'out-component'
    """

def pagerank(
    g: GraphView,
    iter_count: int = 20,
    max_diff: Optional[float] = None,
    use_l2_norm=True,
    damping_factor=0.85,
):
    """
    Pagerank -- pagerank centrality value of the nodes in a graph

    This function calculates the Pagerank value of each node in a graph. See https://en.wikipedia.org/wiki/PageRank for more information on PageRank centrality.
    A default damping factor of 0.85 is used. This is an iterative algorithm which terminates if the sum of the absolute difference in pagerank values between iterations
    is less than the max diff value given.

    Arguments:
        g (GraphView) : Raphtory graph
        iter_count (int) : Maximum number of iterations to run. Note that this will terminate early if convergence is reached.
        max_diff (Optional[float]) : Optional parameter providing an alternative stopping condition.
            The algorithm will terminate if the sum of the absolute difference in pagerank values between iterations
            is less than the max diff value given.

    Returns:
        AlgorithmResult : AlgorithmResult with string keys and float values mapping node names to their pagerank value.
    """

def single_source_shortest_path(
    g: GraphView, source: InputNode, cutoff: Optional[int] = None
) -> AlgorithmResult:
    """
    Calculates the single source shortest paths from a given source node.

    Arguments:
        g (GraphView): A reference to the graph. Must implement `GraphViewOps`.
        source (InputNode): The source node. Must implement `InputNode`.
        cutoff (int, optional): An optional cutoff level. The algorithm will stop if this level is reached.

    Returns:
        AlgorithmResult: Returns an `AlgorithmResult[str, list[str]]` containing the shortest paths from the source to all reachable nodes.

    """

def strongly_connected_components(g: GraphView):
    """
    Strongly connected components

    Partitions the graph into node sets which are mutually reachable by an directed path

    Arguments:
        g (GraphView) : Raphtory graph

    Returns:
        list[list[int]] : List of strongly connected nodes identified by ids
    """

def temporal_SEIR(
    graph: GraphView,
    seeds: int | float | list[Node],
    infection_prob: float,
    initial_infection: int | str | datetime,
    recovery_rate: float | None = None,
    incubation_rate: float | None = None,
    rng_seed: int | None = None,
) -> AlgorithmResult:
    """
    Simulate an SEIR dynamic on the network

    The algorithm uses the event-based sampling strategy from https://doi.org/10.1371/journal.pone.0246961

    Arguments:
        graph (GraphView): the graph view
        seeds (int | float | list[Node]): the seeding strategy to use for the initial infection (if `int`, choose fixed number
               of nodes at random, if `float` infect each node with this probability, if `[Node]`
               initially infect the specified nodes
        infection_prob (float): the probability for a contact between infected and susceptible nodes to lead
                        to a transmission
        initial_infection (int | str | datetime): the time of the initial infection
        recovery_rate (float | None): optional recovery rate (if None, simulates SEI dynamic where nodes never recover)
                       the actual recovery time is sampled from an exponential distribution with this rate
        incubation_rate ( float | None): optional incubation rate (if None, simulates SI or SIR dynamics where infected
                         nodes are infectious at the next time step)
                         the actual incubation time is sampled from an exponential distribution with
                         this rate
        rng_seed (int | None): optional seed for the random number generator

    Returns:
        AlgorithmResult: Returns an `Infected` object for each infected node with attributes

        `infected`: the time stamp of the infection event

        `active`: the time stamp at which the node actively starts spreading the infection (i.e., the end of the incubation period)

        `recovered`: the time stamp at which the node recovered (i.e., stopped spreading the infection)

    """

def temporal_bipartite_graph_projection(
    g: GraphView, delta: int, pivot_type
) -> GraphView:
    """
    Projects a temporal bipartite graph into an undirected temporal graph over the pivot node type. Let G be a bipartite graph with node types A and B. Given delta > 0, the projection graph G' pivoting over type B nodes,
    will make a connection between nodes n1 and n2 (of type A) at time (t1 + t2)/2 if they respectively have an edge at time t1, t2 with the same node of type B in G, and |t2-t1| < delta.

    Arguments:
        g (GraphView) : A directed raphtory graph
        delta (int): Time period
        pivot (str) : node type to pivot over. If a bipartite graph has types A and B, and B is the pivot type, the new graph will consist of type A nodes.

    Returns:
        GraphView: Projected (unipartite) temporal graph.
    """

def temporally_reachable_nodes(
    g: GraphView,
    max_hops: int,
    start_time: int,
    seed_nodes: list[InputNode],
    stop_nodes: Optional[list[InputNode]] = None,
):
    """
    Temporally reachable nodes -- the nodes that are reachable by a time respecting path followed out from a set of seed nodes at a starting time.

    This function starts at a set of seed nodes and follows all time respecting paths until either a) a maximum number of hops is reached, b) one of a set of
    stop nodes is reached, or c) no further time respecting edges exist. A time respecting path is a sequence of nodes v_1, v_2, ... , v_k such that there exists
    a sequence of edges (v_i, v_i+1, t_i) with t_i < t_i+1 for i = 1, ... , k - 1.

    Arguments:
        g (GraphView) : directed Raphtory graph
        max_hops (int) : maximum number of hops to propagate out
        start_time (int) : time at which to start the path (such that t_1 > start_time for any path starting from these seed nodes)
        seed_nodes (list[InputNode]) : list of node names or ids which should be the starting nodes
        stop_nodes (Optional[list[InputNode]]) : nodes at which a path shouldn't go any further

    Returns:
        AlgorithmResult : AlgorithmResult with string keys and float values mapping node names to their pagerank value.
    """

def triplet_count(g: GraphView):
    """
    Computes the number of connected triplets within a graph

    A connected triplet (also known as a wedge, 2-hop path) is a pair of edges with one node in common. For example, the triangle made up of edges
    A-B, B-C, C-A is formed of three connected triplets.

    Arguments:
        g (GraphView) : a Raphtory graph, treated as undirected

    Returns:
        int : the number of triplets in the graph
    """

def weakly_connected_components(g: GraphView, iter_count: int = 9223372036854775807):
    """
    Weakly connected components -- partitions the graph into node sets which are mutually reachable by an undirected path

    This function assigns a component id to each node such that nodes with the same component id are mutually reachable
    by an undirected path.

    Arguments:
        g (GraphView) : Raphtory graph
        iter_count (int) : Maximum number of iterations to run. Note that this will terminate early if the labels converge prior to the number of iterations being reached.

    Returns:
        AlgorithmResult : AlgorithmResult object mapping nodes to their component ids.
    """
