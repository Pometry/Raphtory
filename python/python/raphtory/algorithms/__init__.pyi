"""
Algorithmic functions that can be run on Raphtory graphs
"""
from __future__ import annotations

###############################################################################
#                                                                             #
#                      AUTOGENERATED TYPE STUB FILE                           #
#                                                                             #
#    This file was automatically generated. Do not modify it directly.        #
#    Any changes made here may be lost when the file is regenerated.          #
#                                                                             #
###############################################################################

from typing import *
from raphtory import *
import raphtory.filter as filter
from raphtory.vectors import *
from raphtory.node_state import *
from raphtory.graphql import *
from raphtory.typing import *
from datetime import datetime
from pandas import DataFrame
from os import PathLike
import networkx as nx  # type: ignore
import pyvis  # type: ignore

__all__ = ['dijkstra_single_source_shortest_paths', 'global_reciprocity', 'betweenness_centrality', 'all_local_reciprocity', 'triplet_count', 'local_triangle_count', 'average_degree', 'directed_graph_density', 'degree_centrality', 'max_degree', 'min_degree', 'max_out_degree', 'max_in_degree', 'min_out_degree', 'min_in_degree', 'pagerank', 'single_source_shortest_path', 'global_clustering_coefficient', 'temporally_reachable_nodes', 'temporal_bipartite_graph_projection', 'local_clustering_coefficient', 'local_clustering_coefficient_batch', 'weakly_connected_components', 'strongly_connected_components', 'in_components', 'in_component', 'out_components', 'out_component', 'fast_rp', 'global_temporal_three_node_motif', 'global_temporal_three_node_motif_multi', 'local_temporal_three_node_motifs', 'hits', 'balance', 'label_propagation', 'k_core', 'temporal_SEIR', 'louvain', 'fruchterman_reingold', 'cohesive_fruchterman_reingold', 'max_weight_matching', 'Matching', 'Infected']
def dijkstra_single_source_shortest_paths(graph: GraphView, source: NodeInput, targets: list[NodeInput], direction: Direction = "both", weight: str = 'weight') -> NodeStateWeightedSP:
    """
    Finds the shortest paths from a single source to multiple targets in a graph.

    Arguments:
        graph (GraphView): The graph to search in.
        source (NodeInput): The source node.
        targets (list[NodeInput]): A list of target nodes.
        direction (Direction): The direction of the edges to be considered for the shortest path. Defaults to "both".
        weight (str): The name of the weight property for the edges. Defaults to "weight".

    Returns:
        NodeStateWeightedSP: Mapping from nodes to a tuple containing the total cost and the nodes representing the shortest path.

    """

def global_reciprocity(graph: GraphView) -> float:
    """
    Reciprocity - measure of the symmetry of relationships in a graph, the global reciprocity of
    the entire graph.
    This calculates the number of reciprocal connections (edges that go in both directions) in a
    graph and normalizes it by the total number of directed edges.

    Arguments:
        graph (GraphView): a directed Raphtory graph

    Returns:
        float: reciprocity of the graph between 0 and 1.
    """

def betweenness_centrality(graph: GraphView, k: Optional[int] = None, normalized: bool = True) -> NodeStateF64:
    """
    Computes the betweenness centrality for nodes in a given graph.

    Arguments:
        graph (GraphView): A reference to the graph.
        k (int, optional): Specifies the number of nodes to consider for the centrality computation.
            All nodes are considered by default.
        normalized (bool): Indicates whether to normalize the centrality values. Defaults to True.

    Returns:
        NodeStateF64: Mapping from nodes to their betweenness centrality.
    """

def all_local_reciprocity(graph: GraphView) -> NodeStateF64:
    """
    Local reciprocity - measure of the symmetry of relationships associated with a node

    This measures the proportion of a node's outgoing edges which are reciprocated with an incoming edge.

    Arguments:
        graph (GraphView): a directed Raphtory graph

    Returns:
        NodeStateF64: Mapping of nodes to their reciprocity value.

    """

def triplet_count(graph: GraphView) -> int:
    """
    Computes the number of connected triplets within a graph

    A connected triplet (also known as a wedge, 2-hop path) is a pair of edges with one node in common. For example, the triangle made up of edges
    A-B, B-C, C-A is formed of three connected triplets.

    Arguments:
        graph (GraphView): a Raphtory graph, treated as undirected

    Returns:
        int: the number of triplets in the graph
    """

def local_triangle_count(graph: GraphView, v: NodeInput) -> int:
    """
    Implementations of various graph algorithms that can be run on a graph.

    To run an algorithm simply import the module and call the function with the graph as the argument

    Local triangle count - calculates the number of triangles (a cycle of length 3) a node participates in.

    This function returns the number of pairs of neighbours of a given node which are themselves connected.

    Arguments:
        graph (GraphView): Raphtory graph, this can be directed or undirected but will be treated as undirected
        v (NodeInput): node id or name

    Returns:
        int: number of triangles associated with node v

    """

def average_degree(graph: GraphView) -> float:
    """
    The average (undirected) degree of all nodes in the graph.

    Note that this treats the graph as simple and undirected and is equal to twice
    the number of undirected edges divided by the number of nodes.

    Arguments:
        graph (GraphView): a Raphtory graph

    Returns:
        float: the average degree of the nodes in the graph
    """

def directed_graph_density(graph: GraphView) -> float:
    """
    Graph density - measures how dense or sparse a graph is.

    The ratio of the number of directed edges in the graph to the total number of possible directed
    edges (given by N * (N-1) where N is the number of nodes).

    Arguments:
        graph (GraphView): a directed Raphtory graph

    Returns:
        float: Directed graph density of graph.
    """

def degree_centrality(graph: GraphView) -> NodeStateF64:
    """
    Computes the degree centrality of all nodes in the graph. The values are normalized
    by dividing each result with the maximum possible degree. Graphs with self-loops can have
    values of centrality greater than 1.

    Arguments:
        graph (GraphView): The graph view on which the operation is to be performed.

    Returns:
        NodeStateF64: Mapping of nodes to their associated degree centrality.
    """

def max_degree(graph: GraphView) -> int:
    """
    Returns the largest degree found in the graph

    Arguments:
        graph (GraphView): The graph view on which the operation is to be performed.

    Returns:
        int: The largest degree
    """

def min_degree(graph: GraphView) -> int:
    """
    Returns the smallest degree found in the graph

    Arguments:
        graph (GraphView): The graph view on which the operation is to be performed.

    Returns:
        int: The smallest degree found
    """

def max_out_degree(graph: GraphView) -> int:
    """
    The maximum out degree of any node in the graph.

    Arguments:
        graph (GraphView): a directed Raphtory graph

    Returns:
        int: value of the largest outdegree
    """

def max_in_degree(graph: GraphView) -> int:
    """
    The maximum in degree of any node in the graph.

    Arguments:
        graph (GraphView): a directed Raphtory graph

    Returns:
        int: value of the largest indegree
    """

def min_out_degree(graph: GraphView) -> int:
    """
    The minimum out degree of any node in the graph.

    Arguments:
        graph (GraphView): a directed Raphtory graph

    Returns:
        int: value of the smallest outdegree
    """

def min_in_degree(graph: GraphView) -> int:
    """
    The minimum in degree of any node in the graph.

    Arguments:
        graph (GraphView): a directed Raphtory graph

    Returns:
        int: value of the smallest indegree
    """

def pagerank(graph: GraphView, iter_count: int = 20, max_diff: Optional[float] = None, use_l2_norm: bool = True, damping_factor: float = 0.85) -> NodeStateF64:
    """
    Pagerank -- pagerank centrality value of the nodes in a graph

    This function calculates the Pagerank value of each node in a graph. See https://en.wikipedia.org/wiki/PageRank for more information on PageRank centrality.
    A default damping factor of 0.85 is used. This is an iterative algorithm which terminates if the sum of the absolute difference in pagerank values between iterations
    is less than the max diff value given.

    Arguments:
        graph (GraphView): Raphtory graph
        iter_count (int): Maximum number of iterations to run. Note that this will terminate early if convergence is reached. Defaults to 20.
        max_diff (Optional[float]): Optional parameter providing an alternative stopping condition.
            The algorithm will terminate if the sum of the absolute difference in pagerank values between iterations
            is less than the max diff value given.
        use_l2_norm (bool): Flag for choosing the norm to use for convergence checks, True for l2 norm, False for l1 norm. Defaults to True.
        damping_factor (float): The damping factor for the PageRank calculation. Defaults to 0.85.

    Returns:
        NodeStateF64: Mapping of nodes to their pagerank value.
    """

def single_source_shortest_path(graph: GraphView, source: NodeInput, cutoff: Optional[int] = None) -> NodeStateNodes:
    """
    Calculates the single source shortest paths from a given source node.

    Arguments:
        graph (GraphView): A reference to the graph. Must implement `GraphViewOps`.
        source (NodeInput): The source node.
        cutoff (int, optional): An optional cutoff level. The algorithm will stop if this level is reached.

    Returns:
        NodeStateNodes: Mapping from end node to shortest path from the source node.

    """

def global_clustering_coefficient(graph: GraphView) -> float:
    """
    Computes the global clustering coefficient of a graph. The global clustering coefficient is
    defined as the number of triangles in the graph divided by the number of triplets in the graph.

    Note that this is also known as transitivity and is different to the average clustering coefficient.

    Arguments:
        graph (GraphView): a Raphtory graph, treated as undirected

    Returns:
        float: the global clustering coefficient of the graph

    See also:
        [`Triplet Count`](triplet_count)
    """

def temporally_reachable_nodes(graph: GraphView, max_hops: int, start_time: int, seed_nodes: list[NodeInput], stop_nodes: Optional[list[NodeInput]] = None) -> NodeStateReachability:
    """
    Temporally reachable nodes -- the nodes that are reachable by a time respecting path followed out from a set of seed nodes at a starting time.

    This function starts at a set of seed nodes and follows all time respecting paths until either a) a maximum number of hops is reached, b) one of a set of
    stop nodes is reached, or c) no further time respecting edges exist. A time respecting path is a sequence of nodes v_1, v_2, ... , v_k such that there exists
    a sequence of edges (v_i, v_i+1, t_i) with t_i < t_i+1 for i = 1, ... , k - 1.

    Arguments:
        graph (GraphView): directed Raphtory graph
        max_hops (int): maximum number of hops to propagate out
        start_time (int): time at which to start the path (such that t_1 > start_time for any path starting from these seed nodes)
        seed_nodes (list[NodeInput]): list of node names or ids which should be the starting nodes
        stop_nodes (Optional[list[NodeInput]]): nodes at which a path shouldn't go any further

    Returns:
        NodeStateReachability: Mapping of nodes to their reachability history.
    """

def temporal_bipartite_graph_projection(graph: GraphView, delta: int, pivot_type: str) -> Graph:
    """
    Projects a temporal bipartite graph into an undirected temporal graph over the pivot node type. Let `G` be a bipartite graph with node types `A` and `B`. Given `delta > 0`, the projection graph `G'` pivoting over type `B` nodes,
    will make a connection between nodes `n1` and `n2` (of type `A`) at time `(t1 + t2)/2` if they respectively have an edge at time `t1`, `t2` with the same node of type `B` in `G`, and `|t2-t1| < delta`.

    Arguments:
        graph (GraphView): A directed raphtory graph
        delta (int): Time period
        pivot_type (str): node type to pivot over. If a bipartite graph has types `A` and `B`, and `B` is the pivot type, the new graph will consist of type `A` nodes.

    Returns:
        Graph: Projected (unipartite) temporal graph.
    """

def local_clustering_coefficient(graph: GraphView, v: NodeInput) -> float:
    """
    Local clustering coefficient - measures the degree to which nodes in a graph tend to cluster together.

    The proportion of pairs of neighbours of a node who are themselves connected.

    Arguments:
        graph (GraphView): Raphtory graph, can be directed or undirected but will be treated as undirected.
        v (NodeInput): node id or name

    Returns:
        float: the local clustering coefficient of node v in graph.
    """

def local_clustering_coefficient_batch(graph, v):
    ...

def weakly_connected_components(graph: GraphView) -> NodeStateUsize:
    """
    Weakly connected components -- partitions the graph into node sets which are mutually reachable by an undirected path

    This function assigns a component id to each node such that nodes with the same component id are mutually reachable
    by an undirected path.

    Arguments:
        graph (GraphView): Raphtory graph

    Returns:
        NodeStateUsize: Mapping of nodes to their component ids.
    """

def strongly_connected_components(graph: GraphView) -> NodeStateUsize:
    """
    Strongly connected components

    Partitions the graph into node sets which are mutually reachable by an directed path

    Arguments:
        graph (GraphView): Raphtory graph

    Returns:
        NodeStateUsize: Mapping of nodes to their component ids
    """

def in_components(graph: GraphView) -> NodeStateNodes:
    """
    In components -- Finding the "in-component" of a node in a directed graph involves identifying all nodes that can be reached following only incoming edges.

    Arguments:
        graph (GraphView): Raphtory graph

    Returns:
        NodeStateNodes: Mapping of nodes to the nodes in their 'in-component'
    """

def in_component(node: Node) -> NodeStateUsize:
    """
    In component -- Finding the "in-component" of a node in a directed graph involves identifying all nodes that can be reached following only incoming edges.

    Arguments:
        node (Node): The node whose in-component we wish to calculate

    Returns:
       NodeStateUsize: Mapping of nodes in the in-component to the distance from the starting node.
    """

def out_components(graph: GraphView) -> NodeStateNodes:
    """
    Out components -- Finding the "out-component" of a node in a directed graph involves identifying all nodes that can be reached following only outgoing edges.

    Arguments:
        graph (GraphView): Raphtory graph

    Returns:
        NodeStateNodes: Mapping of nodes to the nodes within their 'out-component'
    """

def out_component(node: Node) -> NodeStateUsize:
    """
    Out component -- Finding the "out-component" of a node in a directed graph involves identifying all nodes that can be reached following only outgoing edges.

    Arguments:
        node (Node): The node whose out-component we wish to calculate

    Returns:
       NodeStateUsize: A NodeState mapping the nodes in the out-component to their distance from the starting node.
    """

def fast_rp(graph: GraphView, embedding_dim: int, normalization_strength: float, iter_weights: list[float], seed: Optional[int] = None, threads: Optional[int] = None) -> NodeStateListF64:
    """
    Computes embedding vectors for each vertex of an undirected/bidirectional graph according to the Fast RP algorithm.
    Original Paper: https://doi.org/10.48550/arXiv.1908.11512
    Arguments:
        graph (GraphView): The graph view on which embeddings are generated.
        embedding_dim (int): The size (dimension) of the generated embeddings.
        normalization_strength (float): The extent to which high-degree vertices should be discounted (range: 1-0)
        iter_weights (list[float]): The scalar weights to apply to the results of each iteration
        seed (int, optional): The seed for initialisation of random vectors
        threads (int, optional): The number of threads to be used for parallel execution.

    Returns:
        NodeStateListF64: Mapping from nodes to embedding vectors.
    """

def global_temporal_three_node_motif(graph: GraphView, delta: int, threads: Optional[int] = None) -> list[int]:
    """
    Computes the number of three edge, up-to-three node delta-temporal motifs in the graph, using the algorithm of Paranjape et al, Motifs in Temporal Networks (2017).
    We point the reader to this reference for more information on the algorithm and background, but provide a short summary below.

     Motifs included:

     Stars

     There are three classes (in the order they are outputted) of star motif on three nodes based on the switching behaviour of the edges between the two leaf nodes.

      - PRE: Stars of the form i<->j, i<->j, i<->k (ie two interactions with leaf j followed by one with leaf k)
      - MID: Stars of the form i<->j, i<->k, i<->j (ie switching interactions from leaf j to leaf k, back to j again)
      - POST: Stars of the form i<->j, i<->k, i<->k (ie one interaction with leaf j followed by two with leaf k)

     Within each of these classes is 8 motifs depending on the direction of the first to the last edge -- incoming "I" or outgoing "O".
     These are enumerated in the order III, IIO, IOI, IOO, OII, OIO, OOI, OOO (like binary with "I"-0 and "O"-1).

     Two node motifs:

     Also included are two node motifs, of which there are 8 when counted from the perspective of each node. These are characterised by the direction of each edge, enumerated
     in the above order. Note that for the global graph counts, each motif is counted in both directions (a single III motif for one node is an OOO motif for the other node).

     Triangles:

     There are 8 triangle motifs:

      1. i --> j, k --> j, i --> k
      2. i --> j, k --> j, k --> i
      3. i --> j, j --> k, i --> k
      4. i --> j, j --> k, k --> i
      5. i --> j, k --> i, j --> k
      6. i --> j, k --> i, k --> j
      7. i --> j, i --> k, j --> k
      8. i --> j, i --> k, k --> j

    Arguments:
        graph (GraphView): A directed raphtory graph
        delta (int): Maximum time difference between the first and last edge of the motif. NB if time for edges was given as a UNIX epoch, this should be given in seconds, otherwise milliseconds should be used (if edge times were given as string)
        threads (int, optional): The number of threads to use when running the algorithm.

    Returns:
        list[int]: A 40 dimensional array with the counts of each motif, given in the same order as described above. Note that the two-node motif counts are symmetrical so it may be more useful just to consider the first four elements.

    Notes:
        This is achieved by calling the local motif counting algorithm, summing the resulting arrays and dealing with overcounted motifs: the triangles (by dividing each motif count by three) and two-node motifs (dividing by two).

    """

def global_temporal_three_node_motif_multi(graph: GraphView, deltas: list[int], threads: Optional[int] = None) -> list[list[int]]:
    """
    Computes the global counts of three-edge up-to-three node temporal motifs for a range of timescales. See `global_temporal_three_node_motif` for an interpretation of each row returned.

    Arguments:
        graph (GraphView): A directed raphtory graph
        deltas (list[int]): A list of delta values to use.
        threads (int, optional): The number of threads to use.

    Returns:
        list[list[int]]: A list of 40d arrays, each array is the motif count for a particular value of delta, returned in the order that the deltas were given as input.
    """

def local_temporal_three_node_motifs(graph: GraphView, delta: int, threads=None) -> NodeStateMotifs:
    """
    Computes the number of each type of motif that each node participates in. See global_temporal_three_node_motifs for a summary of the motifs involved.

    Arguments:
        graph (GraphView): A directed raphtory graph
        delta (int): Maximum time difference between the first and last edge of the motif. NB if time for edges was given as a UNIX epoch, this should be given in seconds, otherwise milliseconds should be used (if edge times were given as string)

    Returns:
        NodeStateMotifs: A mapping from nodes to lists of motif counts (40 counts in the same order as the global motif counts) with the number of each motif that node participates in.

    Notes:
        For this local count, a node is counted as participating in a motif in the following way. For star motifs, only the centre node counts
       the motif. For two node motifs, both constituent nodes count the motif. For triangles, all three constituent nodes count the motif.
    """

def hits(graph: GraphView, iter_count: int = 20, threads: Optional[int] = None) -> NodeStateHits:
    """
    HITS (Hubs and Authority) Algorithm:

    AuthScore of a node (A) = Sum of HubScore of all nodes pointing at node (A) from previous iteration /
    Sum of HubScore of all nodes in the current iteration

    HubScore of a node (A) = Sum of AuthScore of all nodes pointing away from node (A) from previous iteration /
    Sum of AuthScore of all nodes in the current iteration

    Arguments:
        graph (GraphView): Graph to run the algorithm on
        iter_count (int): How many iterations to run the algorithm. Defaults to 20.
        threads (int, optional): Number of threads to use

    Returns:
        NodeStateHits: A mapping from nodes their hub and authority scores
    """

def balance(graph: GraphView, name: str = "weight", direction: Direction = "both") -> NodeStateF64:
    """
    Sums the weights of edges in the graph based on the specified direction.

    This function computes the sum of edge weights based on the direction provided, and can be executed in parallel using a given number of threads.

    Arguments:
        graph (GraphView): The graph view on which the operation is to be performed.
        name (str): The name of the edge property used as the weight. Defaults to "weight".
        direction (Direction): Specifies the direction of the edges to be considered for summation. Defaults to "both".
                * "out": Only consider outgoing edges.
                * "in": Only consider incoming edges.
                * "both": Consider both outgoing and incoming edges. This is the default.

    Returns:
        NodeStateF64: Mapping of nodes to the computed sum of their associated edge weights.

    """

def label_propagation(graph: GraphView, seed: Optional[bytes] = None) -> list[set[Node]]:
    """
    Computes components using a label propagation algorithm

    Arguments:
        graph (GraphView): A reference to the graph
        seed (bytes, optional): Array of 32 bytes of u8 which is set as the rng seed

    Returns:
        list[set[Node]]: A list of sets each containing nodes that have been grouped

    """

def k_core(graph: GraphView, k: int, iter_count: int, threads: Optional[int] = None) -> list[Node]:
    """
    Determines which nodes are in the k-core for a given value of k

    Arguments:
        graph (GraphView): A reference to the graph
        k (int): Value of k such that the returned nodes have degree > k (recursively)
        iter_count (int): The number of iterations to run
        threads (int, optional): number of threads to run on

    Returns:
        list[Node]: A list of nodes in the k core

    """

def temporal_SEIR(graph: GraphView, seeds: int | float | list[NodeInput], infection_prob: float, initial_infection: int | str | datetime, recovery_rate: float | None = None, incubation_rate: float | None = None, rng_seed: int | None = None) -> NodeStateSEIR:
    """
    Simulate an SEIR dynamic on the network

    The algorithm uses the event-based sampling strategy from https://doi.org/10.1371/journal.pone.0246961

    Arguments:
        graph (GraphView): the graph view
        seeds (int | float | list[NodeInput]): the seeding strategy to use for the initial infection (if `int`, choose fixed number
               of nodes at random, if `float` infect each node with this probability, if `list`
               initially infect the specified nodes
        infection_prob (float): the probability for a contact between infected and susceptible nodes to lead
                        to a transmission
        initial_infection (int | str | datetime): the time of the initial infection
        recovery_rate (float | None): optional recovery rate (if None, simulates SEI dynamic where nodes never recover)
                       the actual recovery time is sampled from an exponential distribution with this rate
        incubation_rate ( float | None): optional incubation rate (if None, simulates SI or SIR dynamics where infected
                         nodes are infectious at the next time step)
                         the actual incubation time is sampled from an exponential distribution with
                         this rate
        rng_seed (int | None): optional seed for the random number generator

    Returns:
        NodeStateSEIR: Mapping from nodes to `Infected` objects for each infected node with attributes
            `infected`: the time stamp of the infection event
            `active`: the time stamp at which the node actively starts spreading the infection (i.e., the end of the incubation period)
            `recovered`: the time stamp at which the node recovered (i.e., stopped spreading the infection)

    """

def louvain(graph: GraphView, resolution: float = 1.0, weight_prop: str | None = None, tol: None | float = None) -> NodeStateUsize:
    """
    Louvain algorithm for community detection

    Arguments:
        graph (GraphView): the graph view
        resolution (float): the resolution parameter for modularity. Defaults to 1.0.
        weight_prop (str | None): the edge property to use for weights (has to be float)
        tol (None | float): the floating point tolerance for deciding if improvements are significant (default: 1e-8)

    Returns:
        NodeStateUsize: Mapping of nodes to their community assignment
    """

def fruchterman_reingold(graph: GraphView, iterations: int | None = 100, scale: float | None = 1.0, node_start_size: float | None = 1.0, cooloff_factor: float | None = 0.95, dt: float | None = 0.1) -> NodeLayout:
    """
    Fruchterman Reingold layout algorithm

    Arguments:
        graph (GraphView): the graph view
        iterations (int | None): the number of iterations to run. Defaults to 100.
        scale (float | None): the scale to apply. Defaults to 1.0.
        node_start_size (float | None): the start node size to assign random positions. Defaults to 1.0.
        cooloff_factor (float | None): the cool off factor for the algorithm. Defaults to 0.95.
        dt (float | None): the time increment between iterations. Defaults to 0.1.

    Returns:
        NodeLayout: A mapping from nodes to their [x, y] positions
    """

def cohesive_fruchterman_reingold(graph: GraphView, iter_count: int = 100, scale: float = 1.0, node_start_size: float = 1.0, cooloff_factor: float = 0.95, dt: float = 0.1) -> NodeLayout:
    """
    Cohesive version of `fruchterman_reingold` that adds virtual edges between isolated nodes
    Arguments:
        graph (GraphView): A reference to the graph
        iter_count (int): The number of iterations to run. Defaults to 100.
        scale (float): Global scaling factor to control the overall spread of the graph. Defaults to 1.0.
        node_start_size (float): Initial size or movement range for nodes. Defaults to 1.0.
        cooloff_factor (float): Factor to reduce node movement in later iterations, helping stabilize the layout. Defaults to 0.95.
        dt (float): Time step or movement factor in each iteration. Defaults to 0.1.

    Returns:
        NodeLayout: A mapping from nodes to their [x, y] positions

    """

def max_weight_matching(graph: GraphView, weight_prop: Optional[str] = None, max_cardinality: bool = True, verify_optimum_flag: bool = False) -> Matching:
    """
    Compute a maximum-weighted matching in the general undirected weighted
    graph given by "edges". If `max_cardinality` is true, only
    maximum-cardinality matchings are considered as solutions.

    The algorithm is based on "Efficient Algorithms for Finding Maximum
    Matching in Graphs" by Zvi Galil, ACM Computing Surveys, 1986.

    Based on networkx implementation
    <https://github.com/networkx/networkx/blob/3351206a3ce5b3a39bb2fc451e93ef545b96c95b/networkx/algorithms/matching.py>

    With reference to the standalone protoype implementation from:
    <http://jorisvr.nl/article/maximum-matching>

    <http://jorisvr.nl/files/graphmatching/20130407/mwmatching.py>

    The function takes time O(n**3)

    Arguments:
        graph (GraphView): The graph to compute the maximum weight matching for
        weight_prop (str, optional): The property on the edge to use for the weight. If not
            provided,
        max_cardinality (bool): If set to True, consider only maximum-cardinality matchings. Defaults to True.
            If True, finds the maximum-cardinality matching with maximum weight among all maximum-cardinality matchings,
            otherwise, finds the maximum weight matching irrespective of cardinality.
        verify_optimum_flag (bool): Whether the optimum should be verified. Defaults to False.
            If true prior to returning, an additional routine
            to verify the optimal solution was found will be run after computing
            the maximum weight matching. If it's true and the found matching is not
            an optimal solution this function will panic. This option should
            normally be only set true during testing.

    Returns:
        Matching: The matching
    """

class Matching(object): 
    """A Matching (i.e., a set of edges that do not share any nodes)"""

    def __bool__(self):
        """True if self else False"""

    def __contains__(self, key):
        """Return bool(key in self)."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __repr__(self):
        """Return repr(self)."""

    def dst(self, src: NodeInput) -> Optional[Node]:
        """
        Get the matched destination node for a source node

        Arguments:
            src (NodeInput): The source node

        Returns:
            Optional[Node]: The matched destination node if it exists

        """

    def edge_for_dst(self, dst: NodeInput) -> Optional[Edge]:
        """
        Get the matched edge for a destination node

        Arguments:
            dst (NodeInput): The source node

        Returns:
            Optional[Edge]: The matched edge if it exists
        """

    def edge_for_src(self, src: NodeInput) -> Optional[Edge]:
        """
        Get the matched edge for a source node

        Arguments:
            src (NodeInput): The source node

        Returns:
            Optional[Edge]: The matched edge if it exists
        """

    def edges(self) -> Edges:
        """
        Get a view of the matched edges

        Returns:
            Edges: The edges in the matching
        """

    def src(self, dst: NodeInput) -> Optional[Node]:
        """
        Get the matched source node for a destination node

        Arguments:
            dst (NodeInput): The destination node

        Returns:
            Optional[Node]: The matched source node if it exists

        """

class Infected(object): 

    def __repr__(self):
        """Return repr(self)."""

    @property
    def active(self) -> int:
        """
        The timestamp at which the infected node started spreading the infection

        Returns:
            int:
        """

    @property
    def infected(self) -> int:
        """
        The timestamp at which the node was infected

        Returns:
            int:
        """

    @property
    def recovered(self) -> int:
        """
        The timestamp at which the infected node stopped spreading the infection

        Returns:
            int:
        """
