###############################################################################
#                                                                             #
#                      AUTOGENERATED TYPE STUB FILE                           #
#                                                                             #
#    This file was automatically generated. Do not modify it directly.        #
#    Any changes made here may be lost when the file is regenerated.          #
#                                                                             #
###############################################################################

class Document():

    def content(self):
        ...

    def entity(self):
        ...

    def life(self):
        ...

class VectorisedGraph():

    def append(self, nodes, edges):
        'Add all the documents from `nodes` and `edges` to the current selection\n\nDocuments added by this call are assumed to have a score of 0.\n\nArgs:\n  nodes (list): a list of the node ids or nodes to add\n  edges (list):  a list of the edge ids or edges to add\n\nReturns:\n  A new vectorised graph containing the updated selection'
        ...

    def append_by_similarity(self, query, limit, window):
        'Add the top `limit` documents to the current selection using `query`\n\nArgs:\n  query (str or list): the text or the embedding to score against\n  limit (int): the maximum number of new documents to add\n  window ((int | str, int | str)): the window where documents need to belong to in order to be considered\n\nReturns:\n  A new vectorised graph containing the updated selection'
        ...

    def append_edges(self, edges):
        'Add all the documents from `edges` to the current selection\n\nDocuments added by this call are assumed to have a score of 0.\n\nArgs:\n  edges (list):  a list of the edge ids or edges to add\n\nReturns:\n  A new vectorised graph containing the updated selection'
        ...

    def append_edges_by_similarity(self, query, limit, window):
        'Add the top `limit` edge documents to the current selection using `query`\n\nArgs:\n  query (str or list): the text or the embedding to score against\n  limit (int): the maximum number of new documents to add\n  window ((int | str, int | str)): the window where documents need to belong to in order to be considered\n\nReturns:\n  A new vectorised graph containing the updated selection'
        ...

    def append_nodes(self, nodes):
        'Add all the documents from `nodes` to the current selection\n\nDocuments added by this call are assumed to have a score of 0.\n\nArgs:\n  nodes (list): a list of the node ids or nodes to add\n\nReturns:\n  A new vectorised graph containing the updated selection'
        ...

    def append_nodes_by_similarity(self, query, limit, window):
        'Add the top `limit` node documents to the current selection using `query`\n\nArgs:\n  query (str or list): the text or the embedding to score against\n  limit (int): the maximum number of new documents to add\n  window ((int | str, int | str)): the window where documents need to belong to in order to be considered\n\nReturns:\n  A new vectorised graph containing the updated selection'
        ...

    def edges(self):
        'Return the edges present in the current selection'
        ...

    def expand(self, hops, window):
        'Add all the documents `hops` hops away to the selection\n\nTwo documents A and B are considered to be 1 hop away of each other if they are on the same\nentity or if they are on the same node/edge pair. Provided that, two nodes A and C are n\nhops away of  each other if there is a document B such that A is n - 1 hops away of B and B\nis 1 hop away of C.\n\nArgs:\n  hops (int): the number of hops to carry out the expansion\n  window ((int | str, int | str)): the window where documents need to belong to in order to be considered\n\nReturns:\n  A new vectorised graph containing the updated selection'
        ...

    def expand_by_similarity(self, query, limit, window):
        'Add the top `limit` adjacent documents with higher score for `query` to the selection\n\nThe expansion algorithm is a loop with two steps on each iteration:\n  1. All the documents 1 hop away of some of the documents included on the selection (and\nnot already selected) are marked as candidates.\n 2. Those candidates are added to the selection in descending order according to the\nsimilarity score obtained against the `query`.\n\nThis loops goes on until the current selection reaches a total of `limit`  documents or\nuntil no more documents are available\n\nArgs:\n  query (str or list): the text or the embedding to score against\n  window ((int | str, int | str)): the window where documents need to belong to in order to be considered\n\nReturns:\n  A new vectorised graph containing the updated selection'
        ...

    def expand_edges_by_similarity(self, query, limit, window):
        'Add the top `limit` adjacent edge documents with higher score for `query` to the selection\n\nThis function has the same behavior as expand_by_similarity but it only considers edges.\n\nArgs:\n  query (str or list): the text or the embedding to score against\n  limit (int): the maximum number of new documents to add\n  window ((int | str, int | str)): the window where documents need to belong to in order to be considered\n\nReturns:\n  A new vectorised graph containing the updated selection'
        ...

    def expand_nodes_by_similarity(self, query, limit, window):
        'Add the top `limit` adjacent node documents with higher score for `query` to the selection\n\nThis function has the same behavior as expand_by_similarity but it only considers nodes.\n\nArgs:\n  query (str or list): the text or the embedding to score against\n  limit (int): the maximum number of new documents to add\n  window ((int | str, int | str)): the window where documents need to belong to in order to be considered\n\nReturns:\n  A new vectorised graph containing the updated selection'
        ...

    def get_documents(self):
        'Return the documents present in the current selection'
        ...

    def get_documents_with_scores(self):
        'Return the documents alongside their scores present in the current selection'
        ...

    def nodes(self):
        'Return the nodes present in the current selection'
        ...

    def save_embeddings(self, file):
        'Save the embeddings present in this graph to `file` so they can be further used in a call to `vectorise`'
        ...

def generate_property_list(entity, filter_out, force_static):
    ...
