###############################################################################
#                                                                             #
#                      AUTOGENERATED TYPE STUB FILE                           #
#                                                                             #
#    This file was automatically generated. Do not modify it directly.        #
#    Any changes made here may be lost when the file is regenerated.          #
#                                                                             #
###############################################################################

from typing import *
from raphtory import *
from raphtory.algorithms import *
from raphtory.vectors import *
from raphtory.node_state import *
from raphtory.typing import *
from datetime import datetime
from pandas import DataFrame
from os import PathLike
import networkx as nx  # type: ignore
import pyvis  # type: ignore

class GraphqlGraphs(object):
    """
    A class for accessing graphs hosted in a Raphtory GraphQL server and running global search for
    graph documents
    """

    def get(self, name: str) -> Optional[VectorisedGraph]:
        """
        Return the `VectorisedGraph` with name `name` or `None` if it doesn't exist

        Arguments:
            name (str): the name of the graph
        Returns:
            Optional[VectorisedGraph]: the graph if it exists
        """

    def search_graph_documents(
        self, query: str, limit: int, window: Optional[Tuple[TimeInput, TimeInput]]
    ) -> list[Document]:
        """
        Return the top documents with the smallest cosine distance to `query`

        Arguments:
          query (str): the text or the embedding to score against
          limit (int): the maximum number of documents to return
          window (Tuple[TimeInput, TimeInput], optional): the window where documents need to belong to in order to be considered

        Returns:
          list[Document]: A list of documents
        """

    def search_graph_documents_with_scores(
        self, query: str, limit: int, window: Optional[Tuple[TimeInput, TimeInput]]
    ) -> list[Tuple[Document, float]]:
        """
        Same as `search_graph_documents` but it also returns the scores alongside the documents

        Arguments:
          query (str): the text or the embedding to score against
          limit (int): the maximum number of documents to return
          window (Tuple[TimeInput, TimeInput], optional): the window where documents need to belong to in order to be considered

        Returns:
          list[Tuple[Document, float]]: A list of documents and their scores
        """

class GraphServer(object):
    """
    A class for defining and running a Raphtory GraphQL server

    Arguments:
        work_dir (str | PathLike): the working directory for the server
        cache_capacity (int, optional): the maximum number of graphs to keep in memory at once
        cache_tti_seconds (int, optional): the inactive time in seconds after which a graph is evicted from the cache
        log_level (str, optional): the log level for the server
        tracing (bool, optional): whether tracing should be enabled
        otlp_agent_host (str, optional): OTLP agent host for tracing
        otlp_agent_port(str, optional): OTLP agent port for tracing
        otlp_tracing_service_name (str, optional): The OTLP tracing service name
        config_path (str | PathLike, optional): Path to the config file
    """

    def __new__(
        cls,
        work_dir: str | PathLike,
        cache_capacity: Optional[int] = None,
        cache_tti_seconds: Optional[int] = None,
        log_level: Optional[str] = None,
        tracing: Optional[bool] = None,
        otlp_agent_host: Optional[str] = None,
        otlp_agent_port: Optional[str] = None,
        otlp_tracing_service_name: Optional[str] = None,
        config_path: Optional[str | PathLike] = None,
    ) -> GraphServer:
        """Create and return a new object.  See help(type) for accurate signature."""

    def run(self, port: int = 1736, timeout_ms: int = 180000) -> None:
        """
        Run the server until completion.

        Arguments:
          port (int): The port to use. Defaults to 1736.
          timeout_ms (int): Timeout for waiting for the server to start. Defaults to 180000.

        Returns:
            None:
        """

    def set_embeddings(
        self,
        cache: str,
        embedding: Optional[Callable] = None,
        graphs: bool | str = True,
        nodes: bool | str = True,
        edges: bool | str = True,
    ) -> GraphServer:
        """
        Setup the server to vectorise graphs with a default template.

        Arguments:
          cache (str):  the directory to use as cache for the embeddings.
          embedding (Callable, optional):  the embedding function to translate documents to embeddings.
          graphs (bool | str): if graphs have to be embedded or not or the custom template to use if a str is provided. Defaults to True.
          nodes (bool | str): if nodes have to be embedded or not or the custom template to use if a str is provided. Defaults to True.
          edges (bool | str): if edges have to be embedded or not or the custom template to use if a str is provided. Defaults to True.

        Returns:
           GraphServer: A new server object with embeddings setup.
        """

    def start(self, port: int = 1736, timeout_ms: int = 5000) -> RunningGraphServer:
        """
        Start the server and return a handle to it.

        Arguments:
          port (int):  the port to use. Defaults to 1736.
          timeout_ms (int): wait for server to be online. Defaults to 5000.
            The server is stopped if not online within timeout_ms but manages to come online as soon as timeout_ms finishes!

        Returns:
          RunningGraphServer: The running server
        """

    def turn_off_index(self) -> GraphServer:
        """
        Turn off index for all graphs

        Returns:
            GraphServer: The server with indexing disabled
        """

    def with_global_search_function(
        self, name: str, input: dict[str, str], function: Callable
    ) -> GraphServer:
        """
        Register a function in the GraphQL schema for document search among all the graphs.

        The function needs to take a `GraphqlGraphs` object as the first argument followed by a
        pre-defined set of keyword arguments. Supported types are `str`, `int`, and `float`.
        They have to be specified using the `input` parameter as a dict where the keys are the
        names of the parameters and the values are the types, expressed as strings.

        Arguments:
          name (str): the name of the function in the GraphQL schema.
          input (dict[str, str]):  the keyword arguments expected by the function.
          function (Callable): the function to run.

        Returns:
           GraphServer: A new server object with the function registered
        """

    def with_vectorised_graphs(
        self,
        graph_names: list[str],
        graphs: bool | str = True,
        nodes: bool | str = True,
        edges: bool | str = True,
    ) -> GraphServer:
        """
        Vectorise a subset of the graphs of the server.

        Arguments:
          graph_names (list[str]): the names of the graphs to vectorise. All by default.
          graphs (bool | str): if graphs have to be embedded or not or the custom template to use if a str is provided. Defaults to True.
          nodes (bool | str): if nodes have to be embedded or not or the custom template to use if a str is provided. Defaults to True.
          edges (bool | str): if edges have to be embedded or not or the custom template to use if a str is provided. Defaults to True.

        Returns:
           GraphServer: A new server object containing the vectorised graphs.
        """

class RunningGraphServer(object):
    """A Raphtory server handler that also enables querying the server"""

    def __enter__(self): ...
    def __exit__(self, _exc_type, _exc_val, _exc_tb): ...
    def get_client(self) -> RaphtoryClient:
        """
        Get the client for the server

        Returns:
            RaphtoryClient: the client
        """

    def stop(self) -> None:
        """
        Stop the server and wait for it to finish

        Returns:
            None:
        """

class RaphtoryClient(object):
    """
    A client for handling GraphQL operations in the context of Raphtory.

    Arguments:
        url (str): the URL of the Raphtory GraphQL server
    """

    def __new__(cls, url: str) -> RaphtoryClient:
        """Create and return a new object.  See help(type) for accurate signature."""

    def copy_graph(self, path: str, new_path: str) -> None:
        """
        Copy graph from a path `path` on the server to a `new_path` on the server

        Arguments:
          path (str): the path of the graph to be copied
          new_path (str): the new path of the copied graph

        Returns:
           None:
        """

    def delete_graph(self, path: str) -> None:
        """
        Delete graph from a path `path` on the server

        Arguments:
          path (str): the path of the graph to be deleted

        Returns:
            None:
        """

    def is_server_online(self) -> bool:
        """
        Check if the server is online.

        Returns:
           bool: Returns true if server is online otherwise false.
        """

    def move_graph(self, path: str, new_path: str) -> None:
        """
        Move graph from a path `path` on the server to a `new_path` on the server

        Arguments:
          path (str): the path of the graph to be moved
          new_path (str): the new path of the moved graph

        Returns:
           None:
        """

    def new_graph(self, path: str, graph_type: Literal["EVENT", "PERSISTENT"]) -> None:
        """
        Create a new empty Graph on the server at `path`

        Arguments:
          path (str): the path of the graph to be created
          graph_type (Literal["EVENT", "PERSISTENT"]): the type of graph that should be created - this can be EVENT or PERSISTENT

        Returns:
           None:

        """

    def query(
        self, query: str, variables: Optional[dict[str, Any]] = None
    ) -> dict[str, Any]:
        """
        Make a GraphQL query against the server.

        Arguments:
          query (str): the query to make.
          variables (dict[str, Any], optional): a dict of variables present on the query and their values.

        Returns:
           dict[str, Any]: The `data` field from the graphQL response.
        """

    def receive_graph(self, path: str) -> Union[Graph, PersistentGraph]:
        """
        Receive graph from a path `path` on the server

        Note:
            This downloads a copy of the graph. Modifications are not persistet to the server.

        Arguments:
          path (str): the path of the graph to be received

        Returns:
           Union[Graph, PersistentGraph]: A copy of the graph
        """

    def remote_graph(self, path: str) -> RemoteGraph:
        """
        Get a RemoteGraph reference to a graph on the server at `path`

        Arguments:
          path (str): the path of the graph to be created

        Returns:
           RemoteGraph: the remote graph reference

        """

    def send_graph(
        self, path: str, graph: Graph | PersistentGraph, overwrite: bool = False
    ) -> dict[str, Any]:
        """
        Send a graph to the server

        Arguments:
          path (str): the path of the graph
          graph (Graph | PersistentGraph): the graph to send
          overwrite (bool): overwrite existing graph. Defaults to False.

        Returns:
           dict[str, Any]: The `data` field from the graphQL response after executing the mutation.
        """

    def upload_graph(
        self, path: str, file_path: str, overwrite: bool = False
    ) -> dict[str, Any]:
        """
        Upload graph file from a path `file_path` on the client

        Arguments:
          path (str): the name of the graph
          file_path (str): the path of the graph on the client
          overwrite (bool): overwrite existing graph. Defaults to False.

        Returns:
           dict[str, Any]: The `data` field from the graphQL response after executing the mutation.
        """

class RemoteGraph(object):
    def add_constant_properties(self, properties: dict) -> None:
        """
        Adds constant properties to the remote graph.

        Arguments:
            properties (dict): The constant properties of the graph.

        Returns:
            None:
        """

    def add_edge(
        self,
        timestamp: int | str | datetime,
        src: str | int,
        dst: str | int,
        properties: Optional[dict] = None,
        layer: Optional[str] = None,
    ) -> RemoteEdge:
        """
        Adds a new edge with the given source and destination nodes and properties to the remote graph.

        Arguments:
           timestamp (int | str | datetime): The timestamp of the edge.
           src (str | int): The id of the source node.
           dst (str | int): The id of the destination node.
           properties (dict, optional): The properties of the edge, as a dict of string and properties.
           layer (str, optional): The layer of the edge.

        Returns:
          RemoteEdge: the remote edge
        """

    def add_edges(self, updates: List[RemoteEdgeAddition]) -> None:
        """
        Batch add edge updates to the remote graph

        Arguments:
          updates (List[RemoteEdgeAddition]): The list of updates you want to apply to the remote graph

        Returns:
            None:
        """

    def add_node(
        self,
        timestamp: int | str | datetime,
        id: str | int,
        properties: Optional[dict] = None,
        node_type: Optional[str] = None,
    ) -> RemoteNode:
        """
        Adds a new node with the given id and properties to the remote graph.

        Arguments:
           timestamp (int | str | datetime): The timestamp of the node.
           id (str | int): The id of the node.
           properties (dict, optional): The properties of the node.
           node_type (str, optional): The optional string which will be used as a node type
        Returns:
          RemoteNode: the new remote node
        """

    def add_nodes(self, updates: List[RemoteNodeAddition]) -> None:
        """
        Batch add node updates to the remote graph

        Arguments:
          updates (List[RemoteNodeAddition]): The list of updates you want to apply to the remote graph

        Returns:
            None:
        """

    def add_property(self, timestamp: int | str | datetime, properties: dict) -> None:
        """
        Adds properties to the remote graph.

        Arguments:
           timestamp (int | str | datetime): The timestamp of the temporal property.
           properties (dict): The temporal properties of the graph.

        Returns:
            None:
        """

    def create_node(
        self,
        timestamp: int | str | datetime,
        id: str | int,
        properties: Optional[dict] = None,
        node_type: Optional[str] = None,
    ) -> RemoteNode:
        """
        Create a new node with the given id and properties to the remote graph and fail if the node already exists.

        Arguments:
           timestamp (int | str | datetime): The timestamp of the node.
           id (str | int): The id of the node.
           properties (dict, optional): The properties of the node.
           node_type (str, optional): The optional string which will be used as a node type
        Returns:
          RemoteNode: the new remote node
        """

    def delete_edge(
        self,
        timestamp: int,
        src: str | int,
        dst: str | int,
        layer: Optional[str] = None,
    ) -> RemoteEdge:
        """
        Deletes an edge in the remote graph, given the timestamp, src and dst nodes and layer (optional)

        Arguments:
          timestamp (int): The timestamp of the edge.
          src (str | int): The id of the source node.
          dst (str | int): The id of the destination node.
          layer (str, optional): The layer of the edge.

        Returns:
          RemoteEdge: the remote edge
        """

    def edge(self, src: str | int, dst: str | int) -> RemoteEdge:
        """
        Gets a remote edge with the specified source and destination nodes

        Arguments:
            src (str | int): the source node id
            dst (str | int): the destination node id

        Returns:
            RemoteEdge: the remote edge reference
        """

    def node(self, id: str | int) -> RemoteNode:
        """
        Gets a remote node with the specified id

        Arguments:
          id (str | int): the node id

        Returns:
          RemoteNode: the remote node reference
        """

    def update_constant_properties(self, properties: dict) -> None:
        """
        Updates constant properties on the remote graph.

        Arguments:
            properties (dict): The constant properties of the graph.

        Returns:
            None:
        """

class RemoteEdge(object):
    """
    A remote edge reference

    Returned by :meth:`RemoteGraph.edge`, :meth:`RemoteGraph.add_edge`, and :meth:`RemoteGraph.delete_edge`.
    """

    def add_constant_properties(
        self, properties: Dict[str, Prop], layer: Optional[str] = None
    ) -> None:
        """
        Add constant properties to the edge within the remote graph.
        This function is used to add properties to an edge that remain constant and do not
        change over time. These properties are fundamental attributes of the edge.

        Parameters:
            properties (Dict[str, Prop]): A dictionary of properties to be added to the edge.
            layer (str, optional): The layer you want these properties to be added on to.

        Returns:
            None:
        """

    def add_updates(
        self,
        t: int | str | datetime,
        properties: Optional[Dict[str, Prop]] = None,
        layer: Optional[str] = None,
    ) -> None:
        """
        Add updates to an edge in the remote graph at a specified time.

        This function allows for the addition of property updates to an edge within the graph.
        The updates are time-stamped, meaning they are applied at the specified time.

        Parameters:
            t (int | str | datetime): The timestamp at which the updates should be applied.
            properties (Optional[Dict[str, Prop]]): A dictionary of properties to update.
            layer (str, optional): The layer you want the updates to be applied.

        Returns:
            None:
        """

    def delete(self, t: int | str | datetime, layer: Optional[str] = None) -> None:
        """
        Mark the edge as deleted at the specified time.

        Parameters:
            t (int | str | datetime): The timestamp at which the deletion should be applied.
            layer (str, optional): The layer you want the deletion applied to.

        Returns:
            None:
        """

    def update_constant_properties(
        self, properties: Dict[str, Prop], layer: Optional[str] = None
    ) -> None:
        """
        Update constant properties of an edge in the remote graph overwriting existing values.
        This function is used to add properties to an edge that remains constant and does not
        change over time. These properties are fundamental attributes of the edge.

        Parameters:
            properties (Dict[str, Prop]): A dictionary of properties to be added to the edge.
            layer (str, optional): The layer you want these properties to be added on to.

        Returns:
            None:
        """

class RemoteNode(object):
    def add_constant_properties(self, properties: Dict[str, Prop]) -> None:
        """
        Add constant properties to a node in the remote graph.
        This function is used to add properties to a node that remain constant and does not
        change over time. These properties are fundamental attributes of the node.

        Parameters:
            properties (Dict[str, Prop]): A dictionary of properties to be added to the node.

        Returns:
            None:
        """

    def add_updates(
        self, t: int | str | datetime, properties: Optional[Dict[str, Prop]] = None
    ) -> None:
        """
        Add updates to a node in the remote graph at a specified time.
        This function allows for the addition of property updates to a node within the graph. The updates are time-stamped, meaning they are applied at the specified time.

        Parameters:
            t (int | str | datetime): The timestamp at which the updates should be applied.
            properties (Dict[str, Prop], optional): A dictionary of properties to update.

        Returns:
            None:
        """

    def set_node_type(self, new_type: str) -> None:
        """
        Set the type on the node. This only works if the type has not been previously set, otherwise will
        throw an error

        Parameters:
            new_type (str): The new type to be set

        Returns:
            None:
        """

    def update_constant_properties(self, properties: Dict[str, Prop]) -> None:
        """
        Update constant properties of a node in the remote graph overwriting existing values.
        This function is used to add properties to a node that remain constant and do not
        change over time. These properties are fundamental attributes of the node.

        Parameters:
            properties (Dict[str, Prop]): A dictionary of properties to be added to the node.

        Returns:
            None:
        """

class RemoteNodeAddition(object):
    """
    Node addition update

    Arguments:
        name (GID): the id of the node
        node_type (str, optional): the node type
        constant_properties (PropInput, optional): the constant properties
        updates: (list[RemoteUpdate], optional): the temporal updates
    """

    def __new__(
        cls,
        name: GID,
        node_type: Optional[str] = None,
        constant_properties: Optional[PropInput] = None,
        updates: Any = None,
    ) -> RemoteNodeAddition:
        """Create and return a new object.  See help(type) for accurate signature."""

class RemoteUpdate(object):
    """
    A temporal update

    Arguments:
        time (TimeInput): the timestamp for the update
        properties (PropInput, optional): the properties for the update
    """

    def __new__(
        cls, time: TimeInput, properties: Optional[PropInput] = None
    ) -> RemoteUpdate:
        """Create and return a new object.  See help(type) for accurate signature."""

class RemoteEdgeAddition(object):
    """
    An edge update

    Arguments:
        src (GID): the id of the source node
        dst (GID): the id of the destination node
        layer (str, optional): the layer for the update
        constant_properties (PropInput, optional): the constant properties for the edge
        updates (list[RemoteUpdate], optional): the temporal updates for the edge
    """

    def __new__(
        cls,
        src: GID,
        dst: GID,
        layer: Optional[str] = None,
        constant_properties: Optional[PropInput] = None,
        updates: Optional[list[RemoteUpdate]] = None,
    ) -> RemoteEdgeAddition:
        """Create and return a new object.  See help(type) for accurate signature."""

def encode_graph(graph: Graph | PersistentGraph) -> str:
    """
    Encode a graph using Base64 encoding

    Arguments:
        graph (Graph | PersistentGraph): the graph

    Returns:
        str: the encoded graph
    """

def decode_graph(graph: str) -> Union[Graph, PersistentGraph]:
    """
    Decode a Base64-encoded graph

    Arguments:
        graph (str): the encoded graph

    Returns:
        Union[Graph, PersistentGraph]: the decoded graph
    """
