"""
Raphtory graph analytics library
"""

from __future__ import annotations

###############################################################################
#                                                                             #
#                      AUTOGENERATED TYPE STUB FILE                           #
#                                                                             #
#    This file was automatically generated. Do not modify it directly.        #
#    Any changes made here may be lost when the file is regenerated.          #
#                                                                             #
###############################################################################

from typing import *
import raphtory.filter as filter
from raphtory.algorithms import *
from raphtory.vectors import *
from raphtory.node_state import *
from raphtory.graphql import *
from raphtory.typing import *
import numpy as np
from numpy.typing import NDArray
from datetime import datetime
from pandas import DataFrame
from pyarrow import DataType  # type: ignore[import-untyped]
from os import PathLike
import networkx as nx  # type: ignore
import pyvis  # type: ignore
from raphtory.iterables import *

__all__ = [
    "GraphView",
    "Graph",
    "PersistentGraph",
    "Node",
    "Nodes",
    "PathFromNode",
    "PathFromGraph",
    "MutableNode",
    "Edge",
    "Edges",
    "NestedEdges",
    "MutableEdge",
    "Properties",
    "PyPropValueList",
    "PropType",
    "Metadata",
    "MetadataView",
    "TemporalProperties",
    "PropertiesView",
    "TemporalProperty",
    "EventTime",
    "OptionalEventTime",
    "History",
    "HistoryTimestamp",
    "HistoryDateTime",
    "HistoryEventId",
    "Intervals",
    "WindowSet",
    "IndexSpecBuilder",
    "IndexSpec",
    "Prop",
    "version",
    "graphql",
    "algorithms",
    "graph_loader",
    "graph_gen",
    "vectors",
    "node_state",
    "filter",
    "iterables",
    "nullmodels",
    "plottingutils",
]

class GraphView(object):
    """Graph view is a read-only version of a graph at a certain point in time."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __le__(self, value):
        """Return self<=value."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> GraphView:
        """
         Create a view of the GraphView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             GraphView:
        """

    def at(self, time: TimeInput) -> GraphView:
        """
         Create a view of the GraphView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             GraphView:
        """

    def before(self, end: TimeInput) -> GraphView:
        """
         Create a view of the GraphView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             GraphView:
        """

    def cache_view(self) -> GraphView:
        """
        Applies the filters to the graph and retains the node ids and the edge ids
        in the graph that satisfy the filters
        creates bitsets per layer for nodes and edges

        Returns:
          GraphView: Returns the masked graph
        """

    def count_edges(self) -> int:
        """
        Number of edges in the graph

        Returns:
           int: the number of edges in the graph
        """

    def count_nodes(self) -> int:
        """
        Number of nodes in the graph

        Returns:
          int: the number of nodes in the graph
        """

    def count_temporal_edges(self) -> int:
        """
        Number of edges in the graph

        Returns:
           int: the number of temporal edges in the graph
        """

    def default_layer(self) -> GraphView:
        """
         Return a view of GraphView containing only the default edge layer
        Returns:
             GraphView: The layered view
        """

    @property
    def earliest_time(self) -> OptionalEventTime:
        """
        Time entry of the earliest activity in the graph

        Returns:
            OptionalEventTime: the time entry of the earliest activity in the graph
        """

    def edge(self, src: NodeInput, dst: NodeInput) -> Optional[Edge]:
        """
        Gets the edge with the specified source and destination nodes

        Arguments:
            src (NodeInput): the source node id
            dst (NodeInput): the destination node id

        Returns:
            Optional[Edge]: the edge with the specified source and destination nodes, or None if the edge does not exist
        """

    @property
    def edges(self) -> Edges:
        """
        Gets all edges in the graph

        Returns:
          Edges: the edges in the graph
        """

    @property
    def end(self) -> OptionalEventTime:
        """
         Gets the latest time that this GraphView is valid.

        Returns:
           OptionalEventTime: The latest time that this GraphView is valid or None if the GraphView is valid for all times.
        """

    def exclude_layer(self, name: str) -> GraphView:
        """
         Return a view of GraphView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             GraphView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> GraphView:
        """
         Return a view of GraphView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             GraphView: The layered view
        """

    def exclude_nodes(self, nodes: list[NodeInput]) -> GraphView:
        """
        Returns a subgraph given a set of nodes that are excluded from the subgraph

        Arguments:
          nodes (list[NodeInput]): set of nodes

        Returns:
           GraphView: Returns the subgraph
        """

    def exclude_valid_layer(self, name: str) -> GraphView:
        """
         Return a view of GraphView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             GraphView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> GraphView:
        """
         Return a view of GraphView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             GraphView: The layered view
        """

    def expanding(
        self, step: int | str, alignment_unit: str | None = None
    ) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step. For example, if the step is "1 month and 1 day",
                the windows will be aligned on days (00:00:00 to 23:59:59).
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def filter(self, filter: filter.FilterExpr) -> GraphView:
        """
        Return a filtered view that only includes nodes and edges that satisfy the filter

        Arguments:
            filter (filter.FilterExpr): The filter to apply to the nodes and edges.

        Returns:
            GraphView: The filtered view
        """

    def find_edges(self, properties_dict: dict[str, PropValue]) -> list[Edge]:
        """
        Get the edges that match the properties name and value
        Arguments:
            properties_dict (dict[str, PropValue]): the properties name and value
        Returns:
           list[Edge]: the edges that match the properties name and value
        """

    def find_nodes(self, properties_dict: dict[str, PropValue]) -> list[Node]:
        """
        Get the nodes that match the properties name and value
        Arguments:
            properties_dict (dict[str, PropValue]): the properties name and value
        Returns:
           list[Node]: the nodes that match the properties name and value
        """

    def get_index_spec(self) -> IndexSpec:
        """
        Get index spec

        Returns:
            IndexSpec:
        """

    def has_edge(self, src: NodeInput, dst: NodeInput) -> bool:
        """
        Returns true if the graph contains the specified edge

        Arguments:
          src (NodeInput): the source node id
          dst (NodeInput): the destination node id

        Returns:
            bool: true if the graph contains the specified edge, false otherwise
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if GraphView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def has_node(self, id: NodeInput) -> bool:
        """
        Returns true if the graph contains the specified node

        Arguments:
           id (NodeInput): the node id

        Returns:
          bool: true if the graph contains the specified node, false otherwise
        """

    def latest(self) -> GraphView:
        """
         Create a view of the GraphView including all events at the latest time.

        Returns:
             GraphView:
        """

    @property
    def latest_time(self) -> OptionalEventTime:
        """
        Time entry of the latest activity in the graph

        Returns:
            OptionalEventTime: the time entry of the latest activity in the graph
        """

    def layer(self, name: str) -> GraphView:
        """
         Return a view of GraphView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             GraphView: The layered view
        """

    def layers(self, names: list[str]) -> GraphView:
        """
         Return a view of GraphView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             GraphView: The layered view
        """

    def materialize(self) -> GraphView:
        """
        Returns a 'materialized' clone of the graph view - i.e. a new graph with a copy of the data seen within the view instead of just a mask over the original graph

        Returns:
           GraphView: Returns a graph clone
        """

    @property
    def metadata(self) -> Metadata:
        """
        Get all graph metadata


        Returns:
            Metadata:
        """

    def node(self, id: NodeInput) -> Optional[Node]:
        """
        Gets the node with the specified id

        Arguments:
          id (NodeInput): the node id

        Returns:
            Optional[Node]: the node with the specified id, or None if the node does not exist
        """

    @property
    def nodes(self) -> Nodes:
        """
        Gets the nodes in the graph

        Returns:
          Nodes: the nodes in the graph
        """

    @property
    def properties(self) -> Properties:
        """
        Get all graph properties


        Returns:
            Properties: Properties paired with their names
        """

    def rolling(
        self,
        window: int | str,
        step: int | str | None = None,
        alignment_unit: str | None = None,
    ) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.
        If `alignment_unit` is not "unaligned" and a `step` larger than `window` is provided, some time entries
        may appear before the start of the first window and/or after the end of the last window (i.e. not included in any window).

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step (or window if no step is passed).
                For example, if the step is "1 month and 1 day",
                the first window will begin at the start of the day of the first time event.
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def search_edges(self, filter: Any, limit: int = 25, offset: int = 0) -> list[Edge]:
        """
        Searches for edges which match the given filter expression. This uses Tantivy's exact search.

        Arguments:
           filter: The filter expression to search for.
           limit(int): The maximum number of results to return. Defaults to 25.
           offset(int): The number of results to skip. This is useful for pagination. Defaults to 0.

        Returns:
           list[Edge]: A list of edges which match the filter expression. The list will be empty if no edges match the query.
        """

    def search_nodes(self, filter: Any, limit: int = 25, offset: int = 0) -> list[Node]:
        """
        Searches for nodes which match the given filter expression. This uses Tantivy's exact search.

        Arguments:
           filter: The filter expression to search for.
           limit(int): The maximum number of results to return. Defaults to 25.
           offset(int): The number of results to skip. This is useful for pagination. Defaults to 0.

        Returns:
           list[Node]: A list of nodes which match the filter expression. The list will be empty if no nodes match.
        """

    def shrink_end(self, end: TimeInput) -> GraphView:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             GraphView:
        """

    def shrink_start(self, start: TimeInput) -> GraphView:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             GraphView:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> GraphView:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             GraphView:
        """

    def snapshot_at(self, time: TimeInput) -> GraphView:
        """
         Create a view of the GraphView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             GraphView:
        """

    def snapshot_latest(self) -> GraphView:
        """
         Create a view of the GraphView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             GraphView:
        """

    @property
    def start(self) -> OptionalEventTime:
        """
         Gets the start time for rolling and expanding windows for this GraphView

        Returns:
            OptionalEventTime: The earliest time that this GraphView is valid or None if the GraphView is valid for all times.
        """

    def subgraph(self, nodes: list[NodeInput]) -> GraphView:
        """
        Returns a subgraph given a set of nodes

        Arguments:
          nodes (list[NodeInput]): set of nodes

        Returns:
           GraphView: Returns the subgraph
        """

    def subgraph_node_types(self, node_types: list[str]) -> GraphView:
        """
        Returns a subgraph filtered by node types given a set of node types

        Arguments:
          node_types (list[str]): set of node types

        Returns:
           GraphView: Returns the subgraph
        """

    def to_networkx(
        self,
        explode_edges: bool = False,
        include_node_properties: bool = True,
        include_edge_properties: bool = True,
        include_update_history: bool = True,
        include_property_history: bool = True,
    ) -> nx.MultiDiGraph:
        """
        Returns a graph with NetworkX.

            Network X is a required dependency.
            If you intend to use this function make sure that
            you install Network X with ``pip install networkx``

            Args:
                explode_edges (bool): A boolean that is set to True if you want to explode the edges in the graph. Defaults to False.
                include_node_properties (bool): A boolean that is set to True if you want to include the node properties in the graph. Defaults to True.
                include_edge_properties (bool): A boolean that is set to True if you want to include the edge properties in the graph. Defaults to True.
                include_update_history (bool): A boolean that is set to True if you want to include the update histories in the graph. Defaults to True.
                include_property_history (bool): A boolean that is set to True if you want to include the histories in the graph. Defaults to True.

            Returns:
                nx.MultiDiGraph: A Networkx MultiDiGraph.
        """

    def to_pyvis(
        self,
        explode_edges: bool = False,
        edge_color: str = "#000000",
        shape: str = "dot",
        node_image: Optional[str] = None,
        edge_weight: Optional[str] = None,
        edge_label: Optional[str] = None,
        colour_nodes_by_type: bool = False,
        directed: bool = True,
        notebook: bool = False,
        **kwargs: Any,
    ) -> pyvis.network.Network:
        """
        Draw a graph with PyVis.
        Pyvis is a required dependency. If you intend to use this function make sure that you install Pyvis
        with ``pip install pyvis``

        Args:
            explode_edges (bool): A boolean that is set to True if you want to explode the edges in the graph. Defaults to False.
            edge_color (str): A string defining the colour of the edges in the graph. Defaults to "#000000".
            shape (str): A string defining what the node looks like. Defaults to "dot".
                    There are two types of nodes. One type has the label inside of it and the other type has the label underneath it.
                    The types with the label inside of it are: ellipse, circle, database, box, text.
                    The ones with the label outside of it are: image, circularImage, diamond, dot, star, triangle, triangleDown, square and icon.
            node_image (str, optional): An optional node property used as the url of a custom node image. Use together with `shape="image"`.
            edge_weight (str, optional): An optional string defining the name of the property where edge weight is set on your Raphtory graph.
                If provided, the default weight for edges that are missing the property is 1.0.
            edge_label (str, optional): An optional string defining the name of the property where edge label is set on your Raphtory graph. By default, the edge layer is used as the label.
            colour_nodes_by_type (bool): If True, nodes with different types have different colours. Defaults to False.
            directed (bool): Visualise the graph as directed. Defaults to True.
            notebook (bool): A boolean that is set to True if using jupyter notebook. Defaults to False.
            kwargs: Additional keyword arguments that are passed to the pyvis Network class.

        Returns:
            pyvis.network.Network: A pyvis network
        """

    @property
    def unique_layers(self) -> list[str]:
        """
        Return all the layer ids in the graph

        Returns:
            list[str]: the names of all layers in the graph
        """

    def valid(self) -> GraphView:
        """
        Return a view of the graph that only includes valid edges

        Note:

            The semantics for `valid` depend on the time semantics of the underlying graph.
            In the case of a persistent graph, an edge is valid if its last update is an addition.
            In the case of an event graph, an edge is valid if it has at least one addition event.

        Returns:
            GraphView: The filtered graph
        """

    def valid_layers(self, names: list[str]) -> GraphView:
        """
         Return a view of GraphView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             GraphView: The layered view
        """

    def vectorise(
        self,
        embedding: Callable[[list], list],
        nodes: bool | str = True,
        edges: bool | str = True,
        cache: Optional[str] = None,
        verbose: bool = False,
    ) -> VectorisedGraph:
        """
        Create a VectorisedGraph from the current graph.

        Args:
          embedding (Callable[[list], list]): Specify the embedding function used to vectorise documents into embeddings.
          nodes (bool | str): Enable for nodes to be embedded, disable for nodes to not be embedded or specify a custom document property to use if a string is provided. Defaults to True.
          edges (bool | str): Enable for edges to be embedded, disable for edges to not be embedded or specify a custom document property to use if a string is provided. Defaults to True.
          cache (str, optional): Path used to store the cache of embeddings.
          verbose (bool): Enable to print logs reporting progress. Defaults to False.

        Returns:
          VectorisedGraph: A VectorisedGraph with all the documents and their embeddings, with an initial empty selection.
        """

    def window(self, start: TimeInput, end: TimeInput) -> GraphView:
        """
         Create a view of the GraphView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput): The start time of the window.
            end (TimeInput): The end time of the window.

        Returns:
            GraphView:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this GraphView.

        Returns:
            Optional[int]:
        """

class Graph(GraphView):
    """
    A temporal graph with event semantics.

    Arguments:
        num_shards (int, optional): The number of locks to use in the storage to allow for multithreaded updates.
    """

    def __new__(cls, num_shards: Optional[int] = None) -> Graph:
        """Create and return a new object.  See help(type) for accurate signature."""

    def __reduce__(self): ...
    def add_edge(
        self,
        timestamp: TimeInput,
        src: str | int,
        dst: str | int,
        properties: Optional[PropInput] = None,
        layer: Optional[str] = None,
        event_id: Optional[int] = None,
    ) -> MutableEdge:
        """
        Adds a new edge with the given source and destination nodes and properties to the graph.

        Arguments:
           timestamp (TimeInput): The timestamp of the edge.
           src (str|int): The id of the source node.
           dst (str|int): The id of the destination node.
           properties (PropInput, optional): The properties of the edge, as a dict of string and properties.
           layer (str, optional): The layer of the edge.
           event_id (int, optional): The optional integer which will be used as an event id.

        Returns:
            MutableEdge: The added edge.

        Raises:
            GraphError: If the operation fails.
        """

    def add_metadata(self, metadata: PropInput) -> None:
        """
        Adds static properties to the graph.

        Arguments:
            metadata (PropInput): The static properties of the graph.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def add_node(
        self,
        timestamp: TimeInput,
        id: str | int,
        properties: Optional[PropInput] = None,
        node_type: Optional[str] = None,
        event_id: Optional[int] = None,
    ) -> MutableNode:
        """
        Adds a new node with the given id and properties to the graph.

        Arguments:
           timestamp (TimeInput): The timestamp of the node.
           id (str|int): The id of the node.
           properties (PropInput, optional): The properties of the node.
           node_type (str, optional): The optional string which will be used as a node type.
           event_id (int, optional): The optional integer which will be used as an event id.

        Returns:
            MutableNode: The added node.

        Raises:
            GraphError: If the operation fails.
        """

    def add_properties(
        self,
        timestamp: TimeInput,
        properties: PropInput,
        event_id: Optional[int] = None,
    ) -> None:
        """
        Adds properties to the graph.

        Arguments:
           timestamp (TimeInput): The timestamp of the temporal property.
           properties (PropInput): The temporal properties of the graph.
           event_id (int, optional): The optional integer which will be used as an event id.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def cache(self, path: str) -> None:
        """
         Write Graph to cache file and initialise the cache.

        Future updates are tracked. Use `write_updates` to persist them to the
        cache file. If the file already exists its contents are overwritten.

        Arguments:
            path (str): The path to the cache file

        Returns:
            None:
        """

    def create_index(self) -> None:
        """
        Create graph index

        Returns:
            None:
        """

    def create_index_in_ram(self) -> None:
        """
        Creates a graph index in memory (RAM).

        This is primarily intended for use in tests and should not be used in production environments,
        as the index will not be persisted to disk.

        Returns:
            None:
        """

    def create_index_in_ram_with_spec(self, py_spec: IndexSpec) -> None:
        """
        Creates a graph index in memory (RAM) with the provided index spec.

        This is primarily intended for use in tests and should not be used in production environments,
        as the index will not be persisted to disk.

        Arguments:
            py_spec: The specification for the in-memory index to be created.

        Arguments:
            py_spec (IndexSpec): - The specification for the in-memory index to be created.

        Returns:
            None:
        """

    def create_index_with_spec(self, py_spec: Any) -> None:
        """
        Create graph index with the provided index spec.

        Arguments:
            py_spec: - The specification for the in-memory index to be created.

        Returns:
            None:
        """

    def create_node(
        self,
        timestamp: TimeInput,
        id: str | int,
        properties: Optional[PropInput] = None,
        node_type: Optional[str] = None,
        event_id: Optional[int] = None,
    ) -> MutableNode:
        """
        Creates a new node with the given id and properties to the graph. It fails if the node already exists.

        Arguments:
           timestamp (TimeInput): The timestamp of the node.
           id (str|int): The id of the node.
           properties (PropInput, optional): The properties of the node.
           node_type (str, optional): The optional string which will be used as a node type.
           event_id (int, optional): The optional integer which will be used as an event id.

        Returns:
            MutableNode: The created node.

        Raises:
            GraphError: If the operation fails.
        """

    def delete_edge(
        self,
        timestamp: int,
        src: str | int,
        dst: str | int,
        layer: Optional[str],
        event_id: Optional[int],
    ) -> MutableEdge:
        """
        Deletes an edge given the timestamp, src and dst nodes and layer (optional).

        Arguments:
          timestamp (int): The timestamp of the edge.
          src (str | int): The id of the source node.
          dst (str | int): The id of the destination node.
          layer (str, optional): The layer of the edge.
          event_id (int, optional): The optional integer which will be used as an event id.

        Returns:
          MutableEdge: The deleted edge

        Raises:
            GraphError: If the operation fails.
        """

    @staticmethod
    def deserialise(bytes: bytes) -> Graph:
        """
         Load Graph from serialised bytes.

        Arguments:
            bytes (bytes): The serialised bytes to decode

        Returns:
           Graph:
        """

    def edge(self, src: str | int, dst: str | int) -> MutableEdge:
        """
        Gets the edge with the specified source and destination nodes

        Arguments:
            src (str|int): the source node id
            dst (str|int): the destination node id

        Returns:
            MutableEdge: the edge with the specified source and destination nodes, or None if the edge does not exist
        """

    def event_graph(self) -> Graph:
        """
        View graph with event semantics

        Returns:
            Graph: the graph with event semantics applied
        """

    @staticmethod
    def from_parquet(graph_dir: str | PathLike) -> Graph:
        """
        Read graph from parquet files

        Arguments:
           graph_dir (str | PathLike): the folder where the graph is stored as parquet

        Returns:
          Graph: a view of the graph

        """

    def get_all_node_types(self) -> List[str]:
        """
        Returns all the node types in the graph.

        Returns:
            List[str]: the node types
        """

    def import_edge(self, edge: Edge, merge: bool = False) -> MutableEdge:
        """
        Import a single edge into the graph.

        Arguments:
            edge (Edge): A Edge object representing the edge to be imported.
            merge (bool): An optional boolean flag. Defaults to False.
                          If merge is False, the function will return an error if the imported edge already exists in the graph.
                          If merge is True, the function merges the histories of the imported edge and the existing edge (in the graph).

        Returns:
            MutableEdge: An Edge object if the edge was successfully imported.

        Raises:
            GraphError: If the operation fails.
        """

    def import_edge_as(self, edge: Edge, new_id: tuple, merge: bool = False) -> Edge:
        """
        Import a single edge into the graph with new id.

        Arguments:
            edge (Edge): A Edge object representing the edge to be imported.
            new_id (tuple) : The ID of the new edge. It's a tuple of the source and destination node ids.
            merge (bool): An optional boolean flag. Defaults to False.
                          If merge is False, the function will return an error if the imported edge already exists in the graph.
                          If merge is True, the function merges the histories of the imported edge and the existing edge (in the graph).

        Returns:
            Edge: An Edge object if the edge was successfully imported.

        Raises:
            GraphError: If the operation fails.
        """

    def import_edges(self, edges: List[Edge], merge: bool = False) -> None:
        """
        Import multiple edges into the graph.

        Arguments:
            edges (List[Edge]): A list of Edge objects representing the edges to be imported.
            merge (bool): An optional boolean flag. Defaults to False.
                          If merge is False, the function will return an error if any of the imported edges already exists in the graph.
                          If merge is True, the function merges the histories of the imported edges and the existing edges (in the graph).

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def import_edges_as(
        self, edges: List[Edge], new_ids: List[Tuple[int, int]], merge: bool = False
    ) -> None:
        """
        Import multiple edges into the graph with new ids.

        Arguments:
            edges (List[Edge]): A list of Edge objects representing the edges to be imported.
            new_ids (List[Tuple[int, int]]): The IDs of the new edges. It's a vector of tuples of the source and destination node ids.
            merge (bool): An optional boolean flag. Defaults to False.
                          If merge is False, the function will return an error if any of the imported edges already exists in the graph.
                          If merge is True, the function merges the histories of the imported edges and the existing edges (in the graph).

        Returns:
            None: This function does not return a value if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def import_node(self, node: Node, merge: bool = False) -> Node:
        """
        Import a single node into the graph.

        Arguments:
            node (Node): A Node object representing the node to be imported.
            merge (bool): An optional boolean flag. Defaults to False.
                          If merge is False, the function will return an error if the imported node already exists in the graph.
                          If merge is True, the function merges the histories of the imported node and the existing node (in the graph).

        Returns:
            Node: A node object if the node was successfully imported.

        Raises:
            GraphError: If the operation fails.
        """

    def import_node_as(
        self, node: Node, new_id: str | int, merge: bool = False
    ) -> MutableNode:
        """
        Import a single node into the graph with new id.

        Arguments:
            node (Node): A Node object representing the node to be imported.
            new_id (str|int): The new node id.
            merge (bool): An optional boolean flag. Defaults to False.
                          If merge is False, the function will return an error if the imported node already exists in the graph.
                          If merge is True, the function merges the histories of the imported node and the existing node (in the graph).

        Returns:
            MutableNode: A node object if the node was successfully imported.

        Raises:
            GraphError: If the operation fails.
        """

    def import_nodes(self, nodes: List[Node], merge: bool = False) -> None:
        """
        Import multiple nodes into the graph.

        Arguments:
            nodes (List[Node]): A vector of Node objects representing the nodes to be imported.
            merge (bool): An optional boolean flag. Defaults to False.
                          If merge is False, the function will return an error if any of the imported nodes already exists in the graph.
                          If merge is True, the function merges the histories of the imported nodes and the existing nodes (in the graph).

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def import_nodes_as(
        self, nodes: List[Node], new_ids: List[str | int], merge: bool = False
    ) -> None:
        """
        Import multiple nodes into the graph with new ids.

        Arguments:
            nodes (List[Node]): A vector of Node objects representing the nodes to be imported.
            new_ids (List[str|int]): A list of node IDs to use for the imported nodes.
            merge (bool): An optional boolean flag. Defaults to False.
                          If merge is True, the function will return an error if any of the imported nodes already exists in the graph.
                          If merge is False, the function merges the histories of the imported nodes and the existing nodes (in the graph).

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def largest_connected_component(self) -> GraphView:
        """
        Gives the large connected component of a graph.

        # Example Usage:
        g.largest_connected_component()

        Returns:
            GraphView: sub-graph of the graph `g` containing the largest connected component

        """

    @staticmethod
    def load_cached(path: str) -> Graph:
        """
         Load Graph from a file and initialise it as a cache file.

        Future updates are tracked. Use `write_updates` to persist them to the
        cache file.

        Arguments:
          path (str): The path to the cache file

        Returns:
           Graph: the loaded graph with initialised cache
        """

    def load_edge_metadata(
        self,
        data: Any,
        src: str,
        dst: str,
        metadata: Optional[List[str]] = None,
        shared_metadata: Optional[PropInput] = None,
        layer: Optional[str] = None,
        layer_col: Optional[str] = None,
        schema: Optional[
            list[tuple[str, DataType | PropType | str]]
            | dict[str, DataType | PropType | str]
        ] = None,
        csv_options: Optional[dict[str, str | bool]] = None,
    ) -> None:
        """
        Load edge metadata into the graph from any data source that supports the ArrowStreamExportable protocol (by providing an __arrow_c_stream__() method),
        a path to a CSV or Parquet file, or a directory containing multiple CSV or Parquet files.
        The following are known to support the ArrowStreamExportable protocol: Pandas dataframes, FireDucks(.pandas) dataframes,
        Polars dataframes, Arrow tables, DuckDB (e.g. DuckDBPyRelation obtained from running an SQL query).

        Arguments:
            data (Any): The data source containing edge information.
            src (str): The column name for the source node.
            dst (str): The column name for the destination node.
            metadata (List[str], optional): List of edge metadata column names. Defaults to None.
            shared_metadata (PropInput, optional): A dictionary of metadata properties that will be added to every edge. Defaults to None.
            layer (str, optional): The edge layer name. Defaults to None.
            layer_col (str, optional): The edge layer column name in a dataframe. Defaults to None.
            schema (list[tuple[str, DataType | PropType | str]] | dict[str, DataType | PropType | str], optional): A list of (column_name, column_type) tuples or dict of {"column_name": column_type} to cast columns to. Defaults to None.
            csv_options (dict[str, str | bool], optional): A dictionary of CSV reading options such as delimiter, comment, escape, quote, and terminator characters, as well as allow_truncated_rows and has_header flags. Defaults to None.

        Returns:
            None: This function does not return a value if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_edges(
        self,
        data: Any,
        time: str,
        src: str,
        dst: str,
        properties: Optional[List[str]] = None,
        metadata: Optional[List[str]] = None,
        shared_metadata: Optional[PropInput] = None,
        layer: Optional[str] = None,
        layer_col: Optional[str] = None,
        schema: Optional[
            list[tuple[str, DataType | PropType | str]]
            | dict[str, DataType | PropType | str]
        ] = None,
        csv_options: Optional[dict[str, str | bool]] = None,
    ) -> None:
        """
        Load edges into the graph from any data source that supports the ArrowStreamExportable protocol (by providing an __arrow_c_stream__() method),
        a path to a CSV or Parquet file, or a directory containing multiple CSV or Parquet files.
        The following are known to support the ArrowStreamExportable protocol: Pandas dataframes, FireDucks(.pandas) dataframes,
        Polars dataframes, Arrow tables, DuckDB (e.g. DuckDBPyRelation obtained from running an SQL query).

        Arguments:
            data (Any): The data source containing the edges.
            time (str): The column name for the update timestamps.
            src (str): The column name for the source node IDs.
            dst (str): The column name for the destination node IDs.
            properties (List[str], optional): List of edge property column names. Defaults to None.
            metadata (List[str], optional): List of edge metadata column names. Defaults to None.
            shared_metadata (PropInput, optional): A dictionary of metadata properties that will be added to every edge. Defaults to None.
            layer (str, optional): A value to use as the layer for all edges. Cannot be used in combination with layer_col. Defaults to None.
            layer_col (str, optional): The edge layer column name in a dataframe. Cannot be used in combination with layer. Defaults to None.
            schema (list[tuple[str, DataType | PropType | str]] | dict[str, DataType | PropType | str], optional): A list of (column_name, column_type) tuples or dict of {"column_name": column_type} to cast columns to. Defaults to None.
            csv_options (dict[str, str | bool], optional): A dictionary of CSV reading options such as delimiter, comment, escape, quote, and terminator characters, as well as allow_truncated_rows and has_header flags. Defaults to None.

        Returns:
            None: This function does not return a value if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    @staticmethod
    def load_from_file(path: str) -> Graph:
        """
         Load Graph from a file.

        Arguments:
          path (str): The path to the file.

        Returns:
           Graph:
        """

    def load_node_metadata(
        self,
        data: Any,
        id: str,
        node_type: Optional[str] = None,
        node_type_col: Optional[str] = None,
        metadata: Optional[List[str]] = None,
        shared_metadata: Optional[PropInput] = None,
        schema: Optional[
            list[tuple[str, DataType | PropType | str]]
            | dict[str, DataType | PropType | str]
        ] = None,
        csv_options: Optional[dict[str, str | bool]] = None,
    ) -> None:
        """
        Load node metadata into the graph from any data source that supports the ArrowStreamExportable protocol (by providing an __arrow_c_stream__() method),
        a path to a CSV or Parquet file, or a directory containing multiple CSV or Parquet files.
        The following are known to support the ArrowStreamExportable protocol: Pandas dataframes, FireDucks(.pandas) dataframes,
        Polars dataframes, Arrow tables, DuckDB (e.g. DuckDBPyRelation obtained from running an SQL query).

        Arguments:
            data (Any): The data source containing node information.
            id(str): The column name for the node IDs.
            node_type (str, optional): A value to use as the node type for all nodes. Cannot be used in combination with node_type_col. Defaults to None.
            node_type_col (str, optional): The node type column name in a dataframe. Cannot be used in combination with node_type. Defaults to None.
            metadata (List[str], optional): List of node metadata column names. Defaults to None.
            shared_metadata (PropInput, optional): A dictionary of metadata properties that will be added to every node. Defaults to None.
            schema (list[tuple[str, DataType | PropType | str]] | dict[str, DataType | PropType | str], optional): A list of (column_name, column_type) tuples or dict of {"column_name": column_type} to cast columns to. Defaults to None.
            csv_options (dict[str, str | bool], optional): A dictionary of CSV reading options such as delimiter, comment, escape, quote, and terminator characters, as well as allow_truncated_rows and has_header flags. Defaults to None.

        Returns:
            None: This function does not return a value if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_nodes(
        self,
        data: Any,
        time: str,
        id: str,
        node_type: Optional[str] = None,
        node_type_col: Optional[str] = None,
        properties: Optional[List[str]] = None,
        metadata: Optional[List[str]] = None,
        shared_metadata: Optional[PropInput] = None,
        schema: Optional[
            list[tuple[str, DataType | PropType | str]]
            | dict[str, DataType | PropType | str]
        ] = None,
        csv_options: Optional[dict[str, str | bool]] = None,
    ) -> None:
        """
        Load nodes into the graph from any data source that supports the ArrowStreamExportable protocol (by providing an __arrow_c_stream__() method),
        a path to a CSV or Parquet file, or a directory containing multiple CSV or Parquet files.
        The following are known to support the ArrowStreamExportable protocol: Pandas dataframes, FireDucks(.pandas) dataframes,
        Polars dataframes, Arrow tables, DuckDB (e.g. DuckDBPyRelation obtained from running an SQL query).

        Arguments:
            data (Any): The data source containing the nodes.
            time (str): The column name for the timestamps.
            id (str): The column name for the node IDs.
            node_type (str, optional): A value to use as the node type for all nodes. Cannot be used in combination with node_type_col. Defaults to None.
            node_type_col (str, optional): The node type column name in a dataframe. Cannot be used in combination with node_type. Defaults to None.
            properties (List[str], optional): List of node property column names. Defaults to None.
            metadata (List[str], optional): List of node metadata column names. Defaults to None.
            shared_metadata (PropInput, optional): A dictionary of metadata properties that will be added to every node. Defaults to None.
            schema (list[tuple[str, DataType | PropType | str]] | dict[str, DataType | PropType | str], optional): A list of (column_name, column_type) tuples or dict of {"column_name": column_type} to cast columns to. Defaults to None.
            csv_options (dict[str, str | bool], optional): A dictionary of CSV reading options such as delimiter, comment, escape, quote, and terminator characters, as well as allow_truncated_rows and has_header flags. Defaults to None.

        Returns:
            None: This function does not return a value if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def node(self, id: str | int) -> MutableNode:
        """
        Gets the node with the specified id

        Arguments:
          id (str|int): the node id

        Returns:
          MutableNode: The node object with the specified id, or None if the node does not exist
        """

    def persistent_graph(self) -> PersistentGraph:
        """
        View graph with persistent semantics

        Returns:
            PersistentGraph: the graph with persistent semantics applied
        """

    def save_to_file(self, path: str) -> None:
        """
         Saves the Graph to the given path.

        Arguments:
            path (str): The path to the file.

        Returns:
            None:
        """

    def save_to_zip(self, path: str) -> None:
        """
         Saves the Graph to the given path.

        Arguments:
            path (str): The path to the file.
        Returns:
            None:
        """

    def serialise(self) -> bytes:
        """
         Serialise Graph to bytes.

        Returns:
          bytes:
        """

    def to_parquet(self, graph_dir: str | PathLike) -> None:
        """
        Persist graph to parquet files.

        Arguments:
            graph_dir (str | PathLike): the folder where the graph will be persisted as parquet

        Returns:
            None:
        """

    def update_metadata(self, metadata: PropInput) -> None:
        """
        Updates static properties to the graph.

        Arguments:
            metadata (PropInput): The static properties of the graph.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def write_updates(self) -> None:
        """
        Persist the new updates by appending them to the cache file.

        Returns:
            None:
        """

class PersistentGraph(GraphView):
    """A temporal graph that allows edges and nodes to be deleted."""

    def __new__(cls) -> PersistentGraph:
        """Create and return a new object.  See help(type) for accurate signature."""

    def __reduce__(self): ...
    def add_edge(
        self,
        timestamp: int,
        src: str | int,
        dst: str | int,
        properties: Optional[PropInput] = None,
        layer: Optional[str] = None,
        event_id: Optional[int] = None,
    ) -> None:
        """
        Adds a new edge with the given source and destination nodes and properties to the graph.

        Arguments:
            timestamp (int): The timestamp of the edge.
            src (str | int): The id of the source node.
            dst (str | int): The id of the destination node.
            properties (PropInput, optional): The properties of the edge, as a dict of string and properties.
            layer (str, optional): The layer of the edge.
            event_id (int, optional): The optional integer which will be used as an event id.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def add_metadata(self, metadata: dict) -> None:
        """
        Adds metadata to the graph.

        Arguments:
            metadata (dict): The static properties of the graph.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def add_node(
        self,
        timestamp: TimeInput,
        id: str | int,
        properties: Optional[PropInput] = None,
        node_type: Optional[str] = None,
        event_id: Optional[int] = None,
    ) -> None:
        """
        Adds a new node with the given id and properties to the graph.

        Arguments:
           timestamp (TimeInput): The timestamp of the node.
           id (str | int): The id of the node.
           properties (PropInput, optional): The properties of the node.
           node_type (str, optional) : The optional string which will be used as a node type.
           event_id (int, optional): The optional integer which will be used as an event id.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def add_properties(
        self, timestamp: TimeInput, properties: dict, event_id: Optional[int] = None
    ) -> None:
        """
        Adds properties to the graph.

        Arguments:
           timestamp (TimeInput): The timestamp of the temporal property.
           properties (dict): The temporal properties of the graph.
           event_id (int, optional): The optional integer which will be used as an event id.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def cache(self, path: str) -> None:
        """
         Write PersistentGraph to cache file and initialise the cache.

        Future updates are tracked. Use `write_updates` to persist them to the
        cache file. If the file already exists its contents are overwritten.

        Arguments:
            path (str): The path to the cache file

        Returns:
            None:
        """

    def create_index(self) -> None:
        """
        Create graph index

        Returns:
            None:
        """

    def create_index_in_ram(self) -> None:
        """
        Creates a graph index in memory (RAM).

        This is primarily intended for use in tests and should not be used in production environments,
        as the index will not be persisted to disk.

        Returns:
            None:
        """

    def create_index_in_ram_with_spec(self, py_spec: IndexSpec) -> None:
        """
        Creates a graph index in memory (RAM) with the provided index spec.

        This is primarily intended for use in tests and should not be used in production environments,
        as the index will not be persisted to disk.

        Arguments:
            py_spec: The specification for the in-memory index to be created.

         Arguments:
            py_spec (IndexSpec): The specification for the in-memory index to be created.

        Returns:
            None:
        """

    def create_index_with_spec(self, py_spec: Any) -> None:
        """
        Create graph index with the provided index spec.
        Arguments:
            py_spec: - The specification for the in-memory index to be created.

        Returns:
            None:
        """

    def create_node(
        self,
        timestamp: TimeInput,
        id: str | int,
        properties: Optional[PropInput] = None,
        node_type: Optional[str] = None,
        event_id: Optional[int] = None,
    ) -> MutableNode:
        """
        Creates a new node with the given id and properties to the graph. It fails if the node already exists.

        Arguments:
           timestamp (TimeInput): The timestamp of the node.
           id (str | int): The id of the node.
           properties (PropInput, optional): The properties of the node.
           node_type (str, optional) : The optional string which will be used as a node type.
           event_id (int, optional): The optional integer which will be used as an event id.

        Returns:
          MutableNode: the newly created node.

        Raises:
            GraphError: If the operation fails.
        """

    def delete_edge(
        self,
        timestamp: int,
        src: str | int,
        dst: str | int,
        layer: Optional[str] = None,
        event_id: Optional[int] = None,
    ) -> MutableEdge:
        """
        Deletes an edge given the timestamp, src and dst nodes and layer (optional).

        Arguments:
          timestamp (int): The timestamp of the edge.
          src (str | int): The id of the source node.
          dst (str | int): The id of the destination node.
          layer (str, optional): The layer of the edge.
          event_id (int, optional): The optional integer which will be used as an event id.

        Returns:
          MutableEdge: The deleted edge

        Raises:
            GraphError: If the operation fails.
        """

    @staticmethod
    def deserialise(bytes: bytes) -> PersistentGraph:
        """
         Load PersistentGraph from serialised bytes.

        Arguments:
            bytes (bytes): The serialised bytes to decode

        Returns:
           PersistentGraph:
        """

    def edge(self, src: str | int, dst: str | int) -> Optional[MutableEdge]:
        """
        Gets the edge with the specified source and destination nodes

        Arguments:
            src (str | int): the source node id
            dst (str | int): the destination node id

        Returns:
            Optional[MutableEdge]: The edge with the specified source and destination nodes, or None if the edge does not exist
        """

    def event_graph(self) -> Graph:
        """
        Get event graph

        Returns:
            Graph: the graph with event semantics applied
        """

    def get_all_node_types(self) -> list[str]:
        """
        Returns all the node types in the graph.

        Returns:
            list[str]: A list of node types
        """

    def import_edge(self, edge: Edge, merge: bool = False) -> Edge:
        """
        Import a single edge into the graph.

        This function takes an edge object and an optional boolean flag. If the flag is set to true,
        the function will merge the import of the edge even if it already exists in the graph.

        Arguments:
            edge (Edge): An edge object representing the edge to be imported.
            merge (bool): An optional boolean flag indicating whether to merge the import of the edge. Defaults to False.

        Returns:
            Edge: The imported edge.

        Raises:
            GraphError: If the operation fails.
        """

    def import_edge_as(self, edge: Edge, new_id: tuple, merge: bool = False) -> Edge:
        """
        Import a single edge into the graph with new id.

        This function takes a edge object, a new edge id and an optional boolean flag. If the flag is set to true,
        the function will merge the import of the edge even if it already exists in the graph.

        Arguments:
            edge (Edge): A edge object representing the edge to be imported.
            new_id (tuple) : The ID of the new edge. It's a tuple of the source and destination node ids.
            merge (bool): An optional boolean flag indicating whether to merge the import of the edge. Defaults to False.

        Returns:
            Edge: The imported edge.

        Raises:
            GraphError: If the operation fails.
        """

    def import_edges(self, edges: List[Edge], merge: bool = False) -> None:
        """
        Import multiple edges into the graph.

        This function takes a vector of edge objects and an optional boolean flag. If the flag is set to true,
        the function will merge the import of the edges even if they already exist in the graph.

        Arguments:
            edges (List[Edge]): A vector of edge objects representing the edges to be imported.
            merge (bool): An optional boolean flag indicating whether to merge the import of the edges. Defaults to False.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def import_edges_as(
        self, edges: List[Edge], new_ids: list[Tuple[GID, GID]], merge: bool = False
    ) -> None:
        """
        Import multiple edges into the graph with new ids.

        This function takes a vector of edge objects, a list of new edge ids and an optional boolean flag. If the flag is set to true,
        the function will merge the import of the edges even if they already exist in the graph.

        Arguments:
            edges (List[Edge]): A vector of edge objects representing the edges to be imported.
            new_ids (list[Tuple[GID, GID]]): The new edge ids
            merge (bool): An optional boolean flag indicating whether to merge the import of the edges. Defaults to False.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def import_node(self, node: Node, merge: bool = False) -> Node:
        """
        Import a single node into the graph.

        This function takes a node object and an optional boolean flag. If the flag is set to true,
        the function will merge the import of the node even if it already exists in the graph.

        Arguments:
            node (Node): A node object representing the node to be imported.
            merge (bool): An optional boolean flag indicating whether to merge the import of the node. Defaults to False.

        Returns:
            Node: A Node object if the node was successfully imported, and an error otherwise.

        Raises:
            GraphError: If the operation fails.
        """

    def import_node_as(
        self, node: Node, new_id: str | int, merge: bool = False
    ) -> Node:
        """
        Import a single node into the graph with new id.

        This function takes a node object, a new node id and an optional boolean flag. If the flag is set to true,
        the function will merge the import of the node even if it already exists in the graph.

        Arguments:
            node (Node): A node object representing the node to be imported.
            new_id (str|int): The new node id.
            merge (bool): An optional boolean flag indicating whether to merge the import of the node. Defaults to False.

        Returns:
            Node: A Node object if the node was successfully imported, and an error otherwise.

        Raises:
            GraphError: If the operation fails.
        """

    def import_nodes(self, nodes: List[Node], merge: bool = False) -> None:
        """
        Import multiple nodes into the graph.

        This function takes a vector of node objects and an optional boolean flag. If the flag is set to true,
        the function will merge the import of the nodes even if they already exist in the graph.

        Arguments:
            nodes (List[Node]):  A vector of node objects representing the nodes to be imported.
            merge (bool): An optional boolean flag indicating whether to merge the import of the nodes. Defaults to False.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def import_nodes_as(
        self, nodes: List[Node], new_ids: List[str | int], merge: bool = False
    ) -> None:
        """
        Import multiple nodes into the graph with new ids.

        This function takes a vector of node objects, a list of new node ids and an optional boolean flag. If the flag is set to true,
        the function will merge the import of the nodes even if they already exist in the graph.

        Arguments:
            nodes (List[Node]):  A vector of node objects representing the nodes to be imported.
            new_ids (List[str|int]): A list of node IDs to use for the imported nodes.
            merge (bool): An optional boolean flag indicating whether to merge the import of the nodes. Defaults to False.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    @staticmethod
    def load_cached(path: str) -> PersistentGraph:
        """
         Load PersistentGraph from a file and initialise it as a cache file.

        Future updates are tracked. Use `write_updates` to persist them to the
        cache file.

        Arguments:
          path (str): The path to the cache file

        Returns:
           PersistentGraph: the loaded graph with initialised cache
        """

    def load_edge_deletions(
        self,
        data: Any,
        time: str,
        src: str,
        dst: str,
        layer: Optional[str] = None,
        layer_col: Optional[str] = None,
        schema: Optional[
            list[tuple[str, DataType | PropType | str]]
            | dict[str, DataType | PropType | str]
        ] = None,
        csv_options: Optional[dict[str, str | bool]] = None,
    ) -> None:
        """
        Load edge deletions into the graph from any data source that supports the ArrowStreamExportable protocol (by providing an __arrow_c_stream__() method),
        a path to a CSV or Parquet file, or a directory containing multiple CSV or Parquet files.
        The following are known to support the ArrowStreamExportable protocol: Pandas dataframes, FireDucks(.pandas) dataframes,
        Polars dataframes, Arrow tables, DuckDB (e.g. DuckDBPyRelation obtained from running an SQL query).

        Arguments:
            data (Any): The data source containing the edges.
            time (str): The column name for the update timestamps.
            src (str): The column name for the source node ids.
            dst (str): The column name for the destination node ids.
            layer (str, optional): A value to use as the layer for all edges. Cannot be used in combination with layer_col. Defaults to None.
            layer_col (str, optional): The edge layer col name in the data source. Cannot be used in combination with layer. Defaults to None.
            schema (list[tuple[str, DataType | PropType | str]] | dict[str, DataType | PropType | str], optional): A list of (column_name, column_type) tuples or dict of {"column_name": column_type} to cast columns to. Defaults to None.
            csv_options (dict[str, str | bool], optional): A dictionary of CSV reading options such as delimiter, comment, escape, quote, and terminator characters, as well as allow_truncated_rows and has_header flags. Defaults to None.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_edge_metadata(
        self,
        data: Any,
        src: str,
        dst: str,
        metadata: Optional[List[str]] = None,
        shared_metadata: Optional[PropInput] = None,
        layer: Optional[str] = None,
        layer_col: Optional[str] = None,
        schema: Optional[
            list[tuple[str, DataType | PropType | str]]
            | dict[str, DataType | PropType | str]
        ] = None,
        csv_options: Optional[dict[str, str | bool]] = None,
    ) -> None:
        """
        Load edge metadata into the graph from any data source that supports the ArrowStreamExportable protocol (by providing an __arrow_c_stream__() method),
        a path to a CSV or Parquet file, or a directory containing multiple CSV or Parquet files.
        The following are known to support the ArrowStreamExportable protocol: Pandas dataframes, FireDucks(.pandas) dataframes,
        Polars dataframes, Arrow tables, DuckDB (e.g. DuckDBPyRelation obtained from running an SQL query).

        Arguments:
            data (Any): The data source containing edge information.
            src (str): The column name for the source node.
            dst (str): The column name for the destination node.
            metadata (List[str], optional): List of edge metadata column names. Defaults to None.
            shared_metadata (PropInput, optional): A dictionary of metadata properties that will be added to every edge. Defaults to None.
            layer (str, optional): The edge layer name. Defaults to None.
            layer_col (str, optional): The edge layer column name in a dataframe. Defaults to None.
            schema (list[tuple[str, DataType | PropType | str]] | dict[str, DataType | PropType | str], optional): A list of (column_name, column_type) tuples or dict of {"column_name": column_type} to cast columns to. Defaults to None.
            csv_options (dict[str, str | bool], optional): A dictionary of CSV reading options such as delimiter, comment, escape, quote, and terminator characters, as well as allow_truncated_rows and has_header flags. Defaults to None.

        Returns:
            None: This function does not return a value if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_edges(
        self,
        data: Any,
        time: str,
        src: str,
        dst: str,
        properties: Optional[List[str]] = None,
        metadata: Optional[List[str]] = None,
        shared_metadata: Optional[PropInput] = None,
        layer: Optional[str] = None,
        layer_col: Optional[str] = None,
        schema: Optional[
            list[tuple[str, DataType | PropType | str]]
            | dict[str, DataType | PropType | str]
        ] = None,
        csv_options: Optional[dict[str, str | bool]] = None,
    ) -> None:
        """
        Load edges into the graph from any data source that supports the ArrowStreamExportable protocol (by providing an __arrow_c_stream__() method),
        a path to a CSV or Parquet file, or a directory containing multiple CSV or Parquet files.
        The following are known to support the ArrowStreamExportable protocol: Pandas dataframes, FireDucks(.pandas) dataframes,
        Polars dataframes, Arrow tables, DuckDB (e.g. DuckDBPyRelation obtained from running an SQL query).

        Arguments:
            data (Any): The data source containing the edges.
            time (str): The column name for the update timestamps.
            src (str): The column name for the source node IDs.
            dst (str): The column name for the destination node IDs.
            properties (List[str], optional): List of edge property column names. Defaults to None.
            metadata (List[str], optional): List of edge metadata column names. Defaults to None.
            shared_metadata (PropInput, optional): A dictionary of metadata properties that will be added to every edge. Defaults to None.
            layer (str, optional): A value to use as the layer for all edges. Cannot be used in combination with layer_col. Defaults to None.
            layer_col (str, optional): The edge layer column name in a dataframe. Cannot be used in combination with layer. Defaults to None.
            schema (list[tuple[str, DataType | PropType | str]] | dict[str, DataType | PropType | str], optional): A list of (column_name, column_type) tuples or dict of {"column_name": column_type} to cast columns to. Defaults to None.
            csv_options (dict[str, str | bool], optional): A dictionary of CSV reading options such as delimiter, comment, escape, quote, and terminator characters, as well as allow_truncated_rows and has_header flags. Defaults to None.

        Returns:
            None: This function does not return a value if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    @staticmethod
    def load_from_file(path: str) -> PersistentGraph:
        """
         Load PersistentGraph from a file.

        Arguments:
          path (str): The path to the file.

        Returns:
           PersistentGraph:
        """

    def load_node_metadata(
        self,
        data: Any,
        id: str,
        node_type: Optional[str] = None,
        node_type_col: Optional[str] = None,
        metadata: Optional[List[str]] = None,
        shared_metadata: Optional[PropInput] = None,
        schema: Optional[
            list[tuple[str, DataType | PropType | str]]
            | dict[str, DataType | PropType | str]
        ] = None,
        csv_options: Optional[dict[str, str | bool]] = None,
    ) -> None:
        """
        Load node metadata into the graph from any data source that supports the ArrowStreamExportable protocol (by providing an __arrow_c_stream__() method),
        a path to a CSV or Parquet file, or a directory containing multiple CSV or Parquet files.
        The following are known to support the ArrowStreamExportable protocol: Pandas dataframes, FireDucks(.pandas) dataframes,
        Polars dataframes, Arrow tables, DuckDB (e.g. DuckDBPyRelation obtained from running an SQL query).

        Arguments:
            data (Any): The data source containing node information.
            id(str): The column name for the node IDs.
            node_type (str, optional): A value to use as the node type for all nodes. Cannot be used in combination with node_type_col. Defaults to None.
            node_type_col (str, optional): The node type column name in a dataframe. Cannot be used in combination with node_type. Defaults to None.
            metadata (List[str], optional): List of node metadata column names. Defaults to None.
            shared_metadata (PropInput, optional): A dictionary of metadata properties that will be added to every node. Defaults to None.
            schema (list[tuple[str, DataType | PropType | str]] | dict[str, DataType | PropType | str], optional): A list of (column_name, column_type) tuples or dict of {"column_name": column_type} to cast columns to. Defaults to None.
            csv_options (dict[str, str | bool], optional): A dictionary of CSV reading options such as delimiter, comment, escape, quote, and terminator characters, as well as allow_truncated_rows and has_header flags. Defaults to None.

        Returns:
            None: This function does not return a value if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_nodes(
        self,
        data: Any,
        time: str,
        id: str,
        node_type: Optional[str] = None,
        node_type_col: Optional[str] = None,
        properties: Optional[List[str]] = None,
        metadata: Optional[List[str]] = None,
        shared_metadata: Optional[PropInput] = None,
        schema: Optional[
            list[tuple[str, DataType | PropType | str]]
            | dict[str, DataType | PropType | str]
        ] = None,
        csv_options: Optional[dict[str, str | bool]] = None,
    ) -> None:
        """
        Load nodes into the graph from any data source that supports the ArrowStreamExportable protocol (by providing an __arrow_c_stream__() method),
        a path to a CSV or Parquet file, or a directory containing multiple CSV or Parquet files.
        The following are known to support the ArrowStreamExportable protocol: Pandas dataframes, FireDucks(.pandas) dataframes,
        Polars dataframes, Arrow tables, DuckDB (e.g. DuckDBPyRelation obtained from running an SQL query).

        Arguments:
            data (Any): The data source containing the nodes.
            time (str): The column name for the timestamps.
            id (str): The column name for the node IDs.
            node_type (str, optional): A value to use as the node type for all nodes. Cannot be used in combination with node_type_col. Defaults to None.
            node_type_col (str, optional): The node type column name in a dataframe. Cannot be used in combination with node_type. Defaults to None.
            properties (List[str], optional): List of node property column names. Defaults to None.
            metadata (List[str], optional): List of node metadata column names. Defaults to None.
            shared_metadata (PropInput, optional): A dictionary of metadata properties that will be added to every node. Defaults to None.
            schema (list[tuple[str, DataType | PropType | str]] | dict[str, DataType | PropType | str], optional): A list of (column_name, column_type) tuples or dict of {"column_name": column_type} to cast columns to. Defaults to None.
            csv_options (dict[str, str | bool], optional): A dictionary of CSV reading options such as delimiter, comment, escape, quote, and terminator characters, as well as allow_truncated_rows and has_header flags. Defaults to None.

        Returns:
            None: This function does not return a value if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def node(self, id: str | int) -> Optional[MutableNode]:
        """
        Gets the node with the specified id

        Arguments:
            id (str | int): the node id

        Returns:
            Optional[MutableNode]: The node with the specified id, or None if the node does not exist
        """

    def persistent_graph(self) -> PersistentGraph:
        """
        Get persistent graph

        Returns:
            PersistentGraph: the graph with persistent semantics applied
        """

    def save_to_file(self, path: str) -> None:
        """
         Saves the PersistentGraph to the given path.

        Arguments:
            path (str): The path to the file.

        Returns:
            None:
        """

    def save_to_zip(self, path: str) -> None:
        """
         Saves the PersistentGraph to the given path.

        Arguments:
            path (str): The path to the file.
        Returns:
            None:
        """

    def serialise(self) -> bytes:
        """
         Serialise PersistentGraph to bytes.

        Returns:
          bytes:
        """

    def update_metadata(self, metadata: dict) -> None:
        """
        Updates metadata of the graph.

        Arguments:
            metadata (dict): The static properties of the graph.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def write_updates(self) -> None:
        """
        Persist the new updates by appending them to the cache file.

        Returns:
            None:
        """

class Node(object):
    """A node (or node) in the graph."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __hash__(self):
        """Return hash(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> Node:
        """
         Create a view of the Node including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             Node:
        """

    def at(self, time: TimeInput) -> Node:
        """
         Create a view of the Node including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             Node:
        """

    def before(self, end: TimeInput) -> Node:
        """
         Create a view of the Node including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             Node:
        """

    def default_layer(self) -> Node:
        """
         Return a view of Node containing only the default edge layer
        Returns:
             Node: The layered view
        """

    def degree(self) -> int:
        """
        Get the degree of this node (i.e., the number of edges that are incident to it).

        Returns:
            int: The degree of this node.
        """

    @property
    def earliest_time(self) -> OptionalEventTime:
        """
        Returns the earliest time that the node exists.

        Returns:
            OptionalEventTime: The earliest time that the node exists.
        """

    def edge_history_count(self) -> int:
        """
        Get the number of edge events for this node

        Returns:
            int: The number of edge events
        """

    @property
    def edges(self) -> Edges:
        """
        Get the edges that are incident to this node.

        Returns:
             Edges: The incident edges.
        """

    @property
    def end(self) -> OptionalEventTime:
        """
         Gets the latest time that this Node is valid.

        Returns:
           OptionalEventTime: The latest time that this Node is valid or None if the Node is valid for all times.
        """

    def exclude_layer(self, name: str) -> Node:
        """
         Return a view of Node containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             Node: The layered view
        """

    def exclude_layers(self, names: list[str]) -> Node:
        """
         Return a view of Node containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             Node: The layered view
        """

    def exclude_valid_layer(self, name: str) -> Node:
        """
         Return a view of Node containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             Node: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> Node:
        """
         Return a view of Node containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             Node: The layered view
        """

    def expanding(
        self, step: int | str, alignment_unit: str | None = None
    ) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step. For example, if the step is "1 month and 1 day",
                the windows will be aligned on days (00:00:00 to 23:59:59).
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def filter(self, filter: filter.FilterExpr) -> Node:
        """
        Return a filtered view that only includes nodes and edges that satisfy the filter

        Arguments:
            filter (filter.FilterExpr): The filter to apply to the nodes and edges.

        Returns:
            Node: The filtered view
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if Node has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    @property
    def history(self) -> History:
        """
        Returns the history of a node, including node additions and changes made to node.

        Returns:
            History: A History object for the node, providing access to time entries.
        """

    @property
    def id(self) -> str | int:
        """
        Returns the id of the node.
        This is a unique identifier for the node.

        Returns:
           (str|int): The id of the node.
        """

    def in_degree(self) -> int:
        """
        Get the in-degree of this node (i.e., the number of edges that are incident to it from other nodes).

        Returns:
           int: The in-degree of this node.
        """

    @property
    def in_edges(self) -> Edges:
        """
        Get the edges that point into this node.

        Returns:
             Edges: The inbound edges.
        """

    @property
    def in_neighbours(self) -> PathFromNode:
        """
        Get the neighbours of this node that point into this node.

        Returns:
             PathFromNode: The in-neighbours.
        """

    def is_active(self) -> bool:
        """
        Check if the node is active (it's history is not empty).

        Returns:
            bool:
        """

    def latest(self) -> Node:
        """
         Create a view of the Node including all events at the latest time.

        Returns:
             Node:
        """

    @property
    def latest_time(self) -> OptionalEventTime:
        """
        Returns the latest time that the node exists.

        Returns:
           OptionalEventTime: The latest time that the node exists.
        """

    def layer(self, name: str) -> Node:
        """
         Return a view of Node containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             Node: The layered view
        """

    def layers(self, names: list[str]) -> Node:
        """
         Return a view of Node containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             Node: The layered view
        """

    @property
    def metadata(self) -> Metadata:
        """
        The metadata of the node

        Returns:
            Metadata:
        """

    @property
    def name(self) -> str:
        """
        Returns the name of the node.

        Returns:
            str: The id of the node as a string.
        """

    @property
    def neighbours(self) -> PathFromNode:
        """
        Get the neighbours of this node.

        Returns:
             PathFromNode: The neighbours (both inbound and outbound).
        """

    @property
    def node_type(self) -> Optional[str]:
        """
        Returns the type of node

        Returns:
            Optional[str]: The node type if it is set or `None` otherwise.
        """

    def out_degree(self) -> int:
        """
        Get the out-degree of this node (i.e., the number of edges that are incident to it from this node).

        Returns:
          int: The out-degree of this node.
        """

    @property
    def out_edges(self) -> Edges:
        """
        Get the edges that point out of this node.

        Returns:
             Edges: The outbound edges.
        """

    @property
    def out_neighbours(self) -> PathFromNode:
        """
        Get the neighbours of this node that point out of this node.

        Returns:
             PathFromNode: The out-neighbours.
        """

    @property
    def properties(self) -> Properties:
        """
        The properties of the node

        Returns:
            Properties: A list of properties.
        """

    def rolling(
        self,
        window: int | str,
        step: int | str | None = None,
        alignment_unit: str | None = None,
    ) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.
        If `alignment_unit` is not "unaligned" and a `step` larger than `window` is provided, some time entries
        may appear before the start of the first window and/or after the end of the last window (i.e. not included in any window).

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step (or window if no step is passed).
                For example, if the step is "1 month and 1 day",
                the first window will begin at the start of the day of the first time event.
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> Node:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             Node:
        """

    def shrink_start(self, start: TimeInput) -> Node:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             Node:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> Node:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             Node:
        """

    def snapshot_at(self, time: TimeInput) -> Node:
        """
         Create a view of the Node including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             Node:
        """

    def snapshot_latest(self) -> Node:
        """
         Create a view of the Node including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             Node:
        """

    @property
    def start(self) -> OptionalEventTime:
        """
         Gets the start time for rolling and expanding windows for this Node

        Returns:
            OptionalEventTime: The earliest time that this Node is valid or None if the Node is valid for all times.
        """

    def valid_layers(self, names: list[str]) -> Node:
        """
         Return a view of Node containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             Node: The layered view
        """

    def window(self, start: TimeInput, end: TimeInput) -> Node:
        """
         Create a view of the Node including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput): The start time of the window.
            end (TimeInput): The end time of the window.

        Returns:
            Node:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this Node.

        Returns:
            Optional[int]:
        """

class Nodes(object):
    """A list of nodes that can be iterated over."""

    def __bool__(self):
        """True if self else False"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> Nodes:
        """
         Create a view of the Nodes including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             Nodes:
        """

    def at(self, time: TimeInput) -> Nodes:
        """
         Create a view of the Nodes including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             Nodes:
        """

    def before(self, end: TimeInput) -> Nodes:
        """
         Create a view of the Nodes including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             Nodes:
        """

    def collect(self) -> list[Node]:
        """
         Collect all nodes into a list

        Returns:
             list[Node]: the list of nodes
        """

    def default_layer(self) -> Nodes:
        """
         Return a view of Nodes containing only the default edge layer
        Returns:
             Nodes: The layered view
        """

    def degree(self) -> DegreeView:
        """
        Returns the number of edges of the nodes.

        Returns:
            DegreeView: a view of the undirected node degrees.
        """

    @property
    def earliest_time(self) -> EarliestTimeView:
        """
        The earliest times nodes are active

        Returns:
            EarliestTimeView: a view of the earliest active times
        """

    def edge_history_count(self) -> EdgeHistoryCountView:
        """
        Return the number of edge updates for each node

        Returns:
            EdgeHistoryCountView: a view of the edge history counts
        """

    @property
    def edges(self) -> NestedEdges:
        """
        Get the edges that are incident to this node.

        Returns:
             NestedEdges: The incident edges.
        """

    @property
    def end(self) -> OptionalEventTime:
        """
         Gets the latest time that this Nodes is valid.

        Returns:
           OptionalEventTime: The latest time that this Nodes is valid or None if the Nodes is valid for all times.
        """

    def exclude_layer(self, name: str) -> Nodes:
        """
         Return a view of Nodes containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             Nodes: The layered view
        """

    def exclude_layers(self, names: list[str]) -> Nodes:
        """
         Return a view of Nodes containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             Nodes: The layered view
        """

    def exclude_valid_layer(self, name: str) -> Nodes:
        """
         Return a view of Nodes containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             Nodes: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> Nodes:
        """
         Return a view of Nodes containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             Nodes: The layered view
        """

    def expanding(
        self, step: int | str, alignment_unit: str | None = None
    ) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step. For example, if the step is "1 month and 1 day",
                the windows will be aligned on days (00:00:00 to 23:59:59).
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def filter(self, filter: filter.FilterExpr) -> Nodes:
        """
        Return a filtered view that only includes nodes and edges that satisfy the filter

        Arguments:
            filter (filter.FilterExpr): The filter to apply to the nodes and edges.

        Returns:
            Nodes: The filtered view
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if Nodes has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    @property
    def history(self) -> HistoryView:
        """
        Returns all history objects of nodes, with information on when a node is added or change to a node is made.

        Returns:
           HistoryView: a view of the node histories
        """

    @property
    def id(self) -> IdView:
        """
        The node ids

        Returns:
            IdView: a view of the node ids
        """

    def in_degree(self) -> DegreeView:
        """
        Returns the number of in edges of the nodes.

        Returns:
            DegreeView: a view of the in-degrees of the nodes
        """

    @property
    def in_edges(self) -> NestedEdges:
        """
        Get the edges that point into this node.

        Returns:
             NestedEdges: The inbound edges.
        """

    @property
    def in_neighbours(self) -> PathFromGraph:
        """
        Get the neighbours of this node that point into this node.

        Returns:
             PathFromGraph: The in-neighbours.
        """

    def latest(self) -> Nodes:
        """
         Create a view of the Nodes including all events at the latest time.

        Returns:
             Nodes:
        """

    @property
    def latest_time(self) -> LatestTimeView:
        """
        The latest time nodes are active

        Returns:
            LatestTimeView: a view of the latest active times
        """

    def layer(self, name: str) -> Nodes:
        """
         Return a view of Nodes containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             Nodes: The layered view
        """

    def layers(self, names: list[str]) -> Nodes:
        """
         Return a view of Nodes containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             Nodes: The layered view
        """

    @property
    def metadata(self) -> MetadataView:
        """
        The metadata of the nodes.

        Returns:
            MetadataView: A view of the node properties.
        """

    @property
    def name(self) -> NameView:
        """
        The node names

        Returns:
            NameView: a view of the node names
        """

    @property
    def neighbours(self) -> PathFromGraph:
        """
        Get the neighbours of this node.

        Returns:
             PathFromGraph: The neighbours (both inbound and outbound).
        """

    @property
    def node_type(self) -> NodeTypeView:
        """
        The node types

        Returns:
            NodeTypeView: a view of the node types
        """

    def out_degree(self) -> DegreeView:
        """
        Returns the number of out edges of the nodes.

        Returns:
            DegreeView: a view of the out-degrees of the nodes.
        """

    @property
    def out_edges(self) -> NestedEdges:
        """
        Get the edges that point out of this node.

        Returns:
             NestedEdges: The outbound edges.
        """

    @property
    def out_neighbours(self) -> PathFromGraph:
        """
        Get the neighbours of this node that point out of this node.

        Returns:
             PathFromGraph: The out-neighbours.
        """

    @property
    def properties(self) -> PropertiesView:
        """
        The properties of the node.

        Returns:
            PropertiesView: A view of the node properties.
        """

    def rolling(
        self,
        window: int | str,
        step: int | str | None = None,
        alignment_unit: str | None = None,
    ) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.
        If `alignment_unit` is not "unaligned" and a `step` larger than `window` is provided, some time entries
        may appear before the start of the first window and/or after the end of the last window (i.e. not included in any window).

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step (or window if no step is passed).
                For example, if the step is "1 month and 1 day",
                the first window will begin at the start of the day of the first time event.
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> Nodes:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             Nodes:
        """

    def shrink_start(self, start: TimeInput) -> Nodes:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             Nodes:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> Nodes:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             Nodes:
        """

    def snapshot_at(self, time: TimeInput) -> Nodes:
        """
         Create a view of the Nodes including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             Nodes:
        """

    def snapshot_latest(self) -> Nodes:
        """
         Create a view of the Nodes including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             Nodes:
        """

    @property
    def start(self) -> OptionalEventTime:
        """
         Gets the start time for rolling and expanding windows for this Nodes

        Returns:
            OptionalEventTime: The earliest time that this Nodes is valid or None if the Nodes is valid for all times.
        """

    def to_df(
        self, include_property_history: bool = False, convert_datetime: bool = False
    ) -> DataFrame:
        """
        Converts the graph's nodes into a Pandas DataFrame.

        This method will create a DataFrame with the following columns:
        - "name": The name of the node.
        - "properties": The properties of the node.
        - "update_history": The update history of the node.

        Args:
            include_property_history (bool): A boolean, if set to `True`, the history of each property is included, if `False`, only the latest value is shown. Defaults to False.
            convert_datetime (bool): A boolean, if set to `True` will convert the timestamp to python datetimes. Defaults to False.

        Returns:
            DataFrame: the view of the node data as a pandas Dataframe.
        """

    def type_filter(self, node_types: list[str]) -> Nodes:
        """
        Filter nodes by node type.

        Arguments:
            node_types (list[str]): the list of node types to keep.

        Returns:
            Nodes: the filtered view of the nodes
        """

    def valid_layers(self, names: list[str]) -> Nodes:
        """
         Return a view of Nodes containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             Nodes: The layered view
        """

    def window(self, start: TimeInput, end: TimeInput) -> Nodes:
        """
         Create a view of the Nodes including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput): The start time of the window.
            end (TimeInput): The end time of the window.

        Returns:
            Nodes:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this Nodes.

        Returns:
            Optional[int]:
        """

class PathFromNode(object):
    def __bool__(self):
        """True if self else False"""

    def __getitem__(self, key):
        """Return self[key]."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> PathFromNode:
        """
         Create a view of the PathFromNode including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             PathFromNode:
        """

    def at(self, time: TimeInput) -> PathFromNode:
        """
         Create a view of the PathFromNode including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             PathFromNode:
        """

    def before(self, end: TimeInput) -> PathFromNode:
        """
         Create a view of the PathFromNode including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             PathFromNode:
        """

    def collect(self) -> list[Node]:
        """
         Collect all nodes into a list

        Returns:
             list[Node]: the list of nodes
        """

    def combined_history(self) -> History:
        """
        Returns a single history object containing time entries for all nodes in the path.

        Returns:
            History: History object with all time entries for the nodes.
        """

    def default_layer(self) -> PathFromNode:
        """
         Return a view of PathFromNode containing only the default edge layer
        Returns:
             PathFromNode: The layered view
        """

    def degree(self) -> UsizeIterable:
        """
        The node degrees.

        Returns:
            UsizeIterable:
        """

    @property
    def earliest_time(self):
        """
        The earliest time of each node.

        Returns:
            OptionEventTimeIterable: An iterable of `EventTime`s.
        """

    def edge_history_count(self) -> UsizeIterable:
        """
        Get the number of edge updates for each node.

        Returns:
            UsizeIterable:
        """

    @property
    def edges(self) -> Edges:
        """
        Get the edges that are incident to this node.

        Returns:
             Edges: The incident edges.
        """

    @property
    def end(self) -> OptionalEventTime:
        """
         Gets the latest time that this PathFromNode is valid.

        Returns:
           OptionalEventTime: The latest time that this PathFromNode is valid or None if the PathFromNode is valid for all times.
        """

    def exclude_layer(self, name: str) -> PathFromNode:
        """
         Return a view of PathFromNode containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             PathFromNode: The layered view
        """

    def exclude_layers(self, names: list[str]) -> PathFromNode:
        """
         Return a view of PathFromNode containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             PathFromNode: The layered view
        """

    def exclude_valid_layer(self, name: str) -> PathFromNode:
        """
         Return a view of PathFromNode containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             PathFromNode: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> PathFromNode:
        """
         Return a view of PathFromNode containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             PathFromNode: The layered view
        """

    def expanding(
        self, step: int | str, alignment_unit: str | None = None
    ) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step. For example, if the step is "1 month and 1 day",
                the windows will be aligned on days (00:00:00 to 23:59:59).
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def filter(self, filter: filter.FilterExpr) -> PathFromNode:
        """
        Return a filtered view that only includes nodes and edges that satisfy the filter

        Arguments:
            filter (filter.FilterExpr): The filter to apply to the nodes and edges.

        Returns:
            PathFromNode: The filtered view
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if PathFromNode has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    @property
    def id(self):
        """
        The node IDs.

        Returns:
            GIDIterable:
        """

    def in_degree(self) -> UsizeIterable:
        """
        The node in-degrees.

        Returns:
            UsizeIterable:
        """

    @property
    def in_edges(self) -> Edges:
        """
        Get the edges that point into this node.

        Returns:
             Edges: The inbound edges.
        """

    @property
    def in_neighbours(self) -> PathFromNode:
        """
        Get the neighbours of this node that point into this node.

        Returns:
             PathFromNode: The in-neighbours.
        """

    def latest(self) -> PathFromNode:
        """
         Create a view of the PathFromNode including all events at the latest time.

        Returns:
             PathFromNode:
        """

    @property
    def latest_time(self):
        """
        The latest time of each node.

        Returns:
            OptionEventTimeIterable: An iterable of `EventTime`s.
        """

    def layer(self, name: str) -> PathFromNode:
        """
         Return a view of PathFromNode containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             PathFromNode: The layered view
        """

    def layers(self, names: list[str]) -> PathFromNode:
        """
         Return a view of PathFromNode containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             PathFromNode: The layered view
        """

    @property
    def metadata(self) -> MetadataView:
        """
        The node metadata.

        Returns:
            MetadataView:
        """

    @property
    def name(self):
        """
        The node names.

        Returns:
            StringIterable:
        """

    @property
    def neighbours(self) -> PathFromNode:
        """
        Get the neighbours of this node.

        Returns:
             PathFromNode: The neighbours (both inbound and outbound).
        """

    @property
    def node_type(self):
        """
        The node types.

        Returns:
            OptionArcStringIterable:
        """

    def out_degree(self) -> UsizeIterable:
        """
        The node out-degrees.

        Returns:
            UsizeIterable:
        """

    @property
    def out_edges(self) -> Edges:
        """
        Get the edges that point out of this node.

        Returns:
             Edges: The outbound edges.
        """

    @property
    def out_neighbours(self) -> PathFromNode:
        """
        Get the neighbours of this node that point out of this node.

        Returns:
             PathFromNode: The out-neighbours.
        """

    @property
    def properties(self) -> PropertiesView:
        """
        The node properties.

        Returns:
            PropertiesView:
        """

    def rolling(
        self,
        window: int | str,
        step: int | str | None = None,
        alignment_unit: str | None = None,
    ) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.
        If `alignment_unit` is not "unaligned" and a `step` larger than `window` is provided, some time entries
        may appear before the start of the first window and/or after the end of the last window (i.e. not included in any window).

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step (or window if no step is passed).
                For example, if the step is "1 month and 1 day",
                the first window will begin at the start of the day of the first time event.
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> PathFromNode:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             PathFromNode:
        """

    def shrink_start(self, start: TimeInput) -> PathFromNode:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             PathFromNode:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> PathFromNode:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             PathFromNode:
        """

    def snapshot_at(self, time: TimeInput) -> PathFromNode:
        """
         Create a view of the PathFromNode including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             PathFromNode:
        """

    def snapshot_latest(self) -> PathFromNode:
        """
         Create a view of the PathFromNode including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             PathFromNode:
        """

    @property
    def start(self) -> OptionalEventTime:
        """
         Gets the start time for rolling and expanding windows for this PathFromNode

        Returns:
            OptionalEventTime: The earliest time that this PathFromNode is valid or None if the PathFromNode is valid for all times.
        """

    def type_filter(self, node_types: list[str]) -> PathFromNode:
        """
        filter nodes by type

        Arguments:
            node_types (list[str]): the node types to keep

        Returns:
            PathFromNode: the filtered view
        """

    def valid_layers(self, names: list[str]) -> PathFromNode:
        """
         Return a view of PathFromNode containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             PathFromNode: The layered view
        """

    def window(self, start: TimeInput, end: TimeInput) -> PathFromNode:
        """
         Create a view of the PathFromNode including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput): The start time of the window.
            end (TimeInput): The end time of the window.

        Returns:
            PathFromNode:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this PathFromNode.

        Returns:
            Optional[int]:
        """

class PathFromGraph(object):
    def __bool__(self):
        """True if self else False"""

    def __getitem__(self, key):
        """Return self[key]."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> PathFromGraph:
        """
         Create a view of the PathFromGraph including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             PathFromGraph:
        """

    def at(self, time: TimeInput) -> PathFromGraph:
        """
         Create a view of the PathFromGraph including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             PathFromGraph:
        """

    def before(self, end: TimeInput) -> PathFromGraph:
        """
         Create a view of the PathFromGraph including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             PathFromGraph:
        """

    def collect(self) -> list[list[Node]]:
        """
         Collect all nodes into a list

        Returns:
             list[list[Node]]: the list of nodes
        """

    def combined_history(self) -> History:
        """
        Returns a single history object containing time entries for all nodes in the path.

        Returns:
            History: A history object with all time entries associated with the nodes.
        """

    def default_layer(self) -> PathFromGraph:
        """
         Return a view of PathFromGraph containing only the default edge layer
        Returns:
             PathFromGraph: The layered view
        """

    def degree(self):
        """
        Returns the node degrees.

        Returns:
            NestedUsizeIterable:
        """

    @property
    def earliest_time(self):
        """
        The node earliest times.

        Returns:
            NestedOptionEventTimeIterable:
        """

    def edge_history_count(self):
        """
        Returns the number of edge updates for each node.

        Returns:
            NestedUsizeIterable:
        """

    @property
    def edges(self) -> NestedEdges:
        """
        Get the edges that are incident to this node.

        Returns:
             NestedEdges: The incident edges.
        """

    @property
    def end(self) -> OptionalEventTime:
        """
         Gets the latest time that this PathFromGraph is valid.

        Returns:
           OptionalEventTime: The latest time that this PathFromGraph is valid or None if the PathFromGraph is valid for all times.
        """

    def exclude_layer(self, name: str) -> PathFromGraph:
        """
         Return a view of PathFromGraph containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             PathFromGraph: The layered view
        """

    def exclude_layers(self, names: list[str]) -> PathFromGraph:
        """
         Return a view of PathFromGraph containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             PathFromGraph: The layered view
        """

    def exclude_valid_layer(self, name: str) -> PathFromGraph:
        """
         Return a view of PathFromGraph containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             PathFromGraph: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> PathFromGraph:
        """
         Return a view of PathFromGraph containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             PathFromGraph: The layered view
        """

    def expanding(
        self, step: int | str, alignment_unit: str | None = None
    ) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step. For example, if the step is "1 month and 1 day",
                the windows will be aligned on days (00:00:00 to 23:59:59).
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def filter(self, filter: filter.FilterExpr) -> PathFromGraph:
        """
        Return a filtered view that only includes nodes and edges that satisfy the filter

        Arguments:
            filter (filter.FilterExpr): The filter to apply to the nodes and edges.

        Returns:
            PathFromGraph: The filtered view
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if PathFromGraph has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    @property
    def history(self):
        """
        Returns a history object for each node with time entries for when a node is added or change to a node is made.

        Returns:
            NestedHistoryIterable: A nested iterable of history objects, one for each node.
        """

    @property
    def id(self):
        """
        The node ids

        Returns:
            NestedGIDIterable:
        """

    def in_degree(self):
        """
        Returns the node in-degrees.

        Returns:
            NestedUsizeIterable:
        """

    @property
    def in_edges(self) -> NestedEdges:
        """
        Get the edges that point into this node.

        Returns:
             NestedEdges: The inbound edges.
        """

    @property
    def in_neighbours(self) -> PathFromGraph:
        """
        Get the neighbours of this node that point into this node.

        Returns:
             PathFromGraph: The in-neighbours.
        """

    def latest(self) -> PathFromGraph:
        """
         Create a view of the PathFromGraph including all events at the latest time.

        Returns:
             PathFromGraph:
        """

    @property
    def latest_time(self):
        """
        The node latest times.

        Returns:
            NestedOptionEventTimeIterable:
        """

    def layer(self, name: str) -> PathFromGraph:
        """
         Return a view of PathFromGraph containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             PathFromGraph: The layered view
        """

    def layers(self, names: list[str]) -> PathFromGraph:
        """
         Return a view of PathFromGraph containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             PathFromGraph: The layered view
        """

    @property
    def metadata(self):
        """
        Returns the node metadata.

        Returns:
            MetadataListList:
        """

    @property
    def name(self):
        """
        The node names.

        Returns:
            NestedStringIterable:
        """

    @property
    def neighbours(self) -> PathFromGraph:
        """
        Get the neighbours of this node.

        Returns:
             PathFromGraph: The neighbours (both inbound and outbound).
        """

    @property
    def node_type(self):
        """
        The node types.

        Returns:
            NestedOptionArcStringIterable:
        """

    def out_degree(self):
        """
        Returns the node out-degrees.

        Returns:
            NestedUsizeIterable:
        """

    @property
    def out_edges(self) -> NestedEdges:
        """
        Get the edges that point out of this node.

        Returns:
             NestedEdges: The outbound edges.
        """

    @property
    def out_neighbours(self) -> PathFromGraph:
        """
        Get the neighbours of this node that point out of this node.

        Returns:
             PathFromGraph: The out-neighbours.
        """

    @property
    def properties(self) -> PyNestedPropsIterable:
        """
        Returns the node properties.

        Returns:
            PyNestedPropsIterable:
        """

    def rolling(
        self,
        window: int | str,
        step: int | str | None = None,
        alignment_unit: str | None = None,
    ) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.
        If `alignment_unit` is not "unaligned" and a `step` larger than `window` is provided, some time entries
        may appear before the start of the first window and/or after the end of the last window (i.e. not included in any window).

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step (or window if no step is passed).
                For example, if the step is "1 month and 1 day",
                the first window will begin at the start of the day of the first time event.
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> PathFromGraph:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             PathFromGraph:
        """

    def shrink_start(self, start: TimeInput) -> PathFromGraph:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             PathFromGraph:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> PathFromGraph:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             PathFromGraph:
        """

    def snapshot_at(self, time: TimeInput) -> PathFromGraph:
        """
         Create a view of the PathFromGraph including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             PathFromGraph:
        """

    def snapshot_latest(self) -> PathFromGraph:
        """
         Create a view of the PathFromGraph including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             PathFromGraph:
        """

    @property
    def start(self) -> OptionalEventTime:
        """
         Gets the start time for rolling and expanding windows for this PathFromGraph

        Returns:
            OptionalEventTime: The earliest time that this PathFromGraph is valid or None if the PathFromGraph is valid for all times.
        """

    def type_filter(self, node_types: list[str]) -> PathFromGraph:
        """
        filter nodes by type

        Arguments:
            node_types (list[str]): the node types to keep

        Returns:
            PathFromGraph: the filtered view
        """

    def valid_layers(self, names: list[str]) -> PathFromGraph:
        """
         Return a view of PathFromGraph containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             PathFromGraph: The layered view
        """

    def window(self, start: TimeInput, end: TimeInput) -> PathFromGraph:
        """
         Create a view of the PathFromGraph including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput): The start time of the window.
            end (TimeInput): The end time of the window.

        Returns:
            PathFromGraph:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this PathFromGraph.

        Returns:
            Optional[int]:
        """

class MutableNode(Node):
    def __repr__(self):
        """Return repr(self)."""

    def add_metadata(self, metadata: PropInput) -> None:
        """
        Add metadata to a node in the graph.
        This function is used to add properties to a node that do not
        change over time. These properties are fundamental attributes of the node.

        Arguments:
            metadata (PropInput): A dictionary of properties to be added to the node. Each key is a string representing the property name, and each value is of type Prop representing the property value.

        Returns:
            None:
        """

    def add_updates(
        self,
        t: TimeInput,
        properties: Optional[PropInput] = None,
        event_id: Optional[int] = None,
    ) -> None:
        """
        Add updates to a node in the graph at a specified time.
        This function allows for the addition of property updates to a node within the graph. The updates are time-stamped, meaning they are applied at the specified time.

        Arguments:
           t (TimeInput): The timestamp at which the updates should be applied.
           properties (PropInput, optional): A dictionary of properties to update. Each key is a
                                             string representing the property name, and each value
                                             is of type Prop representing the property value.
                                             If None, no properties are updated.
           event_id (int, optional): The optional integer which will be used as an event id.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def set_node_type(self, new_type: str) -> None:
        """
        Set the type on the node. This only works if the type has not been previously set, otherwise will
        throw an error

        Arguments:
            new_type (str): The new type to be set

        Returns:
            None:
        """

    def update_metadata(self, metadata: PropInput) -> None:
        """
        Update metadata of a node in the graph overwriting existing values.
        This function is used to add properties to a node that do not
        change over time. These properties are fundamental attributes of the node.

        Arguments:
            metadata (PropInput): A dictionary of properties to be added to the node. Each key is a string representing the property name, and each value is of type Prop representing the property value.

        Returns:
            None:
        """

class Edge(object):
    """
    PyEdge is a Python class that represents an edge in the graph.
    An edge is a directed connection between two nodes.
    """

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __hash__(self):
        """Return hash(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> Edge:
        """
         Create a view of the Edge including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             Edge:
        """

    def at(self, time: TimeInput) -> Edge:
        """
         Create a view of the Edge including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             Edge:
        """

    def before(self, end: TimeInput) -> Edge:
        """
         Create a view of the Edge including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             Edge:
        """

    def default_layer(self) -> Edge:
        """
         Return a view of Edge containing only the default edge layer
        Returns:
             Edge: The layered view
        """

    @property
    def deletions(self) -> History:
        """
        Returns a history object with EventTime entries for an edge's deletion times.

        Returns:
           History:  A history object containing time entries about the edge's deletions
        """

    @property
    def dst(self) -> Node:
        """
        Returns the destination node of the edge.

        Returns:
            Node:
        """

    @property
    def earliest_time(self) -> OptionalEventTime:
        """
        Gets the earliest time of an edge.

        Returns:
            OptionalEventTime: The earliest time of an edge
        """

    @property
    def end(self) -> OptionalEventTime:
        """
         Gets the latest time that this Edge is valid.

        Returns:
           OptionalEventTime: The latest time that this Edge is valid or None if the Edge is valid for all times.
        """

    def exclude_layer(self, name: str) -> Edge:
        """
         Return a view of Edge containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             Edge: The layered view
        """

    def exclude_layers(self, names: list[str]) -> Edge:
        """
         Return a view of Edge containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             Edge: The layered view
        """

    def exclude_valid_layer(self, name: str) -> Edge:
        """
         Return a view of Edge containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             Edge: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> Edge:
        """
         Return a view of Edge containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             Edge: The layered view
        """

    def expanding(
        self, step: int | str, alignment_unit: str | None = None
    ) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step. For example, if the step is "1 month and 1 day",
                the windows will be aligned on days (00:00:00 to 23:59:59).
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def explode(self) -> Edges:
        """
        Explodes returns an edge object for each update within the original edge.

        Returns:
            Edges:
        """

    def explode_layers(self) -> Edges:
        """
        Explode layers returns an edge object for each layer within the original edge. These new edge object contains only updates from respective layers.

        Returns:
            Edges:
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if Edge has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    @property
    def history(self) -> History:
        """
        Returns a history object with EventTime entries for when an edge is added or change to an edge is made.

        Returns:
           History:  A history object containing temporal entries about the edge
        """

    @property
    def id(self) -> GID:
        """
        The id of the edge.

        Returns:
            GID:
        """

    def is_active(self) -> bool:
        """
        Check if the edge is currently active (has at least one update within this period).
        Returns:
            bool:
        """

    def is_deleted(self) -> bool:
        """
        Check if the edge is currently deleted
        Returns:
            bool:
        """

    def is_self_loop(self) -> bool:
        """
        Check if the edge is on the same node
        Returns:
            bool:
        """

    def is_valid(self) -> bool:
        """
        Check if the edge is currently valid (i.e., not deleted)
        Returns:
            bool:
        """

    def latest(self) -> Edge:
        """
         Create a view of the Edge including all events at the latest time.

        Returns:
             Edge:
        """

    @property
    def latest_time(self) -> OptionalEventTime:
        """
        Gets the latest time of an edge.

        Returns:
            OptionalEventTime: The latest time of an edge
        """

    def layer(self, name: str) -> Edge:
        """
         Return a view of Edge containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             Edge: The layered view
        """

    @property
    def layer_name(self) -> str:
        """
        Gets the name of the layer this edge belongs to - assuming it only belongs to one layer.

        Returns:
            str: The name of the layer
        """

    @property
    def layer_names(self) -> List[str]:
        """
        Gets the names of the layers this edge belongs to.

        Returns:
            List[str]:  The name of the layer
        """

    def layers(self, names: list[str]) -> Edge:
        """
         Return a view of Edge containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             Edge: The layered view
        """

    @property
    def metadata(self) -> Metadata:
        """
        Gets the metadata of an edge

        Returns:
            Metadata:
        """

    @property
    def nbr(self) -> Nodes:
        """
        Returns the node at the other end of the edge (same as `dst()` for out-edges and `src()` for in-edges)

        Returns:
            Nodes:
        """

    @property
    def properties(self) -> Properties:
        """
        Returns a view of the properties of the edge.

        Returns:
          Properties: Properties on the Edge.
        """

    def rolling(
        self,
        window: int | str,
        step: int | str | None = None,
        alignment_unit: str | None = None,
    ) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.
        If `alignment_unit` is not "unaligned" and a `step` larger than `window` is provided, some time entries
        may appear before the start of the first window and/or after the end of the last window (i.e. not included in any window).

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step (or window if no step is passed).
                For example, if the step is "1 month and 1 day",
                the first window will begin at the start of the day of the first time event.
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> Edge:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             Edge:
        """

    def shrink_start(self, start: TimeInput) -> Edge:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             Edge:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> Edge:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             Edge:
        """

    def snapshot_at(self, time: TimeInput) -> Edge:
        """
         Create a view of the Edge including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             Edge:
        """

    def snapshot_latest(self) -> Edge:
        """
         Create a view of the Edge including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             Edge:
        """

    @property
    def src(self) -> Nodes:
        """
        Returns the source node of the edge.

        Returns:
            Nodes:
        """

    @property
    def start(self) -> OptionalEventTime:
        """
         Gets the start time for rolling and expanding windows for this Edge

        Returns:
            OptionalEventTime: The earliest time that this Edge is valid or None if the Edge is valid for all times.
        """

    @property
    def time(self) -> int:
        """
        Gets the time of an exploded edge.

        Returns:
            int: The time of an exploded edge
        """

    def valid_layers(self, names: list[str]) -> Edge:
        """
         Return a view of Edge containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             Edge: The layered view
        """

    def window(self, start: TimeInput, end: TimeInput) -> Edge:
        """
         Create a view of the Edge including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput): The start time of the window.
            end (TimeInput): The end time of the window.

        Returns:
            Edge:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this Edge.

        Returns:
            Optional[int]:
        """

class Edges(object):
    """A list of edges that can be iterated over."""

    def __bool__(self):
        """True if self else False"""

    def __getitem__(self, key):
        """Return self[key]."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> Edges:
        """
         Create a view of the Edges including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             Edges:
        """

    def at(self, time: TimeInput) -> Edges:
        """
         Create a view of the Edges including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             Edges:
        """

    def before(self, end: TimeInput) -> Edges:
        """
         Create a view of the Edges including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             Edges:
        """

    def collect(self) -> list[Edge]:
        """
         Collect all edges into a list

        Returns:
             list[Edge]: the list of edges
        """

    def count(self) -> int:
        """
        Returns the number of edges.

        Returns:
            int:
        """

    def default_layer(self) -> Edges:
        """
         Return a view of Edges containing only the default edge layer
        Returns:
             Edges: The layered view
        """

    @property
    def deletions(self):
        """
        Returns a history object for each edge containing their deletion times.

        Returns:
           HistoryIterable: An iterable of history objects, one for each edge.
        """

    @property
    def dst(self) -> Node:
        """
        Returns the destination node of the edge.

        Returns:
            Node:
        """

    @property
    def earliest_time(self):
        """
        Returns the earliest time of the edges.

        Returns:
            OptionEventTimeIterable: Iterable of `EventTime`s.
        """

    @property
    def end(self) -> OptionalEventTime:
        """
         Gets the latest time that this Edges is valid.

        Returns:
           OptionalEventTime: The latest time that this Edges is valid or None if the Edges is valid for all times.
        """

    def exclude_layer(self, name: str) -> Edges:
        """
         Return a view of Edges containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             Edges: The layered view
        """

    def exclude_layers(self, names: list[str]) -> Edges:
        """
         Return a view of Edges containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             Edges: The layered view
        """

    def exclude_valid_layer(self, name: str) -> Edges:
        """
         Return a view of Edges containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             Edges: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> Edges:
        """
         Return a view of Edges containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             Edges: The layered view
        """

    def expanding(
        self, step: int | str, alignment_unit: str | None = None
    ) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step. For example, if the step is "1 month and 1 day",
                the windows will be aligned on days (00:00:00 to 23:59:59).
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def explode(self) -> Edges:
        """
        Explodes returns an edge object for each update within the original edge.

        Returns:
            Edges:
        """

    def explode_layers(self) -> Edges:
        """
        Explode layers returns an edge object for each layer within the original edge. These new edge object contains only updates from respective layers.

        Returns:
            Edges:
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if Edges has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    @property
    def history(self):
        """
        Returns a history object for each edge containing time entries for when the edge is added or change to the edge is made.

        Returns:
           HistoryIterable: An iterable of history objects, one for each edge.
        """

    @property
    def id(self):
        """
        Returns all ids of the edges.

        Returns:
            GIDGIDIterable:
        """

    def is_active(self):
        """
        Check if the edges are active (there is at least one update during this time).

        Returns:
            BoolIterable:
        """

    def is_deleted(self):
        """
        Check if the edges are deleted.

        Returns:
            BoolIterable:
        """

    def is_self_loop(self):
        """
        Check if the edges are on the same node.

        Returns:
            BoolIterable:
        """

    def is_valid(self):
        """
        Check if the edges are valid (i.e. not deleted).

        Returns:
            BoolIterable:
        """

    def latest(self) -> Edges:
        """
         Create a view of the Edges including all events at the latest time.

        Returns:
             Edges:
        """

    @property
    def latest_time(self):
        """
        Returns the latest times of the edges.

        Returns:
            OptionEventTimeIterable: Iterable of `EventTime`s.
        """

    def layer(self, name: str) -> Edges:
        """
         Return a view of Edges containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             Edges: The layered view
        """

    @property
    def layer_name(self):
        """
        Get the layer name that all edges belong to - assuming they only belong to one layer

        Returns:
         ArcStringIterable:
        """

    @property
    def layer_names(self):
        """
        Get the layer names that all edges belong to - assuming they only belong to one layer.

        Returns:
          ArcStringVecIterable:
        """

    def layers(self, names: list[str]) -> Edges:
        """
         Return a view of Edges containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             Edges: The layered view
        """

    @property
    def metadata(self) -> MetadataView:
        """
        Returns all the metadata of the edges

        Returns:
            MetadataView:
        """

    @property
    def nbr(self) -> Nodes:
        """
        Returns the node at the other end of the edge (same as `dst()` for out-edges and `src()` for in-edges)

        Returns:
            Nodes:
        """

    @property
    def properties(self) -> PropertiesView:
        """
        Returns all properties of the edges

        Returns:
            PropertiesView:
        """

    def rolling(
        self,
        window: int | str,
        step: int | str | None = None,
        alignment_unit: str | None = None,
    ) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.
        If `alignment_unit` is not "unaligned" and a `step` larger than `window` is provided, some time entries
        may appear before the start of the first window and/or after the end of the last window (i.e. not included in any window).

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step (or window if no step is passed).
                For example, if the step is "1 month and 1 day",
                the first window will begin at the start of the day of the first time event.
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> Edges:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             Edges:
        """

    def shrink_start(self, start: TimeInput) -> Edges:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             Edges:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> Edges:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             Edges:
        """

    def snapshot_at(self, time: TimeInput) -> Edges:
        """
         Create a view of the Edges including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             Edges:
        """

    def snapshot_latest(self) -> Edges:
        """
         Create a view of the Edges including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             Edges:
        """

    @property
    def src(self) -> Nodes:
        """
        Returns the source node of the edge.

        Returns:
            Nodes:
        """

    @property
    def start(self) -> OptionalEventTime:
        """
         Gets the start time for rolling and expanding windows for this Edges

        Returns:
            OptionalEventTime: The earliest time that this Edges is valid or None if the Edges is valid for all times.
        """

    @property
    def time(self):
        """
        Returns the times of exploded edges

        Returns:
          EventTimeIterable: Iterable of `EventTime`s.
        """

    def to_df(
        self,
        include_property_history: bool = True,
        convert_datetime: bool = False,
        explode: bool = False,
    ) -> DataFrame:
        """
        Converts the graph's edges into a Pandas DataFrame.

        This method will create a DataFrame with the following columns:
        - "src": The source node of the edge.
        - "dst": The destination node of the edge.
        - "layer": The layer of the edge.
        - "properties": The properties of the edge.
        - "update_history": The update history of the edge. This column will be included if `include_update_history` is set to `true`.

        Args:
            include_property_history (bool): A boolean, if set to `True`, the history of each property is included, if `False`, only the latest value is shown. Ignored if exploded. Defaults to True.
            convert_datetime (bool): A boolean, if set to `True` will convert the timestamp to python datetimes. Defaults to False.
            explode (bool): A boolean, if set to `True`, will explode each edge update into its own row. Defaults to False.

        Returns:
            DataFrame: If successful, this PyObject will be a Pandas DataFrame.
        """

    def valid_layers(self, names: list[str]) -> Edges:
        """
         Return a view of Edges containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             Edges: The layered view
        """

    def window(self, start: TimeInput, end: TimeInput) -> Edges:
        """
         Create a view of the Edges including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput): The start time of the window.
            end (TimeInput): The end time of the window.

        Returns:
            Edges:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this Edges.

        Returns:
            Optional[int]:
        """

class NestedEdges(object):
    def __bool__(self):
        """True if self else False"""

    def __getitem__(self, key):
        """Return self[key]."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> NestedEdges:
        """
         Create a view of the NestedEdges including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             NestedEdges:
        """

    def at(self, time: TimeInput) -> NestedEdges:
        """
         Create a view of the NestedEdges including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             NestedEdges:
        """

    def before(self, end: TimeInput) -> NestedEdges:
        """
         Create a view of the NestedEdges including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             NestedEdges:
        """

    def collect(self) -> list[list[Edges]]:
        """
         Collect all edges into a list

        Returns:
             list[list[Edges]]: the list of edges
        """

    def default_layer(self) -> NestedEdges:
        """
         Return a view of NestedEdges containing only the default edge layer
        Returns:
             NestedEdges: The layered view
        """

    @property
    def deletions(self):
        """
        Returns a history object for each edge containing their deletion times.

        Returns:
            NestedHistoryIterable: A nested iterable of history objects, one for each edge.
        """

    @property
    def dst(self) -> Node:
        """
        Returns the destination node of the edge.

        Returns:
            Node:
        """

    @property
    def earliest_time(self):
        """
        Returns the earliest time of the edges.

        Returns:
            NestedOptionEventTimeIterable: A nested iterable of `EventTime`s.
        """

    @property
    def end(self) -> OptionalEventTime:
        """
         Gets the latest time that this NestedEdges is valid.

        Returns:
           OptionalEventTime: The latest time that this NestedEdges is valid or None if the NestedEdges is valid for all times.
        """

    def exclude_layer(self, name: str) -> NestedEdges:
        """
         Return a view of NestedEdges containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             NestedEdges: The layered view
        """

    def exclude_layers(self, names: list[str]) -> NestedEdges:
        """
         Return a view of NestedEdges containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             NestedEdges: The layered view
        """

    def exclude_valid_layer(self, name: str) -> NestedEdges:
        """
         Return a view of NestedEdges containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             NestedEdges: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> NestedEdges:
        """
         Return a view of NestedEdges containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             NestedEdges: The layered view
        """

    def expanding(
        self, step: int | str, alignment_unit: str | None = None
    ) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step. For example, if the step is "1 month and 1 day",
                the windows will be aligned on days (00:00:00 to 23:59:59).
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def explode(self) -> Edges:
        """
        Explodes returns an edge object for each update within the original edge.

        Returns:
            Edges:
        """

    def explode_layers(self) -> Edges:
        """
        Explode layers returns an edge object for each layer within the original edge. These new edge object contains only updates from respective layers.

        Returns:
            Edges:
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if NestedEdges has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    @property
    def history(self):
        """
        Returns a history object for each edge containing time entries for when the edge is added or change to the edge is made.

        Returns:
            NestedHistoryIterable: A nested iterable of history objects, one for each edge.
        """

    @property
    def id(self):
        """
        Returns all ids of the edges.

        Returns:
            NestedGIDGIDIterable:
        """

    def is_active(self):
        """
        Check if the edges are active (there is at least one update during this time).

        Returns:
            NestedBoolIterable:
        """

    def is_deleted(self):
        """
        Check if edges are deleted.

        Returns:
            NestedBoolIterable:
        """

    def is_self_loop(self):
        """
        Check if the edges are on the same node.

        Returns:
            NestedBoolIterable:
        """

    def is_valid(self):
        """
        Check if edges are valid (i.e., not deleted).

        Returns:
            NestedBoolIterable:
        """

    def latest(self) -> NestedEdges:
        """
         Create a view of the NestedEdges including all events at the latest time.

        Returns:
             NestedEdges:
        """

    @property
    def latest_time(self):
        """
        Returns the latest time of the edges.

        Returns:
            NestedOptionEventTimeIterable: A nested iterable of `EventTime`s.
        """

    def layer(self, name: str) -> NestedEdges:
        """
         Return a view of NestedEdges containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             NestedEdges: The layered view
        """

    @property
    def layer_name(self):
        """
        Returns the name of the layer the edges belong to - assuming they only belong to one layer.

        Returns:
            NestedArcStringIterable:
        """

    @property
    def layer_names(self):
        """
        Returns the names of the layers the edges belong to.

        Returns:
            NestedArcStringVecIterable:
        """

    def layers(self, names: list[str]) -> NestedEdges:
        """
         Return a view of NestedEdges containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             NestedEdges: The layered view
        """

    @property
    def metadata(self):
        """
        Get a view of the metadata only.

        Returns:
            MetadataListList:
        """

    @property
    def nbr(self) -> Nodes:
        """
        Returns the node at the other end of the edge (same as `dst()` for out-edges and `src()` for in-edges)

        Returns:
            Nodes:
        """

    @property
    def properties(self):
        """
        Returns all properties of the edges

        Returns:
            PyNestedPropsIterable:
        """

    def rolling(
        self,
        window: int | str,
        step: int | str | None = None,
        alignment_unit: str | None = None,
    ) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.
        If `alignment_unit` is not "unaligned" and a `step` larger than `window` is provided, some time entries
        may appear before the start of the first window and/or after the end of the last window (i.e. not included in any window).

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step (or window if no step is passed).
                For example, if the step is "1 month and 1 day",
                the first window will begin at the start of the day of the first time event.
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> NestedEdges:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             NestedEdges:
        """

    def shrink_start(self, start: TimeInput) -> NestedEdges:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             NestedEdges:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> NestedEdges:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             NestedEdges:
        """

    def snapshot_at(self, time: TimeInput) -> NestedEdges:
        """
         Create a view of the NestedEdges including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             NestedEdges:
        """

    def snapshot_latest(self) -> NestedEdges:
        """
         Create a view of the NestedEdges including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             NestedEdges:
        """

    @property
    def src(self) -> Nodes:
        """
        Returns the source node of the edge.

        Returns:
            Nodes:
        """

    @property
    def start(self) -> OptionalEventTime:
        """
         Gets the start time for rolling and expanding windows for this NestedEdges

        Returns:
            OptionalEventTime: The earliest time that this NestedEdges is valid or None if the NestedEdges is valid for all times.
        """

    @property
    def time(self):
        """
        Returns the times of exploded edges.

        Returns:
            NestedEventTimeIterable: A nested iterable of `EventTime`s.

        Raises:
            GraphError: If a graph error occurs (e.g. the edges are not exploded).
        """

    def valid_layers(self, names: list[str]) -> NestedEdges:
        """
         Return a view of NestedEdges containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             NestedEdges: The layered view
        """

    def window(self, start: TimeInput, end: TimeInput) -> NestedEdges:
        """
         Create a view of the NestedEdges including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput): The start time of the window.
            end (TimeInput): The end time of the window.

        Returns:
            NestedEdges:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this NestedEdges.

        Returns:
            Optional[int]:
        """

class MutableEdge(Edge):
    def __repr__(self):
        """Return repr(self)."""

    def add_metadata(self, metadata: PropInput, layer: Optional[str] = None) -> None:
        """
        Add metadata to an edge in the graph.
        This function is used to add properties to an edge that do not
        change over time. These properties are fundamental attributes of the edge.

        Arguments:
            metadata (PropInput): A dictionary of properties to be added to the edge.
            layer (str, optional): The layer you want these properties to be added on to.

        Returns:
            None:
        """

    def add_updates(
        self,
        t: TimeInput,
        properties: Optional[PropInput] = None,
        layer: Optional[str] = None,
        event_id: Optional[int] = None,
    ) -> None:
        """
        Add updates to an edge in the graph at a specified time.
        This function allows for the addition of property updates to an edge within the graph. The updates are time-stamped, meaning they are applied at the specified time.

        Arguments:
           t (TimeInput): The timestamp at which the updates should be applied.
           properties (PropInput, optional): A dictionary of properties to update.
           layer (str, optional): The layer you want these properties to be added on to.
           event_id (int, optional): The optional integer which will be used as an event id

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def delete(
        self, t: TimeInput, layer: Optional[str] = None, event_id: Optional[int] = None
    ) -> None:
        """
        Mark the edge as deleted at the specified time.

        Arguments:
            t (TimeInput): The timestamp at which the deletion should be applied.
            layer (str, optional): The layer you want the deletion applied to.
            event_id (int, optional): The event id for the deletion's time entry.

        Returns:
            None:

        Raises:
            GraphError: If the operation fails.
        """

    def update_metadata(self, metadata: PropInput, layer: Optional[str] = None) -> None:
        """
        Update metadata of an edge in the graph overwriting existing values.
        This function is used to add properties to an edge that does not
        change over time. These properties are fundamental attributes of the edge.

        Arguments:
            metadata (PropInput): A dictionary of properties to be added to the edge.
            layer (str, optional): The layer you want these properties to be added on to.

        Returns:
            None:
        """

class Properties(object):
    """A view of the properties of an entity"""

    def __contains__(self, key):
        """Return bool(key in self)."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def as_dict(self) -> dict[str, PropValue]:
        """
        Convert properties view to a dict.

        Returns:
            dict[str, PropValue]:
        """

    def get(self, key: str) -> PropValue:
        """
        Get property value.

        First searches temporal properties and returns latest value if it exists.
        If not, it falls back to static properties.

        Arguments:
            key (str): the name of the property.

        Returns:
            PropValue:
        """

    def get_dtype_of(self, key: str) -> PropType:
        """
        Get the PropType of a property. Specifically, returns the PropType of the latest value for this property if it exists.

        Arguments:
            key (str): the name of the property.

        Returns:
            PropType:
        """

    def items(self) -> list[Tuple[str, PropValue]]:
        """
        Get a list of key-value pairs

        Returns:
            list[Tuple[str, PropValue]]:
        """

    def keys(self) -> list[str]:
        """
        Get the names for all properties

        Returns:
            list[str]:
        """

    @property
    def temporal(self) -> TemporalProperties:
        """
        Get a view of the temporal properties only.

        Returns:
           TemporalProperties:
        """

    def values(self) -> list[PropValue]:
        """
        Get the values of the properties.

        Returns:
            list[PropValue]:
        """

class PyPropValueList(object):
    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def average(self) -> PropValue:
        """
        Compute the average of all property values. Alias for mean().

        Returns:
            PropValue: The average of each property values, or None if count is zero.
        """

    def collect(self): ...
    def count(self): ...
    def drop_none(self) -> list[PropValue]:
        """
        Drop none.

        Returns:
            list[PropValue]:
        """

    def max(self) -> PropValue:
        """
        Find the maximum property value and its associated time.

        Returns:
            PropValue:
        """

    def mean(self) -> PropValue:
        """
        Compute the mean of all property values.

        Returns:
            PropValue: The mean of each property values, or None if count is zero.
        """

    def median(self) -> PropValue:
        """
        Compute the median of all property values.

        Returns:
            PropValue:
        """

    def min(self) -> PropValue:
        """
        Min property value.

        Returns:
            PropValue:
        """

    def sum(self) -> PropValue:
        """
        Sum of property values.

        Returns:
            PropValue:
        """

class PropType(object):
    """
    PropType provides access to the types used by Raphtory. They can be used to specify the data type of different properties,
    which is especially useful if one wishes to cast some input column from one type to another during ingestion.
    PropType can be used to define the schema in the various load_* functions used for data ingestion
    (i.e. Graph.load_nodes(...)/Graph.load_edges(...) etc.)
    """

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __le__(self, value):
        """Return self<=value."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def __str__(self):
        """Return str(self)."""

    @staticmethod
    def array(p): ...
    @staticmethod
    def bool(): ...
    @staticmethod
    def datetime(): ...
    @staticmethod
    def f32(): ...
    @staticmethod
    def f64(): ...
    @staticmethod
    def i32(): ...
    @staticmethod
    def i64(): ...
    @staticmethod
    def list(p): ...
    @staticmethod
    def map(hash_map): ...
    @staticmethod
    def naive_datetime(): ...
    @staticmethod
    def str(): ...
    @staticmethod
    def u16(): ...
    @staticmethod
    def u32(): ...
    @staticmethod
    def u64(): ...
    @staticmethod
    def u8(): ...

class Metadata(object):
    """A view of metadata of an entity"""

    def __contains__(self, key):
        """Return bool(key in self)."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def as_dict(self) -> dict[str, PropValue]:
        """
        as_dict() -> dict[str, Any]

        Convert the properties view to a python dict

        Returns:
            dict[str, PropValue]:
        """

    def get(self, key: str) -> PropValue:
        """
        get property value by key

        Arguments:
            key (str): the name of the property

        Returns:
            PropValue: the property value or `None` if value for `key` does not exist
        """

    def items(self) -> list[Tuple[str, PropValue]]:
        """
        lists the property keys together with the corresponding value

        Returns:
            list[Tuple[str, PropValue]]: the property keys with corresponding values
        """

    def keys(self) -> list[str]:
        """
        lists the available property keys

        Returns:
            list[str]: the property keys
        """

    def values(self) -> list[PropValue]:
        """
        lists the property values

        Returns:
            list[PropValue]:
        """

class MetadataView(object):
    def __contains__(self, key):
        """Return bool(key in self)."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def as_dict(self): ...
    def get(self, key): ...
    def items(self): ...
    def keys(self): ...
    def values(self): ...

class TemporalProperties(object):
    """A view of the temporal properties of an entity"""

    def __contains__(self, key):
        """Return bool(key in self)."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def get(self, key: str) -> TemporalProperty:
        """
        Get property value for `key` if it exists.

        Arguments:
            key (str): the name of the property.

        Returns:
            TemporalProperty: the property view if it exists, otherwise `None`
        """

    def histories(self) -> dict[str, list[Tuple[EventTime, PropValue]]]:
        """
        Get the histories of all properties

        Returns:
            dict[str, list[Tuple[EventTime, PropValue]]]: the mapping of property keys to histories
        """

    def items(self) -> List[Tuple[str, TemporalProperty]]:
        """
        List the property keys together with the corresponding values

        Returns:
            List[Tuple[str, TemporalProperty]]:
        """

    def keys(self) -> list[str]:
        """
        List the available property keys.

        Returns:
            list[str]:
        """

    def latest(self) -> dict[str, PropValue]:
        """
        Get the latest value of all properties

        Returns:
            dict[str, PropValue]: the mapping of property keys to latest values
        """

    def values(self) -> list[TemporalProperty]:
        """
        List the values of the properties

        Returns:
            list[TemporalProperty]: the list of property views
        """

class PropertiesView(object):
    def __contains__(self, key):
        """Return bool(key in self)."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def as_dict(self) -> dict[str, List[PropValue]]:
        """
        Convert properties view to a dict.

        Returns:
            dict[str, List[PropValue]]:
        """

    def get(self, key: str) -> PyPropValueList:
        """
        Get property value.

        Arguments:
            key (str): the name of the property.

        Returns:
            PyPropValueList:
        """

    def items(self) -> list[Tuple[str, List[PropValue]]]:
        """
        Get a list of key-value pairs.

        Returns:
            list[Tuple[str, List[PropValue]]]:
        """

    def keys(self) -> list[str]:
        """
        Get the names for all properties.

        Returns:
            list[str]:
        """

    @property
    def temporal(self):
        """
        Get a view of the temporal properties only.

        Returns:
            List[TemporalProp]:
        """

    def values(self) -> list[list[PropValue]]:
        """
        Get the values of the properties.

        Returns:
            list[list[PropValue]]:
        """

class TemporalProperty(object):
    """A view of a temporal property"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def at(self, t: TimeInput) -> Optional[PropValue]:
        """
        Get the value of the property at a specified time.

        Arguments:
            t (TimeInput): time

        Returns:
            Optional[PropValue]:
        """

    def average(self) -> PropValue:
        """
        Compute the average of all property values. Alias for mean().

        Returns:
            PropValue: The average of each property values, or None if count is zero.
        """

    def count(self) -> int:
        """
        Count the number of properties.

        Returns:
            int: The number of properties.
        """

    @property
    def history(self) -> History:
        """
        Returns a history object which contains time entries for when the property was updated.

        Returns:
            History:
        """

    def items(self) -> List[Tuple[EventTime, PropValue]]:
        """
        List update times and corresponding property values.

        Returns:
            List[Tuple[EventTime, PropValue]]:
        """

    def max(self) -> Tuple[EventTime, PropValue]:
        """
        Find the maximum property value and its associated time.

        Returns:
            Tuple[EventTime, PropValue]: A tuple containing the time and the maximum property value.
        """

    def mean(self) -> PropValue:
        """
        Compute the mean of all property values. Alias for mean().

        Returns:
            PropValue: The mean of each property values, or None if count is zero.
        """

    def median(self) -> Tuple[EventTime, PropValue]:
        """
        Compute the median of all property values.

        Returns:
            Tuple[EventTime, PropValue]: A tuple containing the time and the median property value, or None if empty
        """

    def min(self) -> Tuple[EventTime, PropValue]:
        """
        Find the minimum property value and its associated time.

        Returns:
            Tuple[EventTime, PropValue]: A tuple containing the time and the minimum property value.
        """

    def ordered_dedupe(self, latest_time: bool) -> List[Tuple[EventTime, PropValue]]:
        """
        List of ordered deduplicated property values.

        Arguments:
            latest_time (bool): Enable to check the latest time only.

        Returns:
            List[Tuple[EventTime, PropValue]]:
        """

    def sum(self) -> PropValue:
        """
        Compute the sum of all property values.

        Returns:
            PropValue: The sum of all property values.
        """

    def unique(self) -> List[PropValue]:
        """
        List of unique property values.

        Returns:
            List[PropValue]:
        """

    def value(self) -> Optional[PropValue]:
        """
        Get the latest value of the property.

        Returns:
            Optional[PropValue]:
        """

    def values(self):
        """
        Get the property values for each update.

        Returns:
            NumpyArray:
        """

class EventTime(object):
    """
    Raphtorys EventTime.
    Represents a unique timepoint in the graphs history as (timestamp, event_id).

    - timestamp: Number of milliseconds since the Unix epoch.
    - event_id: ID used for ordering between equal timestamps.

    Unless specified manually, the event ids are generated automatically by Raphtory to
    maintain a unique ordering of events.
    EventTime can be converted into a timestamp or a Python datetime, and compared
    either by timestamp (against ints/floats/datetimes/strings), by tuple of (timestamp, event_id),
    or against another EventTime.
    """

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __hash__(self):
        """Return hash(self)."""

    def __int__(self):
        """int(self)"""

    def __le__(self, value):
        """Return self<=value."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __new__(cls, timestamp, event_id=None) -> EventTime:
        """Create and return a new object.  See help(type) for accurate signature."""

    def __repr__(self):
        """Return repr(self)."""

    @property
    def as_tuple(self) -> tuple[int, int]:
        """
        Return this entry as a tuple of (timestamp, event_id), where the timestamp is in milliseconds.

        Returns:
            tuple[int,int]: (timestamp, event_id).
        """

    @property
    def dt(self) -> datetime:
        """
        Returns the UTC datetime representation of this EventTime's timestamp.

        Returns:
            datetime: The UTC datetime.

        Raises:
            TimeError: Returns TimeError on timestamp conversion errors (e.g. out-of-range timestamp).
        """

    @property
    def event_id(self) -> int:
        """
        Returns the event id used to order events within the same timestamp.

        Returns:
            int: The event id.
        """

    @property
    def t(self) -> int:
        """
        Returns the timestamp in milliseconds since the Unix epoch.

        Returns:
            int: Milliseconds since the Unix epoch.
        """

class OptionalEventTime(object):
    """
    Raphtorys optional EventTime type. Instances of OptionalEventTime may contain an EventTime, or be empty.
    This is used for functions that may not return data (such as earliest_time and latest_time) because the data is unavailable.

    If data is contained, OptionalEventTime instances can be used similarly to EventTime.
    If empty, time operations (such as .t, .dt, .event_id) will return None.
    An empty OptionalEventTime is considered smaller than (<) any EventTime or OptionalEventTime with data.
    """

    def __bool__(self):
        """True if self else False"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __le__(self, value):
        """Return self<=value."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    @property
    def as_tuple(self):
        """
        Return this entry as a tuple of (timestamp, event_id), where the timestamp is in milliseconds if an EventTime is contained, or else None.

        Returns:
            tuple[int,int] | None: (timestamp, event_id).
        """

    @property
    def dt(self):
        """
        Returns the UTC datetime representation of this EventTime's timestamp if an EventTime is contained, or else None.

        Returns:
            datetime | None: The UTC datetime.

        Raises:
            TimeError: Returns TimeError on timestamp conversion errors (e.g. out-of-range timestamp).
        """

    @property
    def event_id(self):
        """
        Returns the event id used to order events within the same timestamp if an EventTime is contained, or else None.

        Returns:
            int | None: The event id.
        """

    def get_event_time(self):
        """
        Returns the contained EventTime if it exists, or else None.

        Returns:
            EventTime | None:
        """

    def is_none(self) -> bool:
        """
        Returns true if the OptionalEventTime doesn't contain an EventTime.

        Returns:
            bool:
        """

    def is_some(self) -> bool:
        """
        Returns true if the OptionalEventTime contains an EventTime.

        Returns:
            bool:
        """

    @property
    def t(self):
        """
        Returns the timestamp in milliseconds since the Unix epoch if an EventTime is contained, or else None.

        Returns:
            int | None: Milliseconds since the Unix epoch.
        """

class History(object):
    """History of updates for an object. Provides access to time entries and derived views such as timestamps, datetimes, event ids, and intervals."""

    def __contains__(self, key):
        """Return bool(key in self)."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def __reversed__(self) -> Iterator[EventTime]:
        """
        Iterate over all time entries in reverse chronological order.

        Returns:
            Iterator[EventTime]: Iterator over time entries in reverse order.
        """

    def collect(self) -> list[EventTime]:
        """
        Collect all time entries in chronological order.

        Returns:
            list[EventTime]: Collected time entries.
        """

    def collect_rev(self) -> list[EventTime]:
        """
        Collect all time entries in reverse chronological order.

        Returns:
            list[EventTime]: Collected time entries in reverse order.
        """

    @staticmethod
    def compose_histories(objects: Iterable[History]) -> History:
        """
        Compose multiple History objects into a single History by fusing their time entries in chronological order.

        Arguments:
            objects (Iterable[History]): History objects to compose.

        Returns:
            History: Composed History object containing entries from all inputs.
        """

    @property
    def dt(self) -> HistoryDateTime:
        """
        Access history events as UTC datetimes.

        Returns:
            HistoryDateTime: Datetime view of this history.
        """

    def earliest_time(self) -> OptionalEventTime:
        """
        Get the earliest time entry.

        Returns:
            OptionalEventTime: Earliest time entry, or None if empty.
        """

    @property
    def event_id(self) -> HistoryEventId:
        """
        Access the unique event id of each time entry.

        Returns:
            HistoryEventId: Event id view of this history.
        """

    @property
    def intervals(self) -> Intervals:
        """
        Access the intervals between consecutive timestamps in milliseconds.

        Returns:
            Intervals: Intervals view of this history.
        """

    def is_empty(self) -> bool:
        """
        Check whether the history has no entries.

        Returns:
            bool: True if empty, otherwise False.
        """

    def latest_time(self) -> OptionalEventTime:
        """
        Get the latest time entry.

        Returns:
            OptionalEventTime: Latest time entry, or None if empty.
        """

    def merge(self, other: History) -> History:
        """
        Merge this History with another by interleaving entries in time order.

        Arguments:
            other (History): Right-hand history to merge.

        Returns:
            History: Merged history containing entries from both inputs.
        """

    def reverse(self) -> History:
        """
        Return a History where iteration order is reversed.

        Returns:
            History: History that yields items in reverse chronological order.
        """

    @property
    def t(self) -> HistoryTimestamp:
        """
        Access history events as timestamps (milliseconds since Unix the epoch).

        Returns:
            HistoryTimestamp: Timestamp (as int) view of this history.
        """

class HistoryTimestamp(object):
    """History view that exposes timestamps in milliseconds since the Unix epoch."""

    def __contains__(self, key):
        """Return bool(key in self)."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def __reversed__(self) -> Iterator[int]:
        """
        Iterate over all timestamps in reverse order.

        Returns:
            Iterator[int]: Iterator over timestamps (milliseconds since the Unix epoch) in reverse order.
        """

    def collect(self) -> NDArray[np.int64]:
        """
        Collect all timestamps into a NumPy ndarray.

        Returns:
            NDArray[np.int64]: Timestamps in milliseconds since the Unix epoch.
        """

    def collect_rev(self) -> NDArray[np.int64]:
        """
        Collect all timestamps into a NumPy ndarray in reverse order.

        Returns:
            NDArray[np.int64]: Timestamps in milliseconds since the Unix epoch in reverse order.
        """

    def to_list(self) -> list[int]:
        """
        Collect all timestamps into a list.

        Returns:
            list[int]: List of timestamps.
        """

    def to_list_rev(self) -> list[int]:
        """
        Collect all timestamps into a list in reverse order.

        Returns:
            list[int]: List of timestamps.
        """

class HistoryDateTime(object):
    """History view that exposes UTC datetimes."""

    def __contains__(self, key):
        """Return bool(key in self)."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def __reversed__(self) -> Iterator[datetime]:
        """
        Iterate over all datetimes in reverse order.

        Returns:
            Iterator[datetime]: Iterator over UTC datetimes in reverse order.

        Raises:
            TimeError: May be raised during iteration if a timestamp cannot be converted.
        """

    def collect(self) -> list[datetime]:
        """
        Collect all datetimes.

        Returns:
            list[datetime]: Collected UTC datetimes.

        Raises:
            TimeError: If a timestamp cannot be converted to a datetime.
        """

    def collect_rev(self) -> list[datetime]:
        """
        Collect all datetimes in reverse order.

        Returns:
            list[datetime]: Collected UTC datetimes in reverse order.

        Raises:
            TimeError: If a timestamp cannot be converted to a datetime.
        """

class HistoryEventId(object):
    """History view that exposes event ids of time entries. They are used for ordering within the same timestamp."""

    def __contains__(self, key):
        """Return bool(key in self)."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def __reversed__(self) -> Iterator[int]:
        """
        Iterate over all event ids in reverse order.

        Returns:
            Iterator[int]: Iterator over event ids in reverse order.
        """

    def collect(self) -> NDArray[np.uintp]:
        """
        Collect all event ids.

        Returns:
            NDArray[np.uintp]: Event ids.
        """

    def collect_rev(self) -> NDArray[np.uintp]:
        """
        Collect all event ids in reverse order.

        Returns:
            NDArray[np.uintp]: Event ids in reverse order.
        """

    def to_list(self) -> list[int]:
        """
        Collect all event ids into a list.

        Returns:
            list[int]: List of event ids.
        """

    def to_list_rev(self) -> list[int]:
        """
        Collect all event ids into a list in reverse order.

        Returns:
            list[int]: List of event ids.
        """

class Intervals(object):
    """View over the intervals between consecutive timestamps, expressed in milliseconds."""

    def __contains__(self, key):
        """Return bool(key in self)."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def __reversed__(self) -> Iterator[int]:
        """
        Iterate over all intervals in reverse order.

        Returns:
            Iterator[int]: Iterator over intervals in reverse order.
        """

    def collect(self) -> NDArray[np.int64]:
        """
        Collect all interval values in milliseconds.

        Returns:
            NDArray[np.int64]: NumPy NDArray of interval values in milliseconds.
        """

    def collect_rev(self) -> NDArray[np.int64]:
        """
        Collect all interval values in reverse order.

        Returns:
            NDArray[np.int64]: Intervals in reverse order.
        """

    def max(self) -> Optional[int]:
        """
        Calculate the maximum interval in milliseconds.

        Returns:
            Optional[int]: Maximum interval, or None if fewer than 1 interval.
        """

    def mean(self) -> Optional[float]:
        """
        Calculate the mean interval in milliseconds.

        Returns:
            Optional[float]: Mean interval, or None if fewer than 1 interval.
        """

    def median(self) -> Optional[int]:
        """
        Calculate the median interval in milliseconds.

        Returns:
            Optional[int]: Median interval, or None if fewer than 1 interval.
        """

    def min(self) -> Optional[int]:
        """
        Calculate the minimum interval in milliseconds.

        Returns:
            Optional[int]: Minimum interval, or None if fewer than 1 interval.
        """

    def to_list(self) -> list[int]:
        """
        Collect all interval values in milliseconds into a list.

        Returns:
            list[int]: List of intervals in milliseconds.
        """

    def to_list_rev(self) -> list[int]:
        """
        Collect all interval values in milliseconds into a list in reverse order.

        Returns:
            list[int]: List of intervals in milliseconds.
        """

class WindowSet(object):
    def __iter__(self):
        """Implement iter(self)."""

    def time_index(self, center: bool = False) -> Iterable:
        """
        Returns the time index of this window set.

        It uses the last time of each window as the reference or the center of each if `center` is
        set to `True`.

        Arguments:
            center (bool): If True time indexes are centered. Defaults to False.

        Returns:
            Iterable: The time index.
        """

class IndexSpecBuilder(object):
    def __new__(cls, graph) -> IndexSpecBuilder:
        """Create and return a new object.  See help(type) for accurate signature."""

    def build(self) -> IndexSpec:
        """
        Return a spec

        Returns:
            IndexSpec:
        """

    def with_all_edge_metadata(self) -> dict[str, Any]:
        """
        Adds all edge metadata to the spec.

        Returns:
            dict[str, Any]:
        """

    def with_all_edge_properties(self) -> dict[str, Any]:
        """
        Adds all edge properties to the spec.

        Returns:
            dict[str, Any]:
        """

    def with_all_edge_properties_and_metadata(self) -> dict[str, Any]:
        """
        Adds all edge properties and metadata to the spec.

        Returns:
            dict[str, Any]:
        """

    def with_all_node_metadata(self) -> dict[str, Any]:
        """
        Adds all node metadata to the spec.

        Returns:
            dict[str, Any]:
        """

    def with_all_node_properties(self) -> dict[str, Any]:
        """
        Adds all node properties to the spec.

        Returns:
            dict[str, Any]:
        """

    def with_all_node_properties_and_metadata(self) -> dict[str, Any]:
        """
        Adds all node properties and metadata to the spec.

        Returns:
            dict[str, Any]:
        """

    def with_edge_metadata(self, props: Any) -> dict[str, Any]:
        """
        Adds specified edge metadata to the spec.

        Arguments:
            props: List of metadata.

        Returns:
            dict[str, Any]:
        """

    def with_edge_properties(self, props: Any) -> dict[str, Any]:
        """
        Adds specified edge properties to the spec.

        Arguments:
            props: List of properties.

        Returns:
            dict[str, Any]:
        """

    def with_node_metadata(self, props: Any) -> dict[str, Any]:
        """
        Adds specified node metadata to the spec.

        Arguments:
            props: list of metadata.

        Returns:
            dict[str, Any]:
        """

    def with_node_properties(self, props: Any) -> dict[str, Any]:
        """
        Adds specified node properties to the spec.

        Arguments:
            props: list of properties.

        Returns:
            dict[str, Any]:
        """

class IndexSpec(object):
    def __repr__(self):
        """Return repr(self)."""

    @property
    def edge_metadata(self) -> list[str]:
        """
        Get edge metadata.

        Returns:
            list[str]:
        """

    @property
    def edge_properties(self) -> list[str]:
        """
        Get edge properties.

        Returns:
            list[str]:
        """

    @property
    def node_metadata(self) -> list[str]:
        """
        Get node metadata.

        Returns:
            list[str]:
        """

    @property
    def node_properties(self) -> list[str]:
        """
        Get node properties.

        Returns:
            list[str]:
        """

class Prop(object):
    def __repr__(self):
        """Return repr(self)."""

    @staticmethod
    def bool(value): ...
    def dtype(self): ...
    @staticmethod
    def f32(value): ...
    @staticmethod
    def f64(value): ...
    @staticmethod
    def i32(value): ...
    @staticmethod
    def i64(value): ...
    @staticmethod
    def list(values): ...
    @staticmethod
    def map(dict): ...
    @staticmethod
    def str(value): ...
    @staticmethod
    def u16(value): ...
    @staticmethod
    def u32(value): ...
    @staticmethod
    def u64(value): ...
    @staticmethod
    def u8(value): ...

def version() -> str:
    """
    Return Raphtory version.

    Returns:
        str:
    """
