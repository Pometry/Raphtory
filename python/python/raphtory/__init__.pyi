"""
Raphtory graph analytics library
"""
from __future__ import annotations

###############################################################################
#                                                                             #
#                      AUTOGENERATED TYPE STUB FILE                           #
#                                                                             #
#    This file was automatically generated. Do not modify it directly.        #
#    Any changes made here may be lost when the file is regenerated.          #
#                                                                             #
###############################################################################

from typing import *
import raphtory.filter as filter
from raphtory.algorithms import *
from raphtory.vectors import *
from raphtory.node_state import *
from raphtory.graphql import *
from raphtory.typing import *
from datetime import datetime
from pandas import DataFrame
from os import PathLike
import networkx as nx  # type: ignore
import pyvis  # type: ignore

__all__ = ['GraphView', 'Graph', 'PersistentGraph', 'Node', 'Nodes', 'PathFromNode', 'PathFromGraph', 'MutableNode', 'Edge', 'Edges', 'NestedEdges', 'MutableEdge', 'Properties', 'Metadata', 'TemporalProperties', 'PropertiesView', 'TemporalProp', 'WindowSet', 'IndexSpecBuilder', 'IndexSpec', 'version', 'graphql', 'algorithms', 'graph_loader', 'graph_gen', 'vectors', 'node_state', 'filter', 'nullmodels', 'plottingutils']
class GraphView(object): 
    """Graph view is a read-only version of a graph at a certain point in time."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __le__(self, value):
        """Return self<=value."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> GraphView:
        """
         Create a view of the GraphView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             GraphView:
        """

    def at(self, time: TimeInput) -> GraphView:
        """
         Create a view of the GraphView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             GraphView:
        """

    def before(self, end: TimeInput) -> GraphView:
        """
         Create a view of the GraphView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             GraphView:
        """

    def cache_view(self) -> GraphView:
        """
        Applies the filters to the graph and retains the node ids and the edge ids
        in the graph that satisfy the filters
        creates bitsets per layer for nodes and edges

        Returns:
          GraphView: Returns the masked graph
        """

    def count_edges(self) -> int:
        """
        Number of edges in the graph

        Returns:
           int: the number of edges in the graph
        """

    def count_nodes(self) -> int:
        """
        Number of nodes in the graph

        Returns:
          int: the number of nodes in the graph
        """

    def count_temporal_edges(self) -> int:
        """
        Number of edges in the graph

        Returns:
           int: the number of temporal edges in the graph
        """

    def default_layer(self) -> GraphView:
        """
         Return a view of GraphView containing only the default edge layer
        Returns:
             GraphView: The layered view
        """

    @property
    def earliest_date_time(self) -> Optional[datetime]:
        """
        DateTime of earliest activity in the graph

        Returns:
            Optional[datetime]: the datetime of the earliest activity in the graph
        """

    @property
    def earliest_time(self) -> Optional[int]:
        """
        Timestamp of earliest activity in the graph

        Returns:
            Optional[int]: the timestamp of the earliest activity in the graph
        """

    def edge(self, src: NodeInput, dst: NodeInput) -> Optional[Edge]:
        """
        Gets the edge with the specified source and destination nodes

        Arguments:
            src (NodeInput): the source node id
            dst (NodeInput): the destination node id

        Returns:
            Optional[Edge]: the edge with the specified source and destination nodes, or None if the edge does not exist
        """

    @property
    def edges(self) -> Edges:
        """
        Gets all edges in the graph

        Returns:
          Edges: the edges in the graph
        """

    @property
    def end(self) -> Optional[int]:
        """
         Gets the latest time that this GraphView is valid.

        Returns:
           Optional[int]: The latest time that this GraphView is valid or None if the GraphView is valid for all times.
        """

    @property
    def end_date_time(self) -> Optional[datetime]:
        """
         Gets the latest datetime that this GraphView is valid

        Returns:
             Optional[datetime]: The latest datetime that this GraphView is valid or None if the GraphView is valid for all times.
        """

    def exclude_layer(self, name: str) -> GraphView:
        """
         Return a view of GraphView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             GraphView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> GraphView:
        """
         Return a view of GraphView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             GraphView: The layered view
        """

    def exclude_nodes(self, nodes: list[NodeInput]) -> GraphView:
        """
        Returns a subgraph given a set of nodes that are excluded from the subgraph

        Arguments:
          nodes (list[NodeInput]): set of nodes

        Returns:
           GraphView: Returns the subgraph
        """

    def exclude_valid_layer(self, name: str) -> GraphView:
        """
         Return a view of GraphView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             GraphView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> GraphView:
        """
         Return a view of GraphView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             GraphView: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def filter_edges(self, filter: filter.FilterExpr) -> GraphView:
        """
        Return a filtered view that only includes edges that satisfy the filter

        Arguments:
            filter (filter.FilterExpr): The filter to apply to the edges.

        Returns:
            GraphView: The filtered view
        """

    def filter_exploded_edges(self, filter: filter.FilterExpr) -> GraphView:
        """
        Return a filtered view that only includes exploded edges that satisfy the filter

        Arguments:
            filter (filter.FilterExpr): The filter to apply to the exploded edge properties.

        Returns:
            GraphView: The filtered view
        """

    def filter_nodes(self, filter: filter.FilterExpr) -> GraphView:
        """
        Return a filtered view that only includes nodes that satisfy the filter

        Arguments:
            filter (filter.FilterExpr): The filter to apply to the nodes.

        Returns:
            GraphView: The filtered view
        """

    def find_edges(self, properties_dict: dict[str, PropValue]) -> list[Edge]:
        """
        Get the edges that match the properties name and value
        Arguments:
            properties_dict (dict[str, PropValue]): the properties name and value
        Returns:
           list[Edge]: the edges that match the properties name and value
        """

    def find_nodes(self, properties_dict: dict[str, PropValue]) -> list[Node]:
        """
        Get the nodes that match the properties name and value
        Arguments:
            properties_dict (dict[str, PropValue]): the properties name and value
        Returns:
           list[Node]: the nodes that match the properties name and value
        """

    def get_index_spec(self):
        """Get index spec"""

    def has_edge(self, src: NodeInput, dst: NodeInput) -> bool:
        """
        Returns true if the graph contains the specified edge

        Arguments:
          src (NodeInput): the source node id
          dst (NodeInput): the destination node id

        Returns:
            bool: true if the graph contains the specified edge, false otherwise
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if GraphView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def has_node(self, id: NodeInput) -> bool:
        """
        Returns true if the graph contains the specified node

        Arguments:
           id (NodeInput): the node id

        Returns:
          bool: true if the graph contains the specified node, false otherwise
        """

    def latest(self) -> GraphView:
        """
         Create a view of the GraphView including all events at the latest time.

        Returns:
             GraphView:
        """

    @property
    def latest_date_time(self) -> Optional[datetime]:
        """
        DateTime of latest activity in the graph

        Returns:
            Optional[datetime]: the datetime of the latest activity in the graph
        """

    @property
    def latest_time(self) -> Optional[int]:
        """
        Timestamp of latest activity in the graph

        Returns:
            Optional[int]: the timestamp of the latest activity in the graph
        """

    def layer(self, name: str) -> GraphView:
        """
         Return a view of GraphView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             GraphView: The layered view
        """

    def layers(self, names: list[str]) -> GraphView:
        """
         Return a view of GraphView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             GraphView: The layered view
        """

    def materialize(self) -> GraphView:
        """
        Returns a 'materialized' clone of the graph view - i.e. a new graph with a copy of the data seen within the view instead of just a mask over the original graph

        Returns:
           GraphView: Returns a graph clone
        """

    @property
    def metadata(self) -> Metadata:
        """
        Get all graph metadata


        Returns:
            Metadata:
        """

    def node(self, id: NodeInput) -> Optional[Node]:
        """
        Gets the node with the specified id

        Arguments:
          id (NodeInput): the node id

        Returns:
            Optional[Node]: the node with the specified id, or None if the node does not exist
        """

    @property
    def nodes(self) -> Nodes:
        """
        Gets the nodes in the graph

        Returns:
          Nodes: the nodes in the graph
        """

    @property
    def properties(self) -> Properties:
        """
        Get all graph properties


        Returns:
            Properties: Properties paired with their names
        """

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def search_edges(self, filter: Any, limit: int = 25, offset: int = 0) -> list[Edge]:
        """
        Searches for edges which match the given filter expression. This uses Tantivy's exact search.

        Arguments:
           filter: The filter expression to search for.
           limit(int): The maximum number of results to return. Defaults to 25.
           offset(int): The number of results to skip. This is useful for pagination. Defaults to 0.

        Returns:
           list[Edge]: A list of edges which match the filter expression. The list will be empty if no edges match the query.
        """

    def search_nodes(self, filter: Any, limit: int = 25, offset: int = 0) -> list[Node]:
        """
        Searches for nodes which match the given filter expression. This uses Tantivy's exact search.

        Arguments:
           filter: The filter expression to search for.
           limit(int): The maximum number of results to return. Defaults to 25.
           offset(int): The number of results to skip. This is useful for pagination. Defaults to 0.

        Returns:
           list[Node]: A list of nodes which match the filter expression. The list will be empty if no nodes match.
        """

    def shrink_end(self, end: TimeInput) -> GraphView:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             GraphView:
        """

    def shrink_start(self, start: TimeInput) -> GraphView:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             GraphView:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> GraphView:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             GraphView:
        """

    def snapshot_at(self, time: TimeInput) -> GraphView:
        """
         Create a view of the GraphView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             GraphView:
        """

    def snapshot_latest(self) -> GraphView:
        """
         Create a view of the GraphView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             GraphView:
        """

    @property
    def start(self) -> Optional[int]:
        """
         Gets the start time for rolling and expanding windows for this GraphView

        Returns:
            Optional[int]: The earliest time that this GraphView is valid or None if the GraphView is valid for all times.
        """

    @property
    def start_date_time(self) -> Optional[datetime]:
        """
         Gets the earliest datetime that this GraphView is valid

        Returns:
             Optional[datetime]: The earliest datetime that this GraphView is valid or None if the GraphView is valid for all times.
        """

    def subgraph(self, nodes: list[NodeInput]) -> GraphView:
        """
        Returns a subgraph given a set of nodes

        Arguments:
          nodes (list[NodeInput]): set of nodes

        Returns:
           GraphView: Returns the subgraph
        """

    def subgraph_node_types(self, node_types: list[str]) -> GraphView:
        """
        Returns a subgraph filtered by node types given a set of node types

        Arguments:
          node_types (list[str]): set of node types

        Returns:
           GraphView: Returns the subgraph
        """

    def to_networkx(self, explode_edges: bool = False, include_node_properties: bool = True, include_edge_properties: bool = True, include_update_history: bool = True, include_property_history: bool = True) -> nx.MultiDiGraph:
        """
        Returns a graph with NetworkX.

            Network X is a required dependency.
            If you intend to use this function make sure that
            you install Network X with ``pip install networkx``

            Args:
                explode_edges (bool): A boolean that is set to True if you want to explode the edges in the graph. Defaults to False.
                include_node_properties (bool): A boolean that is set to True if you want to include the node properties in the graph. Defaults to True.
                include_edge_properties (bool): A boolean that is set to True if you want to include the edge properties in the graph. Defaults to True.
                include_update_history (bool): A boolean that is set to True if you want to include the update histories in the graph. Defaults to True.
                include_property_history (bool): A boolean that is set to True if you want to include the histories in the graph. Defaults to True.

            Returns:
                nx.MultiDiGraph: A Networkx MultiDiGraph.
        """

    def to_pyvis(self, explode_edges: bool = False, edge_color: str = '#000000', shape: str = 'dot', node_image: Optional[str] = None, edge_weight: Optional[str] = None, edge_label: Optional[str] = None, colour_nodes_by_type: bool = False, directed: bool = True, notebook: bool = False, **kwargs: Any) -> pyvis.network.Network:
        """
        Draw a graph with PyVis.
        Pyvis is a required dependency. If you intend to use this function make sure that you install Pyvis
        with ``pip install pyvis``

        Args:
            explode_edges (bool): A boolean that is set to True if you want to explode the edges in the graph. Defaults to False.
            edge_color (str): A string defining the colour of the edges in the graph. Defaults to "#000000".
            shape (str): A string defining what the node looks like. Defaults to "dot".
                    There are two types of nodes. One type has the label inside of it and the other type has the label underneath it.
                    The types with the label inside of it are: ellipse, circle, database, box, text.
                    The ones with the label outside of it are: image, circularImage, diamond, dot, star, triangle, triangleDown, square and icon.
            node_image (str, optional): An optional node property used as the url of a custom node image. Use together with `shape="image"`.
            edge_weight (str, optional): An optional string defining the name of the property where edge weight is set on your Raphtory graph.
                If provided, the default weight for edges that are missing the property is 1.0.
            edge_label (str, optional): An optional string defining the name of the property where edge label is set on your Raphtory graph. By default, the edge layer is used as the label.
            colour_nodes_by_type (bool): If True, nodes with different types have different colours. Defaults to False.
            directed (bool): Visualise the graph as directed. Defaults to True.
            notebook (bool): A boolean that is set to True if using jupyter notebook. Defaults to False.
            kwargs: Additional keyword arguments that are passed to the pyvis Network class.

        Returns:
            pyvis.network.Network: A pyvis network
        """

    @property
    def unique_layers(self) -> list[str]:
        """
        Return all the layer ids in the graph

        Returns:
            list[str]: the names of all layers in the graph
        """

    def valid(self) -> GraphView:
        """
        Return a view of the graph that only includes valid edges

        Note:

            The semantics for `valid` depend on the time semantics of the underlying graph.
            In the case of a persistent graph, an edge is valid if its last update is an addition.
            In the case of an event graph, an edge is valid if it has at least one addition event.

        Returns:
            GraphView: The filtered graph
        """

    def valid_layers(self, names: list[str]) -> GraphView:
        """
         Return a view of GraphView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             GraphView: The layered view
        """

    def vectorise(self, embedding: Callable[[list], list], nodes: bool | str = True, edges: bool | str = True, cache: Optional[str] = None, verbose: bool = False) -> VectorisedGraph:
        """
        Create a VectorisedGraph from the current graph

        Args:
          embedding (Callable[[list], list]): the embedding function to translate documents to embeddings
          nodes (bool | str): if nodes have to be embedded or not or the custom template to use if a str is provided. Defaults to True.
          edges (bool | str): if edges have to be embedded or not or the custom template to use if a str is provided. Defaults to True.
          cache (str, optional): the path to use to store the cache for embeddings.
          verbose (bool): whether or not to print logs reporting the progress. Defaults to False.

        Returns:
          VectorisedGraph: A VectorisedGraph with all the documents/embeddings computed and with an initial empty selection
        """

    def window(self, start: TimeInput | None, end: TimeInput | None) -> GraphView:
        """
         Create a view of the GraphView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
            GraphView:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this GraphView

        Returns:
            Optional[int]:
        """

class Graph(GraphView): 
    """
    A temporal graph with event semantics.

    Arguments:
        num_shards (int, optional): The number of locks to use in the storage to allow for multithreaded updates.
    """

    def __new__(cls, num_shards: Optional[int] = None) -> Graph:
        """Create and return a new object.  See help(type) for accurate signature."""

    def __reduce__(self):
        ...

    def add_edge(self, timestamp: TimeInput, src: str|int, dst: str|int, properties: Optional[PropInput] = None, layer: Optional[str] = None, secondary_index: Optional[int] = None) -> MutableEdge:
        """
        Adds a new edge with the given source and destination nodes and properties to the graph.

        Arguments:
           timestamp (TimeInput): The timestamp of the edge.
           src (str|int): The id of the source node.
           dst (str|int): The id of the destination node.
           properties (PropInput, optional): The properties of the edge, as a dict of string and properties.
           layer (str, optional): The layer of the edge.
           secondary_index (int, optional): The optional integer which will be used as a secondary index

        Returns:
            MutableEdge: The added edge.

        Raises:
            GraphError: If the operation fails.
        """

    def add_metadata(self, metadata: PropInput) -> None:
        """
        Adds static properties to the graph.

        Arguments:
            metadata (PropInput): The static properties of the graph.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def add_node(self, timestamp: TimeInput, id: str|int, properties: Optional[PropInput] = None, node_type: Optional[str] = None, secondary_index: Optional[int] = None) -> MutableNode:
        """
        Adds a new node with the given id and properties to the graph.

        Arguments:
           timestamp (TimeInput): The timestamp of the node.
           id (str|int): The id of the node.
           properties (PropInput, optional): The properties of the node.
           node_type (str, optional): The optional string which will be used as a node type
           secondary_index (int, optional): The optional integer which will be used as a secondary index

        Returns:
            MutableNode: The added node.

        Raises:
            GraphError: If the operation fails.
        """

    def add_properties(self, timestamp: TimeInput, properties: PropInput, secondary_index: Optional[int] = None) -> None:
        """
        Adds properties to the graph.

        Arguments:
           timestamp (TimeInput): The timestamp of the temporal property.
           properties (PropInput): The temporal properties of the graph.
           secondary_index (int, optional): The optional integer which will be used as a secondary index

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def cache(self, path: str) -> None:
        """
         Write Graph to cache file and initialise the cache.

        Future updates are tracked. Use `write_updates` to persist them to the
        cache file. If the file already exists its contents are overwritten.

        Arguments:
            path (str): The path to the cache file

        Returns:
            None:
        """

    def create_index(self):
        """Create graph index"""

    def create_index_in_ram(self):
        """
        Creates a graph index in memory (RAM).

        This is primarily intended for use in tests and should not be used in production environments,
        as the index will not be persisted to disk.
        """

    def create_index_in_ram_with_spec(self, py_spec):
        """
        Creates a graph index in memory (RAM) with the provided index spec.

        This is primarily intended for use in tests and should not be used in production environments,
        as the index will not be persisted to disk.
        """

    def create_index_with_spec(self, py_spec):
        """Create graph index with the provided index spec."""

    def create_node(self, timestamp: TimeInput, id: str|int, properties: Optional[PropInput] = None, node_type: Optional[str] = None, secondary_index: Optional[int] = None) -> MutableNode:
        """
        Creates a new node with the given id and properties to the graph. It fails if the node already exists.

        Arguments:
           timestamp (TimeInput): The timestamp of the node.
           id (str|int): The id of the node.
           properties (PropInput, optional): The properties of the node.
           node_type (str, optional): The optional string which will be used as a node type
           secondary_index (int, optional): The optional integer which will be used as a secondary index

        Returns:
            MutableNode: The created node.

        Raises:
            GraphError: If the operation fails.
        """

    @staticmethod
    def deserialise(bytes: bytes) -> Graph:
        """
         Load Graph from serialised bytes.

        Arguments:
            bytes (bytes): The serialised bytes to decode

        Returns:
           Graph:
        """

    def edge(self, src: str|int, dst: str|int) -> MutableEdge:
        """
        Gets the edge with the specified source and destination nodes

        Arguments:
            src (str|int): the source node id
            dst (str|int): the destination node id

        Returns:
            MutableEdge: the edge with the specified source and destination nodes, or None if the edge does not exist
        """

    def event_graph(self) -> Graph:
        """
        View graph with event semantics

        Returns:
            Graph: the graph with event semantics applied
        """

    @staticmethod
    def from_parquet(graph_dir: str | PathLike) -> Graph:
        """
        Read graph from parquet files

        Arguments:
           graph_dir (str | PathLike): the folder where the graph is stored as parquet

        Returns:
          Graph: a view of the graph

        """

    def get_all_node_types(self) -> List[str]:
        """
        Returns all the node types in the graph.

        Returns:
            List[str]: the node types
        """

    def import_edge(self, edge: Edge, merge: bool = False) -> MutableEdge:
        """
        Import a single edge into the graph.

        Arguments:
            edge (Edge): A Edge object representing the edge to be imported.
            merge (bool): An optional boolean flag. Defaults to False.
                          If merge is False, the function will return an error if the imported edge already exists in the graph.
                          If merge is True, the function merges the histories of the imported edge and the existing edge (in the graph).

        Returns:
            MutableEdge: An Edge object if the edge was successfully imported.

        Raises:
            GraphError: If the operation fails.
        """

    def import_edge_as(self, edge: Edge, new_id: tuple, merge: bool = False) -> Edge:
        """
        Import a single edge into the graph with new id.

        Arguments:
            edge (Edge): A Edge object representing the edge to be imported.
            new_id (tuple) : The ID of the new edge. It's a tuple of the source and destination node ids.
            merge (bool): An optional boolean flag. Defaults to False.
                          If merge is False, the function will return an error if the imported edge already exists in the graph.
                          If merge is True, the function merges the histories of the imported edge and the existing edge (in the graph).

        Returns:
            Edge: An Edge object if the edge was successfully imported.

        Raises:
            GraphError: If the operation fails.
        """

    def import_edges(self, edges: List[Edge], merge: bool = False) -> None:
        """
        Import multiple edges into the graph.

        Arguments:
            edges (List[Edge]): A list of Edge objects representing the edges to be imported.
            merge (bool): An optional boolean flag. Defaults to False.
                          If merge is False, the function will return an error if any of the imported edges already exists in the graph.
                          If merge is True, the function merges the histories of the imported edges and the existing edges (in the graph).

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def import_edges_as(self, edges: List[Edge], new_ids: List[Tuple[int, int]], merge: bool = False) -> None:
        """
        Import multiple edges into the graph with new ids.

        Arguments:
            edges (List[Edge]): A list of Edge objects representing the edges to be imported.
            new_ids (List[Tuple[int, int]]): The IDs of the new edges. It's a vector of tuples of the source and destination node ids.
            merge (bool): An optional boolean flag. Defaults to False.
                          If merge is False, the function will return an error if any of the imported edges already exists in the graph.
                          If merge is True, the function merges the histories of the imported edges and the existing edges (in the graph).

        Returns:
            None: This function does not return a value if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def import_node(self, node: Node, merge: bool = False) -> Node:
        """
        Import a single node into the graph.

        Arguments:
            node (Node): A Node object representing the node to be imported.
            merge (bool): An optional boolean flag. Defaults to False.
                          If merge is False, the function will return an error if the imported node already exists in the graph.
                          If merge is True, the function merges the histories of the imported node and the existing node (in the graph).

        Returns:
            Node: A node object if the node was successfully imported.

        Raises:
            GraphError: If the operation fails.
        """

    def import_node_as(self, node: Node, new_id: str|int, merge: bool = False) -> MutableNode:
        """
        Import a single node into the graph with new id.

        Arguments:
            node (Node): A Node object representing the node to be imported.
            new_id (str|int): The new node id.
            merge (bool): An optional boolean flag. Defaults to False.
                          If merge is False, the function will return an error if the imported node already exists in the graph.
                          If merge is True, the function merges the histories of the imported node and the existing node (in the graph).

        Returns:
            MutableNode: A node object if the node was successfully imported.

        Raises:
            GraphError: If the operation fails.
        """

    def import_nodes(self, nodes: List[Node], merge: bool = False) -> None:
        """
        Import multiple nodes into the graph.

        Arguments:
            nodes (List[Node]): A vector of Node objects representing the nodes to be imported.
            merge (bool): An optional boolean flag. Defaults to False.
                          If merge is False, the function will return an error if any of the imported nodes already exists in the graph.
                          If merge is True, the function merges the histories of the imported nodes and the existing nodes (in the graph).

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def import_nodes_as(self, nodes: List[Node], new_ids: List[str|int], merge: bool = False) -> None:
        """
        Import multiple nodes into the graph with new ids.

        Arguments:
            nodes (List[Node]): A vector of Node objects representing the nodes to be imported.
            new_ids (List[str|int]): A list of node IDs to use for the imported nodes.
            merge (bool): An optional boolean flag. Defaults to False.
                          If merge is True, the function will return an error if any of the imported nodes already exists in the graph.
                          If merge is False, the function merges the histories of the imported nodes and the existing nodes (in the graph).

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def largest_connected_component(self) -> GraphView:
        """
        Gives the large connected component of a graph.

        # Example Usage:
        g.largest_connected_component()

        Returns:
            GraphView: sub-graph of the graph `g` containing the largest connected component

        """

    @staticmethod
    def load_cached(path: str) -> Graph:
        """
         Load Graph from a file and initialise it as a cache file.

        Future updates are tracked. Use `write_updates` to persist them to the
        cache file.

        Arguments:
          path (str): The path to the cache file

        Returns:
           Graph: the loaded graph with initialised cache
        """

    def load_edge_props_from_pandas(self, df: DataFrame, src: str, dst: str, metadata: Optional[List[str]] = None, shared_metadata: Optional[PropInput] = None, layer: Optional[str] = None, layer_col: Optional[str] = None) -> None:
        """
        Load edge properties from a Pandas DataFrame.

        Arguments:
            df (DataFrame): The Pandas DataFrame containing edge information.
            src (str): The column name for the source node.
            dst (str): The column name for the destination node.
            metadata (List[str], optional): List of edge metadata column names. Defaults to None.
            shared_metadata (PropInput, optional): A dictionary of metadata properties that will be added to every edge. Defaults to None.
            layer (str, optional): The edge layer name. Defaults to None.
            layer_col (str, optional): The edge layer col name in dataframe. Defaults to None.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_edge_props_from_parquet(self, parquet_path: str, src: str, dst: str, metadata: Optional[List[str]] = None, shared_metadata: Optional[PropInput] = None, layer: Optional[str] = None, layer_col: Optional[str] = None) -> None:
        """
        Load edge properties from parquet file

        Arguments:
            parquet_path (str): Parquet file or directory of Parquet files path containing edge information.
            src (str): The column name for the source node.
            dst (str): The column name for the destination node.
            metadata (List[str], optional): List of edge metadata column names. Defaults to None.
            shared_metadata (PropInput, optional): A dictionary of metadata properties that will be added to every edge. Defaults to None.
            layer (str, optional): The edge layer name. Defaults to None.
            layer_col (str, optional): The edge layer col name in dataframe. Defaults to None.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_edges_from_pandas(self, df: DataFrame, time: str, src: str, dst: str, properties: Optional[List[str]] = None, metadata: Optional[List[str]] = None, shared_metadata: Optional[PropInput] = None, layer: Optional[str] = None, layer_col: Optional[str] = None) -> None:
        """
        Load edges from a Pandas DataFrame into the graph.

        Arguments:
            df (DataFrame): The Pandas DataFrame containing the edges.
            time (str): The column name for the update timestamps.
            src (str): The column name for the source node ids.
            dst (str): The column name for the destination node ids.
            properties (List[str], optional): List of edge property column names. Defaults to None.
            metadata (List[str], optional): List of edge metadata column names. Defaults to None.
            shared_metadata (PropInput, optional): A dictionary of metadata properties that will be added to every edge. Defaults to None.
            layer (str, optional): A value to use as the layer for all edges. Defaults to None. (cannot be used in combination with layer_col)
            layer_col (str, optional): The edge layer col name in dataframe. Defaults to None. (cannot be used in combination with layer)

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_edges_from_parquet(self, parquet_path: str, time: str, src: str, dst: str, properties: Optional[List[str]] = None, metadata: Optional[List[str]] = None, shared_metadata: Optional[PropInput] = None, layer: Optional[str] = None, layer_col: Optional[str] = None) -> None:
        """
        Load edges from a Parquet file into the graph.

        Arguments:
            parquet_path (str): Parquet file or directory of Parquet files path containing edges
            time (str): The column name for the update timestamps.
            src (str): The column name for the source node ids.
            dst (str): The column name for the destination node ids.
            properties (List[str], optional): List of edge property column names. Defaults to None.
            metadata (List[str], optional): List of edge metadata column names. Defaults to None.
            shared_metadata (PropInput, optional): A dictionary of metadata properties that will be added to every edge. Defaults to None.
            layer (str, optional): A value to use as the layer for all edges. Defaults to None. (cannot be used in combination with layer_col)
            layer_col (str, optional): The edge layer col name in dataframe. Defaults to None. (cannot be used in combination with layer)

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    @staticmethod
    def load_from_file(path: str) -> Graph:
        """
         Load Graph from a file.

        Arguments:
          path (str): The path to the file.

        Returns:
           Graph:
        """

    def load_node_props_from_pandas(self, df: DataFrame, id: str, node_type: Optional[str] = None, node_type_col: Optional[str] = None, metadata: Optional[List[str]] = None, shared_metadata: Optional[PropInput] = None) -> None:
        """
        Load node properties from a Pandas DataFrame.

        Arguments:
            df (DataFrame): The Pandas DataFrame containing node information.
            id(str): The column name for the node IDs.
            node_type (str, optional): A value to use as the node type for all nodes. Defaults to None. (cannot be used in combination with node_type_col)
            node_type_col (str, optional): The node type col name in dataframe. Defaults to None. (cannot be used in combination with node_type)
            metadata (List[str], optional): List of node metadata column names. Defaults to None.
            shared_metadata (PropInput, optional): A dictionary of metadata properties that will be added to every node. Defaults to None.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_node_props_from_parquet(self, parquet_path: str, id: str, node_type: Optional[str] = None, node_type_col: Optional[str] = None, metadata: Optional[List[str]] = None, shared_metadata: Optional[PropInput] = None) -> None:
        """
        Load node properties from a parquet file.

        Arguments:
            parquet_path (str): Parquet file or directory of Parquet files path containing node information.
            id(str): The column name for the node IDs.
            node_type (str, optional): A value to use as the node type for all nodes. Defaults to None. (cannot be used in combination with node_type_col)
            node_type_col (str, optional): The node type col name in dataframe. Defaults to None. (cannot be used in combination with node_type)
            metadata (List[str], optional): List of node metadata column names. Defaults to None.
            shared_metadata (PropInput, optional): A dictionary of metadata properties that will be added to every node. Defaults to None.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_nodes_from_pandas(self, df: DataFrame, time: str, id: str, node_type: Optional[str] = None, node_type_col: Optional[str] = None, properties: Optional[List[str]] = None, metadata: Optional[List[str]] = None, shared_metadata: Optional[PropInput] = None) -> None:
        """
        Load nodes from a Pandas DataFrame into the graph.

        Arguments:
            df (DataFrame): The Pandas DataFrame containing the nodes.
            time (str): The column name for the timestamps.
            id (str): The column name for the node IDs.
            node_type (str, optional): A value to use as the node type for all nodes. Defaults to None. (cannot be used in combination with node_type_col)
            node_type_col (str, optional): The node type col name in dataframe. Defaults to None. (cannot be used in combination with node_type)
            properties (List[str], optional): List of node property column names. Defaults to None.
            metadata (List[str], optional): List of node metadata column names. Defaults to None.
            shared_metadata (PropInput, optional): A dictionary of metadata properties that will be added to every node. Defaults to None.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_nodes_from_parquet(self, parquet_path: str, time: str, id: str, node_type: Optional[str] = None, node_type_col: Optional[str] = None, properties: Optional[List[str]] = None, metadata: Optional[List[str]] = None, shared_metadata: Optional[PropInput] = None) -> None:
        """
        Load nodes from a Parquet file into the graph.

        Arguments:
            parquet_path (str): Parquet file or directory of Parquet files containing the nodes
            time (str): The column name for the timestamps.
            id (str): The column name for the node IDs.
            node_type (str, optional): A value to use as the node type for all nodes. Defaults to None. (cannot be used in combination with node_type_col)
            node_type_col (str, optional): The node type col name in dataframe. Defaults to None. (cannot be used in combination with node_type)
            properties (List[str], optional): List of node property column names. Defaults to None.
            metadata (List[str], optional): List of node metadata column names. Defaults to None.
            shared_metadata (PropInput, optional): A dictionary of metadata properties that will be added to every node. Defaults to None.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def node(self, id: str|int) -> MutableNode:
        """
        Gets the node with the specified id

        Arguments:
          id (str|int): the node id

        Returns:
          MutableNode: The node object with the specified id, or None if the node does not exist
        """

    def persistent_graph(self) -> PersistentGraph:
        """
        View graph with persistent semantics

        Returns:
            PersistentGraph: the graph with persistent semantics applied
        """

    def save_to_file(self, path: str) -> None:
        """
         Saves the Graph to the given path.

        Arguments:
            path (str): The path to the file.

        Returns:
            None:
        """

    def save_to_zip(self, path: str) -> None:
        """
         Saves the Graph to the given path.

        Arguments:
            path (str): The path to the file.
        Returns:
            None:
        """

    def serialise(self) -> bytes:
        """
         Serialise Graph to bytes.

        Returns:
          bytes:
        """

    def to_parquet(self, graph_dir: str | PathLike):
        """
        Persist graph to parquet files

        Arguments:
            graph_dir (str | PathLike): the folder where the graph will be persisted as parquet

        """

    def update_metadata(self, metadata: PropInput) -> None:
        """
        Updates static properties to the graph.

        Arguments:
            metadata (PropInput): The static properties of the graph.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def write_updates(self) -> None:
        """
        Persist the new updates by appending them to the cache file.

        Returns:
            None:
        """

class PersistentGraph(GraphView): 
    """A temporal graph that allows edges and nodes to be deleted."""

    def __new__(cls) -> PersistentGraph:
        """Create and return a new object.  See help(type) for accurate signature."""

    def __reduce__(self):
        ...

    def add_edge(self, timestamp: int, src: str | int, dst: str | int, properties: Optional[PropInput] = None, layer: Optional[str] = None, secondary_index: Optional[int] = None) -> None:
        """
        Adds a new edge with the given source and destination nodes and properties to the graph.

        Arguments:
           timestamp (int): The timestamp of the edge.
           src (str | int): The id of the source node.
           dst (str | int): The id of the destination node.
           properties (PropInput, optional): The properties of the edge, as a dict of string and properties
           layer (str, optional): The layer of the edge.
           secondary_index (int, optional): The optional integer which will be used as a secondary index

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def add_metadata(self, metadata: dict) -> None:
        """
        Adds metadata to the graph.

        Arguments:
            metadata (dict): The static properties of the graph.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def add_node(self, timestamp: TimeInput, id: str | int, properties: Optional[PropInput] = None, node_type: Optional[str] = None, secondary_index: Optional[int] = None) -> None:
        """
        Adds a new node with the given id and properties to the graph.

        Arguments:
           timestamp (TimeInput): The timestamp of the node.
           id (str | int): The id of the node.
           properties (PropInput, optional): The properties of the node.
           node_type (str, optional) : The optional string which will be used as a node type
           secondary_index (int, optional): The optional integer which will be used as a secondary index

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def add_properties(self, timestamp: TimeInput, properties: dict, secondary_index: Optional[int] = None) -> None:
        """
        Adds properties to the graph.

        Arguments:
           timestamp (TimeInput): The timestamp of the temporal property.
           properties (dict): The temporal properties of the graph.
           secondary_index (int, optional): The optional integer which will be used as a secondary index

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def cache(self, path: str) -> None:
        """
         Write PersistentGraph to cache file and initialise the cache.

        Future updates are tracked. Use `write_updates` to persist them to the
        cache file. If the file already exists its contents are overwritten.

        Arguments:
            path (str): The path to the cache file

        Returns:
            None:
        """

    def create_index(self):
        """Create graph index"""

    def create_index_in_ram(self):
        """
        Creates a graph index in memory (RAM).

        This is primarily intended for use in tests and should not be used in production environments,
        as the index will not be persisted to disk.
        """

    def create_index_in_ram_with_spec(self, py_spec):
        """
        Creates a graph index in memory (RAM) with the provided index spec.

        This is primarily intended for use in tests and should not be used in production environments,
        as the index will not be persisted to disk.
        """

    def create_index_with_spec(self, py_spec):
        """Create graph index with the provided index spec."""

    def create_node(self, timestamp: TimeInput, id: str | int, properties: Optional[PropInput] = None, node_type: Optional[str] = None, secondary_index: Optional[int] = None) -> MutableNode:
        """
        Creates a new node with the given id and properties to the graph. It fails if the node already exists.

        Arguments:
           timestamp (TimeInput): The timestamp of the node.
           id (str | int): The id of the node.
           properties (PropInput, optional): The properties of the node.
           node_type (str, optional) : The optional string which will be used as a node type
           secondary_index (int, optional): The optional integer which will be used as a secondary index

        Returns:
          MutableNode: the newly created node.

        Raises:
            GraphError: If the operation fails.
        """

    def delete_edge(self, timestamp: int, src: str | int, dst: str | int, layer: Optional[str] = None, secondary_index: Optional[int] = None) -> MutableEdge:
        """
        Deletes an edge given the timestamp, src and dst nodes and layer (optional)

        Arguments:
          timestamp (int): The timestamp of the edge.
          src (str | int): The id of the source node.
          dst (str | int): The id of the destination node.
          layer (str, optional): The layer of the edge.
          secondary_index (int, optional): The optional integer which will be used as a secondary index.

        Returns:
          MutableEdge: The deleted edge

        Raises:
            GraphError: If the operation fails.
        """

    @staticmethod
    def deserialise(bytes: bytes) -> PersistentGraph:
        """
         Load PersistentGraph from serialised bytes.

        Arguments:
            bytes (bytes): The serialised bytes to decode

        Returns:
           PersistentGraph:
        """

    def edge(self, src: str | int, dst: str | int) -> Optional[MutableEdge]:
        """
        Gets the edge with the specified source and destination nodes

        Arguments:
            src (str | int): the source node id
            dst (str | int): the destination node id

        Returns:
            Optional[MutableEdge]: The edge with the specified source and destination nodes, or None if the edge does not exist
        """

    def event_graph(self) -> Graph:
        """
        Get event graph

        Returns:
            Graph: the graph with event semantics applied
        """

    def get_all_node_types(self) -> list[str]:
        """
        Returns all the node types in the graph.

        Returns:
            list[str]: A list of node types
        """

    def import_edge(self, edge: Edge, merge: bool = False) -> Edge:
        """
        Import a single edge into the graph.

        This function takes an edge object and an optional boolean flag. If the flag is set to true,
        the function will merge the import of the edge even if it already exists in the graph.

        Arguments:
            edge (Edge): An edge object representing the edge to be imported.
            merge (bool): An optional boolean flag indicating whether to merge the import of the edge. Defaults to False.

        Returns:
            Edge: The imported edge.

        Raises:
            GraphError: If the operation fails.
        """

    def import_edge_as(self, edge: Edge, new_id: tuple, merge: bool = False) -> Edge:
        """
        Import a single edge into the graph with new id.

        This function takes a edge object, a new edge id and an optional boolean flag. If the flag is set to true,
        the function will merge the import of the edge even if it already exists in the graph.

        Arguments:
            edge (Edge): A edge object representing the edge to be imported.
            new_id (tuple) : The ID of the new edge. It's a tuple of the source and destination node ids.
            merge (bool): An optional boolean flag indicating whether to merge the import of the edge. Defaults to False.

        Returns:
            Edge: The imported edge.

        Raises:
            GraphError: If the operation fails.
        """

    def import_edges(self, edges: List[Edge], merge: bool = False) -> None:
        """
        Import multiple edges into the graph.

        This function takes a vector of edge objects and an optional boolean flag. If the flag is set to true,
        the function will merge the import of the edges even if they already exist in the graph.

        Arguments:
            edges (List[Edge]): A vector of edge objects representing the edges to be imported.
            merge (bool): An optional boolean flag indicating whether to merge the import of the edges. Defaults to False.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def import_edges_as(self, edges: List[Edge], new_ids: list[Tuple[GID, GID]], merge: bool = False) -> None:
        """
        Import multiple edges into the graph with new ids.

        This function takes a vector of edge objects, a list of new edge ids and an optional boolean flag. If the flag is set to true,
        the function will merge the import of the edges even if they already exist in the graph.

        Arguments:
            edges (List[Edge]): A vector of edge objects representing the edges to be imported.
            new_ids (list[Tuple[GID, GID]]): The new edge ids
            merge (bool): An optional boolean flag indicating whether to merge the import of the edges. Defaults to False.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def import_node(self, node: Node, merge: bool = False) -> Node:
        """
        Import a single node into the graph.

        This function takes a node object and an optional boolean flag. If the flag is set to true,
        the function will merge the import of the node even if it already exists in the graph.

        Arguments:
            node (Node): A node object representing the node to be imported.
            merge (bool): An optional boolean flag indicating whether to merge the import of the node. Defaults to False.

        Returns:
            Node: A Node object if the node was successfully imported, and an error otherwise.

        Raises:
            GraphError: If the operation fails.
        """

    def import_node_as(self, node: Node, new_id: str|int, merge: bool = False) -> Node:
        """
        Import a single node into the graph with new id.

        This function takes a node object, a new node id and an optional boolean flag. If the flag is set to true,
        the function will merge the import of the node even if it already exists in the graph.

        Arguments:
            node (Node): A node object representing the node to be imported.
            new_id (str|int): The new node id.
            merge (bool): An optional boolean flag indicating whether to merge the import of the node. Defaults to False.

        Returns:
            Node: A Node object if the node was successfully imported, and an error otherwise.

        Raises:
            GraphError: If the operation fails.
        """

    def import_nodes(self, nodes: List[Node], merge: bool = False) -> None:
        """
        Import multiple nodes into the graph.

        This function takes a vector of node objects and an optional boolean flag. If the flag is set to true,
        the function will merge the import of the nodes even if they already exist in the graph.

        Arguments:
            nodes (List[Node]):  A vector of node objects representing the nodes to be imported.
            merge (bool): An optional boolean flag indicating whether to merge the import of the nodes. Defaults to False.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def import_nodes_as(self, nodes: List[Node], new_ids: List[str|int], merge: bool = False) -> None:
        """
        Import multiple nodes into the graph with new ids.

        This function takes a vector of node objects, a list of new node ids and an optional boolean flag. If the flag is set to true,
        the function will merge the import of the nodes even if they already exist in the graph.

        Arguments:
            nodes (List[Node]):  A vector of node objects representing the nodes to be imported.
            new_ids (List[str|int]): A list of node IDs to use for the imported nodes.
            merge (bool): An optional boolean flag indicating whether to merge the import of the nodes. Defaults to False.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    @staticmethod
    def load_cached(path: str) -> PersistentGraph:
        """
         Load PersistentGraph from a file and initialise it as a cache file.

        Future updates are tracked. Use `write_updates` to persist them to the
        cache file.

        Arguments:
          path (str): The path to the cache file

        Returns:
           PersistentGraph: the loaded graph with initialised cache
        """

    def load_edge_deletions_from_pandas(self, df: DataFrame, time: str, src: str, dst: str, layer: Optional[str] = None, layer_col: Optional[str] = None) -> None:
        """
        Load edges deletions from a Pandas DataFrame into the graph.

        Arguments:
            df (DataFrame): The Pandas DataFrame containing the edges.
            time (str): The column name for the update timestamps.
            src (str): The column name for the source node ids.
            dst (str): The column name for the destination node ids.
            layer (str, optional): A value to use as the layer for all edges. Defaults to None. (cannot be used in combination with layer_col)
            layer_col (str, optional): The edge layer col name in dataframe. Defaults to None. (cannot be used in combination with layer)

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_edge_deletions_from_parquet(self, parquet_path: str, time: str, src: str, dst: str, layer: Optional[str] = None, layer_col: Optional[str] = None) -> None:
        """
        Load edges deletions from a Parquet file into the graph.

        Arguments:
            parquet_path (str): Parquet file or directory of Parquet files path containing node information.
            src (str): The column name for the source node ids.
            dst (str): The column name for the destination node ids.
            time (str): The column name for the update timestamps.
            layer (str, optional): A value to use as the layer for all edges. Defaults to None. (cannot be used in combination with layer_col)
            layer_col (str, optional): The edge layer col name in dataframe. Defaults to None. (cannot be used in combination with layer)

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_edge_props_from_pandas(self, df: DataFrame, src: str, dst: str, metadata: Optional[List[str]] = None, shared_metadata: Optional[PropInput] = None, layer: Optional[str] = None, layer_col: Optional[str] = None) -> None:
        """
        Load edge properties from a Pandas DataFrame.

        Arguments:
            df (DataFrame): The Pandas DataFrame containing edge information.
            src (str): The column name for the source node.
            dst (str): The column name for the destination node.
            metadata (List[str], optional): List of edge metadata column names. Defaults to None.
            shared_metadata (PropInput, optional): A dictionary of metadata properties that will be added to every edge. Defaults to None.
            layer (str, optional): The edge layer name. Defaults to None.
            layer_col (str, optional): The edge layer col name in dataframe. Defaults to None.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_edge_props_from_parquet(self, parquet_path: str, src: str, dst: str, metadata: Optional[List[str]] = None, shared_metadata: Optional[PropInput] = None, layer: Optional[str] = None, layer_col: Optional[str] = None) -> None:
        """
        Load edge properties from parquet file

        Arguments:
            parquet_path (str): Parquet file or directory of Parquet files path containing edge information.
            src (str): The column name for the source node.
            dst (str): The column name for the destination node.
            metadata (List[str], optional): List of edge metadata column names. Defaults to None.
            shared_metadata (PropInput, optional): A dictionary of metadata properties that will be added to every edge. Defaults to None.
            layer (str, optional): The edge layer name. Defaults to None.
            layer_col (str, optional): The edge layer col name in dataframe. Defaults to None.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_edges_from_pandas(self, df: DataFrame, time: str, src: str, dst: str, properties: Optional[List[str]] = None, metadata: Optional[List[str]] = None, shared_metadata: Optional[PropInput] = None, layer: Optional[str] = None, layer_col: Optional[str] = None) -> None:
        """
        Load edges from a Pandas DataFrame into the graph.

        Arguments:
            df (DataFrame): The Pandas DataFrame containing the edges.
            time (str): The column name for the update timestamps.
            src (str): The column name for the source node ids.
            dst (str): The column name for the destination node ids.
            properties (List[str], optional): List of edge property column names. Defaults to None.
            metadata (List[str], optional): List of edge metadata column names. Defaults to None.
            shared_metadata (PropInput, optional): A dictionary of metadata properties that will be added to every edge. Defaults to None.
            layer (str, optional): A value to use as the layer for all edges. Defaults to None. (cannot be used in combination with layer_col)
            layer_col (str, optional): The edge layer col name in dataframe. Defaults to None. (cannot be used in combination with layer)

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_edges_from_parquet(self, parquet_path: str, time: str, src: str, dst: str, properties: Optional[List[str]] = None, metadata: Optional[List[str]] = None, shared_metadata: Optional[PropInput] = None, layer: Optional[str] = None, layer_col: Optional[str] = None) -> None:
        """
        Load edges from a Parquet file into the graph.

        Arguments:
            parquet_path (str): Parquet file or directory of Parquet files path containing edges
            time (str): The column name for the update timestamps.
            src (str): The column name for the source node ids.
            dst (str): The column name for the destination node ids.
            properties (List[str], optional): List of edge property column names. Defaults to None.
            metadata (List[str], optional): List of edge metadata column names. Defaults to None.
            shared_metadata (PropInput, optional): A dictionary of metadata properties that will be added to every edge. Defaults to None.
            layer (str, optional): A value to use as the layer for all edges. Defaults to None. (cannot be used in combination with layer_col)
            layer_col (str, optional): The edge layer col name in dataframe. Defaults to None. (cannot be used in combination with layer)

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    @staticmethod
    def load_from_file(path: str) -> PersistentGraph:
        """
         Load PersistentGraph from a file.

        Arguments:
          path (str): The path to the file.

        Returns:
           PersistentGraph:
        """

    def load_node_props_from_pandas(self, df: DataFrame, id: str, node_type: Optional[str] = None, node_type_col: Optional[str] = None, metadata: Optional[List[str]] = None, shared_metadata: Optional[PropInput] = None) -> None:
        """
        Load node properties from a Pandas DataFrame.

        Arguments:
            df (DataFrame): The Pandas DataFrame containing node information.
            id(str): The column name for the node IDs.
            node_type (str, optional): A value to use as the node type for all nodes. Defaults to None. (cannot be used in combination with node_type_col)
            node_type_col (str, optional): The node type col name in dataframe. Defaults to None. (cannot be used in combination with node_type)
            metadata (List[str], optional): List of node metadata column names. Defaults to None.
            shared_metadata (PropInput, optional): A dictionary of metadata properties that will be added to every node. Defaults to None.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_node_props_from_parquet(self, parquet_path: str, id: str, node_type: Optional[str] = None, node_type_col: Optional[str] = None, metadata: Optional[List[str]] = None, shared_metadata: Optional[PropInput] = None) -> None:
        """
        Load node properties from a parquet file.

        Arguments:
            parquet_path (str): Parquet file or directory of Parquet files path containing node information.
            id(str): The column name for the node IDs.
            node_type (str, optional): A value to use as the node type for all nodes. Defaults to None. (cannot be used in combination with node_type_col)
            node_type_col (str, optional): The node type col name in dataframe. Defaults to None. (cannot be used in combination with node_type)
            metadata (List[str], optional): List of node metadata column names. Defaults to None.
            shared_metadata (PropInput, optional): A dictionary of metadata properties that will be added to every node. Defaults to None.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_nodes_from_pandas(self, df: DataFrame, time: str, id: str, node_type: Optional[str] = None, node_type_col: Optional[str] = None, properties: Optional[List[str]] = None, metadata: Optional[List[str]] = None, shared_metadata: Optional[PropInput] = None) -> None:
        """
        Load nodes from a Pandas DataFrame into the graph.

        Arguments:
            df (DataFrame): The Pandas DataFrame containing the nodes.
            time (str): The column name for the timestamps.
            id (str): The column name for the node IDs.
            node_type (str, optional): A value to use as the node type for all nodes. Defaults to None. (cannot be used in combination with node_type_col)
            node_type_col (str, optional): The node type col name in dataframe. Defaults to None. (cannot be used in combination with node_type)
            properties (List[str], optional): List of node property column names. Defaults to None.
            metadata (List[str], optional): List of node metadata column names. Defaults to None.
            shared_metadata (PropInput, optional): A dictionary of metadata properties that will be added to every node. Defaults to None.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_nodes_from_parquet(self, parquet_path: str, time: str, id: str, node_type: Optional[str] = None, node_type_col: Optional[str] = None, properties: Optional[List[str]] = None, metadata: Optional[List[str]] = None, shared_metadata: Optional[PropInput] = None) -> None:
        """
        Load nodes from a Parquet file into the graph.

        Arguments:
            parquet_path (str): Parquet file or directory of Parquet files containing the nodes
            time (str): The column name for the timestamps.
            id (str): The column name for the node IDs.
            node_type (str, optional): A value to use as the node type for all nodes. Defaults to None. (cannot be used in combination with node_type_col)
            node_type_col (str, optional): The node type col name in dataframe. Defaults to None. (cannot be used in combination with node_type)
            properties (List[str], optional): List of node property column names. Defaults to None.
            metadata (List[str], optional): List of node metadata column names. Defaults to None.
            shared_metadata (PropInput, optional): A dictionary of metadata properties that will be added to every node. Defaults to None.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def node(self, id: str | int) -> Optional[MutableNode]:
        """
        Gets the node with the specified id

        Arguments:
          id (str | int): the node id

        Returns:
          Optional[MutableNode]: The node with the specified id, or None if the node does not exist
        """

    def persistent_graph(self) -> PersistentGraph:
        """
        Get persistent graph

        Returns:
            PersistentGraph: the graph with persistent semantics applied
        """

    def save_to_file(self, path: str) -> None:
        """
         Saves the PersistentGraph to the given path.

        Arguments:
            path (str): The path to the file.

        Returns:
            None:
        """

    def save_to_zip(self, path: str) -> None:
        """
         Saves the PersistentGraph to the given path.

        Arguments:
            path (str): The path to the file.
        Returns:
            None:
        """

    def serialise(self) -> bytes:
        """
         Serialise PersistentGraph to bytes.

        Returns:
          bytes:
        """

    def update_metadata(self, metadata: dict) -> None:
        """
        Updates metadata of the graph.

        Arguments:
            metadata (dict): The static properties of the graph.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def write_updates(self) -> None:
        """
        Persist the new updates by appending them to the cache file.

        Returns:
            None:
        """

class Node(object): 
    """A node (or node) in the graph."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __hash__(self):
        """Return hash(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> Node:
        """
         Create a view of the Node including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             Node:
        """

    def at(self, time: TimeInput) -> Node:
        """
         Create a view of the Node including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             Node:
        """

    def before(self, end: TimeInput) -> Node:
        """
         Create a view of the Node including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             Node:
        """

    def default_layer(self) -> Node:
        """
         Return a view of Node containing only the default edge layer
        Returns:
             Node: The layered view
        """

    def degree(self) -> int:
        """
        Get the degree of this node (i.e., the number of edges that are incident to it).

        Returns:
            int: The degree of this node.
        """

    @property
    def earliest_date_time(self) -> datetime:
        """
        Returns the earliest datetime that the node exists.

        Returns:
            datetime: The earliest datetime that the node exists as a Datetime.
        """

    @property
    def earliest_time(self) -> int:
        """
        Returns the earliest time that the node exists.

        Returns:
            int: The earliest time that the node exists as an integer.
        """

    def edge_history_count(self) -> int:
        """
        Get the number of edge events for this node

        Returns:
            int: The number of edge events
        """

    @property
    def edges(self) -> Edges:
        """
        Get the edges that are incident to this node.

        Returns:

             Edges: The incident edges.
        """

    @property
    def end(self) -> Optional[int]:
        """
         Gets the latest time that this Node is valid.

        Returns:
           Optional[int]: The latest time that this Node is valid or None if the Node is valid for all times.
        """

    @property
    def end_date_time(self) -> Optional[datetime]:
        """
         Gets the latest datetime that this Node is valid

        Returns:
             Optional[datetime]: The latest datetime that this Node is valid or None if the Node is valid for all times.
        """

    def exclude_layer(self, name: str) -> Node:
        """
         Return a view of Node containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             Node: The layered view
        """

    def exclude_layers(self, names: list[str]) -> Node:
        """
         Return a view of Node containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             Node: The layered view
        """

    def exclude_valid_layer(self, name: str) -> Node:
        """
         Return a view of Node containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             Node: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> Node:
        """
         Return a view of Node containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             Node: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def filter_edges(self, filter: filter.FilterExpr) -> Node:
        """
        Return a filtered view that only includes edges that satisfy the filter

        Arguments:
            filter (filter.FilterExpr): The filter to apply to the edges.

        Returns:
            Node: The filtered view
        """

    def filter_exploded_edges(self, filter: filter.FilterExpr) -> Node:
        """
        Return a filtered view that only includes exploded edges that satisfy the filter

        Arguments:
            filter (filter.FilterExpr): The filter to apply to the exploded edge properties.

        Returns:
            Node: The filtered view
        """

    def filter_nodes(self, filter: filter.FilterExpr) -> Node:
        """
        Return a filtered view that only includes nodes that satisfy the filter

        Arguments:
            filter (filter.FilterExpr): The filter to apply to the nodes.

        Returns:
            Node: The filtered view
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if Node has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def history(self) -> List[int]:
        """
        Returns the history of a node, including node additions and changes made to node.

        Returns:
            List[int]: A list of unix timestamps of the event history of node.
        """

    def history_date_time(self) -> List[datetime]:
        """
        Returns the history of a node, including node additions and changes made to node.

        Returns:
            List[datetime]: A list of timestamps of the event history of node.

        """

    @property
    def id(self) -> (str|int):
        """
        Returns the id of the node.
        This is a unique identifier for the node.

        Returns:
           (str|int): The id of the node.
        """

    def in_degree(self) -> int:
        """
        Get the in-degree of this node (i.e., the number of edges that are incident to it from other nodes).

        Returns:
           int: The in-degree of this node.
        """

    @property
    def in_edges(self) -> Edges:
        """
        Get the edges that point into this node.

        Returns:

             Edges: The inbound edges.
        """

    @property
    def in_neighbours(self) -> PathFromNode:
        """
        Get the neighbours of this node that point into this node.

        Returns:

             PathFromNode: The in-neighbours.
        """

    def is_active(self) -> bool:
        """
        Check if the node is active, i.e., it's history is not empty

        Returns:
            bool:
        """

    def latest(self) -> Node:
        """
         Create a view of the Node including all events at the latest time.

        Returns:
             Node:
        """

    @property
    def latest_date_time(self) -> datetime:
        """
        Returns the latest datetime that the node exists.

        Returns:
            datetime: The latest datetime that the node exists as a Datetime.
        """

    @property
    def latest_time(self) -> int:
        """
        Returns the latest time that the node exists.

        Returns:
           int:  The latest time that the node exists as an integer.
        """

    def layer(self, name: str) -> Node:
        """
         Return a view of Node containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             Node: The layered view
        """

    def layers(self, names: list[str]) -> Node:
        """
         Return a view of Node containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             Node: The layered view
        """

    @property
    def metadata(self) -> Metadata:
        """
        The metadata of the node

        Returns:
            Metadata:
        """

    @property
    def name(self) -> str:
        """
        Returns the name of the node.

        Returns:
            str: The id of the node as a string.
        """

    @property
    def neighbours(self) -> PathFromNode:
        """
        Get the neighbours of this node.

        Returns:

             PathFromNode: The neighbours (both inbound and outbound).
        """

    @property
    def node_type(self) -> Optional[str]:
        """
        Returns the type of node

        Returns:
            Optional[str]: The node type if it is set or `None` otherwise.
        """

    def out_degree(self) -> int:
        """
        Get the out-degree of this node (i.e., the number of edges that are incident to it from this node).

        Returns:
          int: The out-degree of this node.
        """

    @property
    def out_edges(self) -> Edges:
        """
        Get the edges that point out of this node.

        Returns:

             Edges: The outbound edges.
        """

    @property
    def out_neighbours(self) -> PathFromNode:
        """
        Get the neighbours of this node that point out of this node.

        Returns:

             PathFromNode: The out-neighbours.
        """

    @property
    def properties(self) -> Properties:
        """
        The properties of the node

        Returns:
            Properties: A list of properties.
        """

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> Node:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             Node:
        """

    def shrink_start(self, start: TimeInput) -> Node:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             Node:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> Node:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             Node:
        """

    def snapshot_at(self, time: TimeInput) -> Node:
        """
         Create a view of the Node including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             Node:
        """

    def snapshot_latest(self) -> Node:
        """
         Create a view of the Node including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             Node:
        """

    @property
    def start(self) -> Optional[int]:
        """
         Gets the start time for rolling and expanding windows for this Node

        Returns:
            Optional[int]: The earliest time that this Node is valid or None if the Node is valid for all times.
        """

    @property
    def start_date_time(self) -> Optional[datetime]:
        """
         Gets the earliest datetime that this Node is valid

        Returns:
             Optional[datetime]: The earliest datetime that this Node is valid or None if the Node is valid for all times.
        """

    def valid_layers(self, names: list[str]) -> Node:
        """
         Return a view of Node containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             Node: The layered view
        """

    def window(self, start: TimeInput | None, end: TimeInput | None) -> Node:
        """
         Create a view of the Node including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
            Node:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this Node

        Returns:
            Optional[int]:
        """

class Nodes(object): 
    """A list of nodes that can be iterated over."""

    def __bool__(self):
        """True if self else False"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> Nodes:
        """
         Create a view of the Nodes including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             Nodes:
        """

    def at(self, time: TimeInput) -> Nodes:
        """
         Create a view of the Nodes including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             Nodes:
        """

    def before(self, end: TimeInput) -> Nodes:
        """
         Create a view of the Nodes including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             Nodes:
        """

    def collect(self) -> list[Node]:
        """
         Collect all nodes into a list

        Returns:
             list[Node]: the list of nodes
        """

    def default_layer(self) -> Nodes:
        """
         Return a view of Nodes containing only the default edge layer
        Returns:
             Nodes: The layered view
        """

    def degree(self) -> DegreeView:
        """
        Returns the number of edges of the nodes

        Returns:
            DegreeView: a view of the undirected node degrees
        """

    @property
    def earliest_date_time(self) -> EarliestDateTimeView:
        """
        The earliest time nodes are active as datetime objects

        Returns:
            EarliestDateTimeView: a view of the earliest active times.
        """

    @property
    def earliest_time(self) -> EarliestTimeView:
        """
        The earliest times nodes are active

        Returns:
            EarliestTimeView: a view of the earliest active times
        """

    def edge_history_count(self) -> EdgeHistoryCountView:
        """
        Return the number of edge updates for each node

        Returns:
            EdgeHistoryCountView: a view of the edge history counts
        """

    @property
    def edges(self) -> NestedEdges:
        """
        Get the edges that are incident to this node.

        Returns:

             NestedEdges: The incident edges.
        """

    @property
    def end(self) -> Optional[int]:
        """
         Gets the latest time that this Nodes is valid.

        Returns:
           Optional[int]: The latest time that this Nodes is valid or None if the Nodes is valid for all times.
        """

    @property
    def end_date_time(self) -> Optional[datetime]:
        """
         Gets the latest datetime that this Nodes is valid

        Returns:
             Optional[datetime]: The latest datetime that this Nodes is valid or None if the Nodes is valid for all times.
        """

    def exclude_layer(self, name: str) -> Nodes:
        """
         Return a view of Nodes containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             Nodes: The layered view
        """

    def exclude_layers(self, names: list[str]) -> Nodes:
        """
         Return a view of Nodes containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             Nodes: The layered view
        """

    def exclude_valid_layer(self, name: str) -> Nodes:
        """
         Return a view of Nodes containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             Nodes: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> Nodes:
        """
         Return a view of Nodes containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             Nodes: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def filter_edges(self, filter: filter.FilterExpr) -> Nodes:
        """
        Return a filtered view that only includes edges that satisfy the filter

        Arguments:
            filter (filter.FilterExpr): The filter to apply to the edges.

        Returns:
            Nodes: The filtered view
        """

    def filter_exploded_edges(self, filter: filter.FilterExpr) -> Nodes:
        """
        Return a filtered view that only includes exploded edges that satisfy the filter

        Arguments:
            filter (filter.FilterExpr): The filter to apply to the exploded edge properties.

        Returns:
            Nodes: The filtered view
        """

    def filter_nodes(self, filter: filter.FilterExpr) -> Nodes:
        """
        Return a filtered view that only includes nodes that satisfy the filter

        Arguments:
            filter (filter.FilterExpr): The filter to apply to the nodes.

        Returns:
            Nodes: The filtered view
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if Nodes has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def history(self) -> HistoryView:
        """
        Returns all timestamps of nodes, when a node is added or change to a node is made.

        Returns:
           HistoryView: a view of the node histories

        """

    def history_date_time(self) -> HistoryDateTimeView:
        """
        Returns all timestamps of nodes, when a node is added or change to a node is made.

        Returns:
           HistoryDateTimeView: a view of the node histories as datetime objects.

        """

    @property
    def id(self) -> IdView:
        """
        The node ids

        Returns:
            IdView: a view of the node ids
        """

    def in_degree(self) -> DegreeView:
        """
        Returns the number of in edges of the nodes

        Returns:
            DegreeView: a view of the in-degrees of the nodes
        """

    @property
    def in_edges(self) -> NestedEdges:
        """
        Get the edges that point into this node.

        Returns:

             NestedEdges: The inbound edges.
        """

    @property
    def in_neighbours(self) -> PathFromGraph:
        """
        Get the neighbours of this node that point into this node.

        Returns:

             PathFromGraph: The in-neighbours.
        """

    def latest(self) -> Nodes:
        """
         Create a view of the Nodes including all events at the latest time.

        Returns:
             Nodes:
        """

    @property
    def latest_date_time(self) -> LatestDateTimeView:
        """
        The latest time nodes are active as datetime objects

        Returns:
          LatestDateTimeView: a view of the latest active times
        """

    @property
    def latest_time(self) -> LatestTimeView:
        """
        The latest time nodes are active

        Returns:
            LatestTimeView: a view of the latest active times
        """

    def layer(self, name: str) -> Nodes:
        """
         Return a view of Nodes containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             Nodes: The layered view
        """

    def layers(self, names: list[str]) -> Nodes:
        """
         Return a view of Nodes containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             Nodes: The layered view
        """

    @property
    def metadata(self):
        """
        The metadata of the node

        Returns:
            MetadataView: A view of the node properties
        """

    @property
    def name(self) -> NameView:
        """
        The node names

        Returns:
            NameView: a view of the node names
        """

    @property
    def neighbours(self) -> PathFromGraph:
        """
        Get the neighbours of this node.

        Returns:

             PathFromGraph: The neighbours (both inbound and outbound).
        """

    @property
    def node_type(self) -> NodeTypeView:
        """
        The node types

        Returns:
            NodeTypeView: a view of the node types
        """

    def out_degree(self) -> DegreeView:
        """
        Returns the number of out edges of the nodes

        Returns:
            DegreeView: a view of the out-degrees of the nodes
        """

    @property
    def out_edges(self) -> NestedEdges:
        """
        Get the edges that point out of this node.

        Returns:

             NestedEdges: The outbound edges.
        """

    @property
    def out_neighbours(self) -> PathFromGraph:
        """
        Get the neighbours of this node that point out of this node.

        Returns:

             PathFromGraph: The out-neighbours.
        """

    @property
    def properties(self) -> PropertiesView:
        """
        The properties of the node

        Returns:
            PropertiesView: A view of the node properties
        """

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> Nodes:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             Nodes:
        """

    def shrink_start(self, start: TimeInput) -> Nodes:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             Nodes:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> Nodes:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             Nodes:
        """

    def snapshot_at(self, time: TimeInput) -> Nodes:
        """
         Create a view of the Nodes including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             Nodes:
        """

    def snapshot_latest(self) -> Nodes:
        """
         Create a view of the Nodes including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             Nodes:
        """

    @property
    def start(self) -> Optional[int]:
        """
         Gets the start time for rolling and expanding windows for this Nodes

        Returns:
            Optional[int]: The earliest time that this Nodes is valid or None if the Nodes is valid for all times.
        """

    @property
    def start_date_time(self) -> Optional[datetime]:
        """
         Gets the earliest datetime that this Nodes is valid

        Returns:
             Optional[datetime]: The earliest datetime that this Nodes is valid or None if the Nodes is valid for all times.
        """

    def to_df(self, include_property_history: bool = False, convert_datetime: bool = False) -> DataFrame:
        """
        Converts the graph's nodes into a Pandas DataFrame.

        This method will create a DataFrame with the following columns:
        - "name": The name of the node.
        - "properties": The properties of the node.
        - "update_history": The update history of the node.

        Args:
            include_property_history (bool): A boolean, if set to `True`, the history of each property is included, if `False`, only the latest value is shown. Defaults to False.
            convert_datetime (bool): A boolean, if set to `True` will convert the timestamp to python datetimes. Defaults to False.

        Returns:
            DataFrame: the view of the node data as a pandas Dataframe
        """

    def type_filter(self, node_types: list[str]) -> Nodes:
        """
        Filter nodes by node type

        Arguments:
            node_types (list[str]): the list of node types to keep

        Returns:
            Nodes: the filtered view of the nodes
        """

    def valid_layers(self, names: list[str]) -> Nodes:
        """
         Return a view of Nodes containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             Nodes: The layered view
        """

    def window(self, start: TimeInput | None, end: TimeInput | None) -> Nodes:
        """
         Create a view of the Nodes including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
            Nodes:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this Nodes

        Returns:
            Optional[int]:
        """

class PathFromNode(object): 

    def __bool__(self):
        """True if self else False"""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> PathFromNode:
        """
         Create a view of the PathFromNode including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             PathFromNode:
        """

    def at(self, time: TimeInput) -> PathFromNode:
        """
         Create a view of the PathFromNode including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             PathFromNode:
        """

    def before(self, end: TimeInput) -> PathFromNode:
        """
         Create a view of the PathFromNode including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             PathFromNode:
        """

    def collect(self) -> list[Node]:
        """
         Collect all nodes into a list

        Returns:
             list[Node]: the list of nodes
        """

    def default_layer(self) -> PathFromNode:
        """
         Return a view of PathFromNode containing only the default edge layer
        Returns:
             PathFromNode: The layered view
        """

    def degree(self):
        """the node degrees"""

    @property
    def earliest_time(self):
        """the node earliest times"""

    def edge_history_count(self):
        """
        Get the number of edge updates for each node

        Returns:
            UsizeIterable:
        """

    @property
    def edges(self) -> Edges:
        """
        Get the edges that are incident to this node.

        Returns:

             Edges: The incident edges.
        """

    @property
    def end(self) -> Optional[int]:
        """
         Gets the latest time that this PathFromNode is valid.

        Returns:
           Optional[int]: The latest time that this PathFromNode is valid or None if the PathFromNode is valid for all times.
        """

    @property
    def end_date_time(self) -> Optional[datetime]:
        """
         Gets the latest datetime that this PathFromNode is valid

        Returns:
             Optional[datetime]: The latest datetime that this PathFromNode is valid or None if the PathFromNode is valid for all times.
        """

    def exclude_layer(self, name: str) -> PathFromNode:
        """
         Return a view of PathFromNode containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             PathFromNode: The layered view
        """

    def exclude_layers(self, names: list[str]) -> PathFromNode:
        """
         Return a view of PathFromNode containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             PathFromNode: The layered view
        """

    def exclude_valid_layer(self, name: str) -> PathFromNode:
        """
         Return a view of PathFromNode containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             PathFromNode: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> PathFromNode:
        """
         Return a view of PathFromNode containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             PathFromNode: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def filter_edges(self, filter: filter.FilterExpr) -> PathFromNode:
        """
        Return a filtered view that only includes edges that satisfy the filter

        Arguments:
            filter (filter.FilterExpr): The filter to apply to the edges.

        Returns:
            PathFromNode: The filtered view
        """

    def filter_exploded_edges(self, filter: filter.FilterExpr) -> PathFromNode:
        """
        Return a filtered view that only includes exploded edges that satisfy the filter

        Arguments:
            filter (filter.FilterExpr): The filter to apply to the exploded edge properties.

        Returns:
            PathFromNode: The filtered view
        """

    def filter_nodes(self, filter: filter.FilterExpr) -> PathFromNode:
        """
        Return a filtered view that only includes nodes that satisfy the filter

        Arguments:
            filter (filter.FilterExpr): The filter to apply to the nodes.

        Returns:
            PathFromNode: The filtered view
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if PathFromNode has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    @property
    def id(self):
        """the node ids"""

    def in_degree(self):
        """the node in-degrees"""

    @property
    def in_edges(self) -> Edges:
        """
        Get the edges that point into this node.

        Returns:

             Edges: The inbound edges.
        """

    @property
    def in_neighbours(self) -> PathFromNode:
        """
        Get the neighbours of this node that point into this node.

        Returns:

             PathFromNode: The in-neighbours.
        """

    def latest(self) -> PathFromNode:
        """
         Create a view of the PathFromNode including all events at the latest time.

        Returns:
             PathFromNode:
        """

    @property
    def latest_time(self):
        """the node latest times"""

    def layer(self, name: str) -> PathFromNode:
        """
         Return a view of PathFromNode containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             PathFromNode: The layered view
        """

    def layers(self, names: list[str]) -> PathFromNode:
        """
         Return a view of PathFromNode containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             PathFromNode: The layered view
        """

    @property
    def metadata(self):
        """the node metadata"""

    @property
    def name(self):
        """the node names"""

    @property
    def neighbours(self) -> PathFromNode:
        """
        Get the neighbours of this node.

        Returns:

             PathFromNode: The neighbours (both inbound and outbound).
        """

    @property
    def node_type(self):
        """the node types"""

    def out_degree(self):
        """the node out-degrees"""

    @property
    def out_edges(self) -> Edges:
        """
        Get the edges that point out of this node.

        Returns:

             Edges: The outbound edges.
        """

    @property
    def out_neighbours(self) -> PathFromNode:
        """
        Get the neighbours of this node that point out of this node.

        Returns:

             PathFromNode: The out-neighbours.
        """

    @property
    def properties(self):
        """the node properties"""

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> PathFromNode:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             PathFromNode:
        """

    def shrink_start(self, start: TimeInput) -> PathFromNode:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             PathFromNode:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> PathFromNode:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             PathFromNode:
        """

    def snapshot_at(self, time: TimeInput) -> PathFromNode:
        """
         Create a view of the PathFromNode including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             PathFromNode:
        """

    def snapshot_latest(self) -> PathFromNode:
        """
         Create a view of the PathFromNode including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             PathFromNode:
        """

    @property
    def start(self) -> Optional[int]:
        """
         Gets the start time for rolling and expanding windows for this PathFromNode

        Returns:
            Optional[int]: The earliest time that this PathFromNode is valid or None if the PathFromNode is valid for all times.
        """

    @property
    def start_date_time(self) -> Optional[datetime]:
        """
         Gets the earliest datetime that this PathFromNode is valid

        Returns:
             Optional[datetime]: The earliest datetime that this PathFromNode is valid or None if the PathFromNode is valid for all times.
        """

    def type_filter(self, node_types: list[str]) -> PathFromNode:
        """
        filter nodes by type

        Arguments:
            node_types (list[str]): the node types to keep

        Returns:
            PathFromNode: the filtered view
        """

    def valid_layers(self, names: list[str]) -> PathFromNode:
        """
         Return a view of PathFromNode containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             PathFromNode: The layered view
        """

    def window(self, start: TimeInput | None, end: TimeInput | None) -> PathFromNode:
        """
         Create a view of the PathFromNode including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
            PathFromNode:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this PathFromNode

        Returns:
            Optional[int]:
        """

class PathFromGraph(object): 

    def __bool__(self):
        """True if self else False"""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> PathFromGraph:
        """
         Create a view of the PathFromGraph including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             PathFromGraph:
        """

    def at(self, time: TimeInput) -> PathFromGraph:
        """
         Create a view of the PathFromGraph including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             PathFromGraph:
        """

    def before(self, end: TimeInput) -> PathFromGraph:
        """
         Create a view of the PathFromGraph including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             PathFromGraph:
        """

    def collect(self) -> list[list[Node]]:
        """
         Collect all nodes into a list

        Returns:
             list[list[Node]]: the list of nodes
        """

    def default_layer(self) -> PathFromGraph:
        """
         Return a view of PathFromGraph containing only the default edge layer
        Returns:
             PathFromGraph: The layered view
        """

    def degree(self):
        """the node degrees"""

    @property
    def earliest_date_time(self):
        """Returns the earliest date time of the nodes."""

    @property
    def earliest_time(self):
        """the node earliest times"""

    def edge_history_count(self):
        """Returns the number of edge updates for each node"""

    @property
    def edges(self) -> NestedEdges:
        """
        Get the edges that are incident to this node.

        Returns:

             NestedEdges: The incident edges.
        """

    @property
    def end(self) -> Optional[int]:
        """
         Gets the latest time that this PathFromGraph is valid.

        Returns:
           Optional[int]: The latest time that this PathFromGraph is valid or None if the PathFromGraph is valid for all times.
        """

    @property
    def end_date_time(self) -> Optional[datetime]:
        """
         Gets the latest datetime that this PathFromGraph is valid

        Returns:
             Optional[datetime]: The latest datetime that this PathFromGraph is valid or None if the PathFromGraph is valid for all times.
        """

    def exclude_layer(self, name: str) -> PathFromGraph:
        """
         Return a view of PathFromGraph containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             PathFromGraph: The layered view
        """

    def exclude_layers(self, names: list[str]) -> PathFromGraph:
        """
         Return a view of PathFromGraph containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             PathFromGraph: The layered view
        """

    def exclude_valid_layer(self, name: str) -> PathFromGraph:
        """
         Return a view of PathFromGraph containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             PathFromGraph: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> PathFromGraph:
        """
         Return a view of PathFromGraph containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             PathFromGraph: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def filter_edges(self, filter: filter.FilterExpr) -> PathFromGraph:
        """
        Return a filtered view that only includes edges that satisfy the filter

        Arguments:
            filter (filter.FilterExpr): The filter to apply to the edges.

        Returns:
            PathFromGraph: The filtered view
        """

    def filter_exploded_edges(self, filter: filter.FilterExpr) -> PathFromGraph:
        """
        Return a filtered view that only includes exploded edges that satisfy the filter

        Arguments:
            filter (filter.FilterExpr): The filter to apply to the exploded edge properties.

        Returns:
            PathFromGraph: The filtered view
        """

    def filter_nodes(self, filter: filter.FilterExpr) -> PathFromGraph:
        """
        Return a filtered view that only includes nodes that satisfy the filter

        Arguments:
            filter (filter.FilterExpr): The filter to apply to the nodes.

        Returns:
            PathFromGraph: The filtered view
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if PathFromGraph has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def history(self):
        """Returns all timestamps of nodes, when an node is added or change to an node is made."""

    def history_date_time(self):
        """Returns all timestamps of nodes, when an node is added or change to an node is made."""

    @property
    def id(self):
        """the node ids"""

    def in_degree(self):
        """the node in-degrees"""

    @property
    def in_edges(self) -> NestedEdges:
        """
        Get the edges that point into this node.

        Returns:

             NestedEdges: The inbound edges.
        """

    @property
    def in_neighbours(self) -> PathFromGraph:
        """
        Get the neighbours of this node that point into this node.

        Returns:

             PathFromGraph: The in-neighbours.
        """

    def latest(self) -> PathFromGraph:
        """
         Create a view of the PathFromGraph including all events at the latest time.

        Returns:
             PathFromGraph:
        """

    @property
    def latest_date_time(self):
        """Returns the latest date time of the nodes."""

    @property
    def latest_time(self):
        """the node latest times"""

    def layer(self, name: str) -> PathFromGraph:
        """
         Return a view of PathFromGraph containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             PathFromGraph: The layered view
        """

    def layers(self, names: list[str]) -> PathFromGraph:
        """
         Return a view of PathFromGraph containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             PathFromGraph: The layered view
        """

    @property
    def metadata(self):
        """the node metadata"""

    @property
    def name(self):
        """the node names"""

    @property
    def neighbours(self) -> PathFromGraph:
        """
        Get the neighbours of this node.

        Returns:

             PathFromGraph: The neighbours (both inbound and outbound).
        """

    @property
    def node_type(self):
        """the node types"""

    def out_degree(self):
        """the node out-degrees"""

    @property
    def out_edges(self) -> NestedEdges:
        """
        Get the edges that point out of this node.

        Returns:

             NestedEdges: The outbound edges.
        """

    @property
    def out_neighbours(self) -> PathFromGraph:
        """
        Get the neighbours of this node that point out of this node.

        Returns:

             PathFromGraph: The out-neighbours.
        """

    @property
    def properties(self):
        """the node properties"""

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> PathFromGraph:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             PathFromGraph:
        """

    def shrink_start(self, start: TimeInput) -> PathFromGraph:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             PathFromGraph:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> PathFromGraph:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             PathFromGraph:
        """

    def snapshot_at(self, time: TimeInput) -> PathFromGraph:
        """
         Create a view of the PathFromGraph including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             PathFromGraph:
        """

    def snapshot_latest(self) -> PathFromGraph:
        """
         Create a view of the PathFromGraph including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             PathFromGraph:
        """

    @property
    def start(self) -> Optional[int]:
        """
         Gets the start time for rolling and expanding windows for this PathFromGraph

        Returns:
            Optional[int]: The earliest time that this PathFromGraph is valid or None if the PathFromGraph is valid for all times.
        """

    @property
    def start_date_time(self) -> Optional[datetime]:
        """
         Gets the earliest datetime that this PathFromGraph is valid

        Returns:
             Optional[datetime]: The earliest datetime that this PathFromGraph is valid or None if the PathFromGraph is valid for all times.
        """

    def type_filter(self, node_types: list[str]) -> PathFromGraph:
        """
        filter nodes by type

        Arguments:
            node_types (list[str]): the node types to keep

        Returns:
            PathFromGraph: the filtered view
        """

    def valid_layers(self, names: list[str]) -> PathFromGraph:
        """
         Return a view of PathFromGraph containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             PathFromGraph: The layered view
        """

    def window(self, start: TimeInput | None, end: TimeInput | None) -> PathFromGraph:
        """
         Create a view of the PathFromGraph including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
            PathFromGraph:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this PathFromGraph

        Returns:
            Optional[int]:
        """

class MutableNode(Node): 

    def __repr__(self):
        """Return repr(self)."""

    def add_metadata(self, metadata: PropInput):
        """
        Add metadata to a node in the graph.
        This function is used to add properties to a node that do not
        change over time. These properties are fundamental attributes of the node.

        Parameters:
            metadata (PropInput): A dictionary of properties to be added to the node. Each key is a string representing the property name, and each value is of type Prop representing the property value.
        """

    def add_updates(self, t: TimeInput, properties: Optional[PropInput] = None, secondary_index: Optional[int] = None) -> None:
        """
        Add updates to a node in the graph at a specified time.
        This function allows for the addition of property updates to a node within the graph. The updates are time-stamped, meaning they are applied at the specified time.

        Parameters:
           t (TimeInput): The timestamp at which the updates should be applied.
           properties (PropInput, optional): A dictionary of properties to update. Each key is a
                                             string representing the property name, and each value
                                             is of type Prop representing the property value.
                                             If None, no properties are updated.
           secondary_index (int, optional): The optional integer which will be used as a secondary index

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def set_node_type(self, new_type: str):
        """
        Set the type on the node. This only works if the type has not been previously set, otherwise will
        throw an error

        Parameters:
            new_type (str): The new type to be set
        """

    def update_metadata(self, metadata: PropInput):
        """
        Update metadata of a node in the graph overwriting existing values.
        This function is used to add properties to a node that do not
        change over time. These properties are fundamental attributes of the node.

        Parameters:
            metadata (PropInput): A dictionary of properties to be added to the node. Each key is a string representing the property name, and each value is of type Prop representing the property value.
        """

class Edge(object): 
    """
    PyEdge is a Python class that represents an edge in the graph.
    An edge is a directed connection between two nodes.
    """

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __hash__(self):
        """Return hash(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> Edge:
        """
         Create a view of the Edge including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             Edge:
        """

    def at(self, time: TimeInput) -> Edge:
        """
         Create a view of the Edge including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             Edge:
        """

    def before(self, end: TimeInput) -> Edge:
        """
         Create a view of the Edge including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             Edge:
        """

    @property
    def date_time(self) -> datetime:
        """
        Gets the datetime of an exploded edge.

        Returns:
            datetime: the datetime of an exploded edge
        """

    def default_layer(self) -> Edge:
        """
         Return a view of Edge containing only the default edge layer
        Returns:
             Edge: The layered view
        """

    def deletions(self) -> List[int]:
        """
        Returns a list of timestamps of when an edge is deleted

        Returns:
            List[int]: A list of unix timestamps
        """

    def deletions_data_time(self):
        """
        Returns a list of timestamps of when an edge is deleted

        Returns:
            List[datetime]
        """

    @property
    def dst(self):
        """Returns the destination node of the edge."""

    @property
    def earliest_date_time(self) -> datetime:
        """
        Gets of earliest datetime of an edge.

        Returns:
            datetime: the earliest datetime of an edge
        """

    @property
    def earliest_time(self) -> int:
        """
        Gets the earliest time of an edge.

        Returns:
            int: The earliest time of an edge
        """

    @property
    def end(self) -> Optional[int]:
        """
         Gets the latest time that this Edge is valid.

        Returns:
           Optional[int]: The latest time that this Edge is valid or None if the Edge is valid for all times.
        """

    @property
    def end_date_time(self) -> Optional[datetime]:
        """
         Gets the latest datetime that this Edge is valid

        Returns:
             Optional[datetime]: The latest datetime that this Edge is valid or None if the Edge is valid for all times.
        """

    def exclude_layer(self, name: str) -> Edge:
        """
         Return a view of Edge containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             Edge: The layered view
        """

    def exclude_layers(self, names: list[str]) -> Edge:
        """
         Return a view of Edge containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             Edge: The layered view
        """

    def exclude_valid_layer(self, name: str) -> Edge:
        """
         Return a view of Edge containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             Edge: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> Edge:
        """
         Return a view of Edge containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             Edge: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def explode(self):
        """Explodes returns an edge object for each update within the original edge."""

    def explode_layers(self):
        """Explode layers returns an edge object for each layer within the original edge. These new edge object contains only updates from respective layers."""

    def has_layer(self, name: str) -> bool:
        """
         Check if Edge has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def history(self) -> List[int]:
        """
        Returns a list of timestamps of when an edge is added or change to an edge is made.

        Returns:
           List[int]:  A list of unix timestamps.

        """

    def history_counts(self) -> int:
        """
        Returns the number of times an edge is added or change to an edge is made.

        Returns:
           int: The number of times an edge is added or change to an edge is made.

        """

    def history_date_time(self):
        """
        Returns a list of timestamps of when an edge is added or change to an edge is made.

        Returns:
            List[datetime]

        """

    @property
    def id(self):
        """The id of the edge."""

    def is_active(self) -> bool:
        """
        Check if the edge is currently active (i.e., has at least one update within this period)
        Returns:
            bool:
        """

    def is_deleted(self) -> bool:
        """
        Check if the edge is currently deleted
        Returns:
            bool:
        """

    def is_self_loop(self) -> bool:
        """
        Check if the edge is on the same node
        Returns:
            bool:
        """

    def is_valid(self) -> bool:
        """
        Check if the edge is currently valid (i.e., not deleted)
        Returns:
            bool:
        """

    def latest(self) -> Edge:
        """
         Create a view of the Edge including all events at the latest time.

        Returns:
             Edge:
        """

    @property
    def latest_date_time(self) -> datetime:
        """
        Gets of latest datetime of an edge.

        Returns:
            datetime: the latest datetime of an edge
        """

    @property
    def latest_time(self) -> int:
        """
        Gets the latest time of an edge.

        Returns:
            int: The latest time of an edge
        """

    def layer(self, name: str) -> Edge:
        """
         Return a view of Edge containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             Edge: The layered view
        """

    @property
    def layer_name(self) -> str:
        """
        Gets the name of the layer this edge belongs to - assuming it only belongs to one layer

        Returns:
            str: The name of the layer
        """

    @property
    def layer_names(self):
        """
        Gets the names of the layers this edge belongs to

        Returns:
            List[str]-  The name of the layer
        """

    def layers(self, names: list[str]) -> Edge:
        """
         Return a view of Edge containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             Edge: The layered view
        """

    @property
    def metadata(self) -> Metadata:
        """
        Gets the metadata of an edge

        Returns:
            Metadata:
        """

    @property
    def nbr(self):
        """Returns the node at the other end of the edge (same as `dst()` for out-edges and `src()` for in-edges)"""

    @property
    def properties(self) -> Properties:
        """
        Returns a view of the properties of the edge.

        Returns:
          Properties: Properties on the Edge.
        """

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> Edge:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             Edge:
        """

    def shrink_start(self, start: TimeInput) -> Edge:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             Edge:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> Edge:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             Edge:
        """

    def snapshot_at(self, time: TimeInput) -> Edge:
        """
         Create a view of the Edge including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             Edge:
        """

    def snapshot_latest(self) -> Edge:
        """
         Create a view of the Edge including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             Edge:
        """

    @property
    def src(self):
        """Returns the source node of the edge."""

    @property
    def start(self) -> Optional[int]:
        """
         Gets the start time for rolling and expanding windows for this Edge

        Returns:
            Optional[int]: The earliest time that this Edge is valid or None if the Edge is valid for all times.
        """

    @property
    def start_date_time(self) -> Optional[datetime]:
        """
         Gets the earliest datetime that this Edge is valid

        Returns:
             Optional[datetime]: The earliest datetime that this Edge is valid or None if the Edge is valid for all times.
        """

    @property
    def time(self) -> int:
        """
        Gets the time of an exploded edge.

        Returns:
            int: The time of an exploded edge
        """

    def valid_layers(self, names: list[str]) -> Edge:
        """
         Return a view of Edge containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             Edge: The layered view
        """

    def window(self, start: TimeInput | None, end: TimeInput | None) -> Edge:
        """
         Create a view of the Edge including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
            Edge:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this Edge

        Returns:
            Optional[int]:
        """

class Edges(object): 
    """A list of edges that can be iterated over."""

    def __bool__(self):
        """True if self else False"""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> Edges:
        """
         Create a view of the Edges including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             Edges:
        """

    def at(self, time: TimeInput) -> Edges:
        """
         Create a view of the Edges including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             Edges:
        """

    def before(self, end: TimeInput) -> Edges:
        """
         Create a view of the Edges including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             Edges:
        """

    def collect(self) -> list[Edge]:
        """
         Collect all edges into a list

        Returns:
             list[Edge]: the list of edges
        """

    def count(self):
        """Returns the number of edges"""

    @property
    def date_time(self):
        """
        Returns the date times of exploded edges

        Returns:
           A list of date times.
        """

    def default_layer(self) -> Edges:
        """
         Return a view of Edges containing only the default edge layer
        Returns:
             Edges: The layered view
        """

    def deletions(self):
        """
        Returns all timestamps of edges where an edge is deleted

        Returns:
            A list of lists of unix timestamps
        """

    def deletions_date_time(self):
        """
        Returns all timestamps of edges where an edge is deleted

        Returns:
            A list of lists of DateTime objects
        """

    @property
    def dst(self):
        """Returns the destination node of the edge."""

    @property
    def earliest_date_time(self):
        """
        Returns the earliest date time of the edges.

        Returns:
         Earliest date time of the edges.
        """

    @property
    def earliest_time(self):
        """
        Returns the earliest time of the edges.

        Returns:
        Earliest time of the edges.
        """

    @property
    def end(self) -> Optional[int]:
        """
         Gets the latest time that this Edges is valid.

        Returns:
           Optional[int]: The latest time that this Edges is valid or None if the Edges is valid for all times.
        """

    @property
    def end_date_time(self) -> Optional[datetime]:
        """
         Gets the latest datetime that this Edges is valid

        Returns:
             Optional[datetime]: The latest datetime that this Edges is valid or None if the Edges is valid for all times.
        """

    def exclude_layer(self, name: str) -> Edges:
        """
         Return a view of Edges containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             Edges: The layered view
        """

    def exclude_layers(self, names: list[str]) -> Edges:
        """
         Return a view of Edges containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             Edges: The layered view
        """

    def exclude_valid_layer(self, name: str) -> Edges:
        """
         Return a view of Edges containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             Edges: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> Edges:
        """
         Return a view of Edges containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             Edges: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def explode(self):
        """Explodes returns an edge object for each update within the original edge."""

    def explode_layers(self):
        """Explode layers returns an edge object for each layer within the original edge. These new edge object contains only updates from respective layers."""

    def has_layer(self, name: str) -> bool:
        """
         Check if Edges has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def history(self):
        """
        Returns all timestamps of edges, when an edge is added or change to an edge is made.

        Returns:
           A list of lists unix timestamps.

        """

    def history_counts(self):
        ...

    def history_date_time(self):
        """
        Returns all timestamps of edges, when an edge is added or change to an edge is made.

        Returns:
           A list of lists of timestamps.

        """

    @property
    def id(self):
        """Returns all ids of the edges."""

    def is_active(self):
        ...

    def is_deleted(self):
        """Check if the edges are deleted"""

    def is_self_loop(self):
        """Check if the edges are on the same node"""

    def is_valid(self):
        """Check if the edges are valid (i.e. not deleted)"""

    def latest(self) -> Edges:
        """
         Create a view of the Edges including all events at the latest time.

        Returns:
             Edges:
        """

    @property
    def latest_date_time(self):
        """
        Returns the latest date time of the edges.

        Returns:
          Latest date time of the edges.
        """

    @property
    def latest_time(self):
        """
        Returns the latest time of the edges.

        Returns:
         Latest time of the edges.
        """

    def layer(self, name: str) -> Edges:
        """
         Return a view of Edges containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             Edges: The layered view
        """

    @property
    def layer_name(self):
        """
        Get the layer name that all edges belong to - assuming they only belong to one layer

        Returns:
         The name of the layer
        """

    @property
    def layer_names(self):
        """
        Get the layer names that all edges belong to - assuming they only belong to one layer

        Returns:
          A list of layer names
        """

    def layers(self, names: list[str]) -> Edges:
        """
         Return a view of Edges containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             Edges: The layered view
        """

    @property
    def metadata(self):
        """
        Returns all the metadata of the edges

        Returns:
            MetadataView:
        """

    @property
    def nbr(self):
        """Returns the node at the other end of the edge (same as `dst()` for out-edges and `src()` for in-edges)"""

    @property
    def properties(self) -> PropertiesView:
        """
        Returns all properties of the edges

        Returns:
            PropertiesView:
        """

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> Edges:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             Edges:
        """

    def shrink_start(self, start: TimeInput) -> Edges:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             Edges:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> Edges:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             Edges:
        """

    def snapshot_at(self, time: TimeInput) -> Edges:
        """
         Create a view of the Edges including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             Edges:
        """

    def snapshot_latest(self) -> Edges:
        """
         Create a view of the Edges including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             Edges:
        """

    @property
    def src(self):
        """Returns the source node of the edge."""

    @property
    def start(self) -> Optional[int]:
        """
         Gets the start time for rolling and expanding windows for this Edges

        Returns:
            Optional[int]: The earliest time that this Edges is valid or None if the Edges is valid for all times.
        """

    @property
    def start_date_time(self) -> Optional[datetime]:
        """
         Gets the earliest datetime that this Edges is valid

        Returns:
             Optional[datetime]: The earliest datetime that this Edges is valid or None if the Edges is valid for all times.
        """

    @property
    def time(self):
        """
        Returns the times of exploded edges

        Returns:
          Time of edge
        """

    def to_df(self, include_property_history: bool = True, convert_datetime: bool = False, explode: bool = False) -> DataFrame:
        """
        Converts the graph's edges into a Pandas DataFrame.

        This method will create a DataFrame with the following columns:
        - "src": The source node of the edge.
        - "dst": The destination node of the edge.
        - "layer": The layer of the edge.
        - "properties": The properties of the edge.
        - "update_history": The update history of the edge. This column will be included if `include_update_history` is set to `true`.

        Args:
            include_property_history (bool): A boolean, if set to `True`, the history of each property is included, if `False`, only the latest value is shown. Ignored if exploded. Defaults to True.
            convert_datetime (bool): A boolean, if set to `True` will convert the timestamp to python datetimes. Defaults to False.
            explode (bool): A boolean, if set to `True`, will explode each edge update into its own row. Defaults to False.

        Returns:
            DataFrame: If successful, this PyObject will be a Pandas DataFrame.
        """

    def valid_layers(self, names: list[str]) -> Edges:
        """
         Return a view of Edges containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             Edges: The layered view
        """

    def window(self, start: TimeInput | None, end: TimeInput | None) -> Edges:
        """
         Create a view of the Edges including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
            Edges:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this Edges

        Returns:
            Optional[int]:
        """

class NestedEdges(object): 

    def __bool__(self):
        """True if self else False"""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> NestedEdges:
        """
         Create a view of the NestedEdges including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             NestedEdges:
        """

    def at(self, time: TimeInput) -> NestedEdges:
        """
         Create a view of the NestedEdges including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             NestedEdges:
        """

    def before(self, end: TimeInput) -> NestedEdges:
        """
         Create a view of the NestedEdges including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             NestedEdges:
        """

    def collect(self) -> list[list[Edges]]:
        """
         Collect all edges into a list

        Returns:
             list[list[Edges]]: the list of edges
        """

    @property
    def date_time(self):
        """Get the date times of exploded edges"""

    def default_layer(self) -> NestedEdges:
        """
         Return a view of NestedEdges containing only the default edge layer
        Returns:
             NestedEdges: The layered view
        """

    def deletions(self):
        """
        Returns all timestamps of edges, where an edge is deleted

        Returns:
            A list of lists of lists of unix timestamps
        """

    def deletions_date_time(self):
        """
        Returns all timestamps of edges, where an edge is deleted

        Returns:
            A list of lists of lists of DateTime objects
        """

    @property
    def dst(self):
        """Returns the destination node of the edge."""

    @property
    def earliest_date_time(self):
        """Returns the earliest date time of the edges."""

    @property
    def earliest_time(self):
        """Returns the earliest time of the edges."""

    @property
    def end(self) -> Optional[int]:
        """
         Gets the latest time that this NestedEdges is valid.

        Returns:
           Optional[int]: The latest time that this NestedEdges is valid or None if the NestedEdges is valid for all times.
        """

    @property
    def end_date_time(self) -> Optional[datetime]:
        """
         Gets the latest datetime that this NestedEdges is valid

        Returns:
             Optional[datetime]: The latest datetime that this NestedEdges is valid or None if the NestedEdges is valid for all times.
        """

    def exclude_layer(self, name: str) -> NestedEdges:
        """
         Return a view of NestedEdges containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             NestedEdges: The layered view
        """

    def exclude_layers(self, names: list[str]) -> NestedEdges:
        """
         Return a view of NestedEdges containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             NestedEdges: The layered view
        """

    def exclude_valid_layer(self, name: str) -> NestedEdges:
        """
         Return a view of NestedEdges containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             NestedEdges: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> NestedEdges:
        """
         Return a view of NestedEdges containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             NestedEdges: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def explode(self):
        """Explodes returns an edge object for each update within the original edge."""

    def explode_layers(self):
        """Explode layers returns an edge object for each layer within the original edge. These new edge object contains only updates from respective layers."""

    def has_layer(self, name: str) -> bool:
        """
         Check if NestedEdges has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def history(self):
        """Returns all timestamps of edges, when an edge is added or change to an edge is made."""

    def history_date_time(self):
        """Returns all timestamps of edges, when an edge is added or change to an edge is made."""

    @property
    def id(self):
        """Returns all ids of the edges."""

    def is_active(self):
        ...

    def is_deleted(self):
        """Check if edges are deleted"""

    def is_self_loop(self):
        """Check if the edges are on the same node"""

    def is_valid(self):
        """Check if edges are valid (i.e., not deleted)"""

    def latest(self) -> NestedEdges:
        """
         Create a view of the NestedEdges including all events at the latest time.

        Returns:
             NestedEdges:
        """

    @property
    def latest_date_time(self):
        """Returns the latest date time of the edges."""

    @property
    def latest_time(self):
        """Returns the latest time of the edges."""

    def layer(self, name: str) -> NestedEdges:
        """
         Return a view of NestedEdges containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             NestedEdges: The layered view
        """

    @property
    def layer_name(self):
        """Returns the name of the layer the edges belong to - assuming they only belong to one layer"""

    @property
    def layer_names(self):
        """Returns the names of the layers the edges belong to"""

    def layers(self, names: list[str]) -> NestedEdges:
        """
         Return a view of NestedEdges containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             NestedEdges: The layered view
        """

    @property
    def metadata(self):
        """Get a view of the metadata only."""

    @property
    def nbr(self):
        """Returns the node at the other end of the edge (same as `dst()` for out-edges and `src()` for in-edges)"""

    @property
    def properties(self):
        """Returns all properties of the edges"""

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> NestedEdges:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             NestedEdges:
        """

    def shrink_start(self, start: TimeInput) -> NestedEdges:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             NestedEdges:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> NestedEdges:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             NestedEdges:
        """

    def snapshot_at(self, time: TimeInput) -> NestedEdges:
        """
         Create a view of the NestedEdges including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             NestedEdges:
        """

    def snapshot_latest(self) -> NestedEdges:
        """
         Create a view of the NestedEdges including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             NestedEdges:
        """

    @property
    def src(self):
        """Returns the source node of the edge."""

    @property
    def start(self) -> Optional[int]:
        """
         Gets the start time for rolling and expanding windows for this NestedEdges

        Returns:
            Optional[int]: The earliest time that this NestedEdges is valid or None if the NestedEdges is valid for all times.
        """

    @property
    def start_date_time(self) -> Optional[datetime]:
        """
         Gets the earliest datetime that this NestedEdges is valid

        Returns:
             Optional[datetime]: The earliest datetime that this NestedEdges is valid or None if the NestedEdges is valid for all times.
        """

    @property
    def time(self):
        """Returns the times of exploded edges"""

    def valid_layers(self, names: list[str]) -> NestedEdges:
        """
         Return a view of NestedEdges containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             NestedEdges: The layered view
        """

    def window(self, start: TimeInput | None, end: TimeInput | None) -> NestedEdges:
        """
         Create a view of the NestedEdges including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
            NestedEdges:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this NestedEdges

        Returns:
            Optional[int]:
        """

class MutableEdge(Edge): 

    def __repr__(self):
        """Return repr(self)."""

    def add_metadata(self, metadata: PropInput, layer: Optional[str] = None):
        """
        Add metadata to an edge in the graph.
        This function is used to add properties to an edge that do not
        change over time. These properties are fundamental attributes of the edge.

        Parameters:
            metadata (PropInput): A dictionary of properties to be added to the edge.
            layer (str, optional): The layer you want these properties to be added on to.
        """

    def add_updates(self, t: TimeInput, properties: Optional[PropInput] = None, layer: Optional[str] = None, secondary_index: Optional[int] = None) -> None:
        """
        Add updates to an edge in the graph at a specified time.
        This function allows for the addition of property updates to an edge within the graph. The updates are time-stamped, meaning they are applied at the specified time.

        Parameters:
           t (TimeInput): The timestamp at which the updates should be applied.
           properties (PropInput, optional): A dictionary of properties to update.
           layer (str, optional): The layer you want these properties to be added on to.
           secondary_index (int, optional): The optional integer which will be used as a secondary index

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def delete(self, t: TimeInput, layer: Optional[str] = None):
        """
        Mark the edge as deleted at the specified time.

        Parameters:
            t (TimeInput): The timestamp at which the deletion should be applied.
            layer (str, optional): The layer you want the deletion applied to .
        """

    def update_metadata(self, metadata: PropInput, layer: Optional[str] = None):
        """
        Update metadata of an edge in the graph overwriting existing values.
        This function is used to add properties to an edge that does not
        change over time. These properties are fundamental attributes of the edge.

        Parameters:
            metadata (PropInput): A dictionary of properties to be added to the edge.
            layer (str, optional): The layer you want these properties to be added on to.
        """

class Properties(object): 
    """A view of the properties of an entity"""

    def __contains__(self, key):
        """Return bool(key in self)."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def as_dict(self):
        """Convert properties view to a dict"""

    def get(self, key):
        """
        Get property value.

        First searches temporal properties and returns latest value if it exists.
        If not, it falls back to static properties.
        """

    def items(self):
        """Get a list of key-value pairs"""

    def keys(self):
        """Get the names for all properties (includes temporal and static properties)"""

    @property
    def temporal(self):
        """Get a view of the temporal properties only."""

    def values(self):
        """Get the values of the properties"""

class Metadata(object): 
    """A view of metadata of an entity"""

    def __contains__(self, key):
        """Return bool(key in self)."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def as_dict(self) -> dict[str, PropValue]:
        """
        as_dict() -> dict[str, Any]

        convert the properties view to a python dict

        Returns:
            dict[str, PropValue]:
        """

    def get(self, key: str):
        """
        get property value by key

        Arguments:
            key (str): the name of the property

        Returns:
            PropValue | None: the property value or `None` if value for `key` does not exist
        """

    def items(self) -> list[Tuple[str, PropValue]]:
        """
        lists the property keys together with the corresponding value

        Returns:
            list[Tuple[str, PropValue]]: the property keys with corresponding values
        """

    def keys(self) -> list[str]:
        """
        lists the available property keys

        Returns:
            list[str]: the property keys
        """

    def values(self):
        """
        lists the property values

        Returns:
            list | Array: the property values
        """

class TemporalProperties(object): 
    """A view of the temporal properties of an entity"""

    def __contains__(self, key):
        """Return bool(key in self)."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def get(self, key) -> TemporalProp:
        """
        Get property value for `key` if it exists

        Returns:
            TemporalProp: the property view if it exists, otherwise `None`
        """

    def histories(self) -> dict[str, list[Tuple[int, PropValue]]]:
        """
        Get the histories of all properties

        Returns:
            dict[str, list[Tuple[int, PropValue]]]: the mapping of property keys to histories
        """

    def histories_date_time(self) -> dict[str, list[Tuple[datetime, PropValue]]]:
        """
        Get the histories of all properties

        Returns:
            dict[str, list[Tuple[datetime, PropValue]]]: the mapping of property keys to histories
        """

    def items(self):
        """List the property keys together with the corresponding values"""

    def keys(self):
        """List the available property keys"""

    def latest(self) -> dict[str, PropValue]:
        """
        Get the latest value of all properties

        Returns:
            dict[str, PropValue]: the mapping of property keys to latest values
        """

    def values(self) -> list[TemporalProp]:
        """
        List the values of the properties

        Returns:
            list[TemporalProp]: the list of property views
        """

class PropertiesView(object): 

    def __contains__(self, key):
        """Return bool(key in self)."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def as_dict(self):
        """Convert properties view to a dict"""

    def get(self, key):
        """Get property value."""

    def items(self):
        """Get a list of key-value pairs"""

    def keys(self):
        """Get the names for all properties"""

    @property
    def temporal(self):
        """Get a view of the temporal properties only."""

    def values(self):
        """Get the values of the properties"""

class TemporalProp(object): 
    """A view of a temporal property"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def at(self, t):
        """Get the value of the property at time `t`"""

    def average(self) -> PropValue:
        """
        Compute the average of all property values. Alias for mean().

        Returns:
            PropValue: The average of each property values, or None if count is zero.
        """

    def count(self) -> int:
        """
        Count the number of properties.

        Returns:
            int: The number of properties.
        """

    def history(self):
        """Get the timestamps at which the property was updated"""

    def history_date_time(self):
        """Get the timestamps at which the property was updated"""

    def items(self):
        """List update timestamps and corresponding property values"""

    def items_date_time(self):
        """List update timestamps and corresponding property values"""

    def max(self) -> Tuple[int, PropValue]:
        """
        Find the maximum property value and its associated time.

        Returns:
            Tuple[int, PropValue]: A tuple containing the time and the maximum property value.
        """

    def mean(self) -> PropValue:
        """
        Compute the mean of all property values. Alias for mean().

        Returns:
            PropValue: The mean of each property values, or None if count is zero.
        """

    def median(self) -> Tuple[int, PropValue]:
        """
        Compute the median of all property values.

        Returns:
            Tuple[int, PropValue]: A tuple containing the time and the median property value, or None if empty
        """

    def min(self) -> Tuple[int, PropValue]:
        """
        Find the minimum property value and its associated time.

        Returns:
            Tuple[int, PropValue]: A tuple containing the time and the minimum property value.
        """

    def ordered_dedupe(self, latest_time):
        """List of ordered deduplicated property values"""

    def sum(self) -> PropValue:
        """
        Compute the sum of all property values.

        Returns:
            PropValue: The sum of all property values.
        """

    def unique(self):
        """List of unique property values"""

    def value(self):
        """Get the latest value of the property"""

    def values(self):
        """Get the property values for each update"""

class WindowSet(object): 

    def __iter__(self):
        """Implement iter(self)."""

    def time_index(self, center: bool = False) -> Iterable:
        """
        Returns the time index of this window set

        It uses the last time of each window as the reference or the center of each if `center` is
        set to `True`

        Arguments:
            center (bool): if True time indexes are centered. Defaults to False

        Returns:
            Iterable: the time index"
        """

class IndexSpecBuilder(object): 

    def __new__(cls, graph) -> IndexSpecBuilder:
        """Create and return a new object.  See help(type) for accurate signature."""

    def build(self):
        ...

    def with_all_edge_metadata(self):
        ...

    def with_all_edge_properties(self):
        ...

    def with_all_edge_properties_and_metadata(self):
        ...

    def with_all_node_metadata(self):
        ...

    def with_all_node_properties(self):
        ...

    def with_all_node_properties_and_metadata(self):
        ...

    def with_edge_metadata(self, props):
        ...

    def with_edge_properties(self, props):
        ...

    def with_node_metadata(self, props):
        ...

    def with_node_properties(self, props):
        ...

class IndexSpec(object): 

    def __repr__(self):
        """Return repr(self)."""

    @property
    def edge_metadata(self):
        ...

    @property
    def edge_properties(self):
        ...

    @property
    def node_metadata(self):
        ...

    @property
    def node_properties(self):
        ...

def version():
    ...
