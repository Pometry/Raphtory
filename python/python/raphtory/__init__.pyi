###############################################################################
#                                                                             #
#                      AUTOGENERATED TYPE STUB FILE                           #
#                                                                             #
#    This file was automatically generated. Do not modify it directly.        #
#    Any changes made here may be lost when the file is regenerated.          #
#                                                                             #
###############################################################################

from typing import *
from raphtory import *
from raphtory.algorithms import *
from raphtory.vectors import *
from raphtory.node_state import *
from raphtory.graphql import *
from raphtory.typing import *
from datetime import datetime
from pandas import DataFrame

class AlgorithmResult(object):
    def __len__(self):
        """Return len(self)."""

    def __repr__(self):
        """Return repr(self)."""

    def get(self, key: Any):
        """
        Returns the value corresponding to the provided key

        Arguments:
            key: The key of type `H` for which the value is to be retrieved.
        """

    def get_all(self):
        """
        Returns a Dict containing all the nodes (as keys) and their corresponding values (values) or none.

        Returns:
            A dict of nodes and their values
        """

    def get_all_values(self):
        """Returns a a list of all values"""

    def get_all_with_names(self):
        """
        Returns a dict with node names and values

        Returns:
            a dict with node names and values
        """

    def group_by(self):
        """
        Groups the `AlgorithmResult` by its values.

        Returns:
            A `HashMap` where keys are unique values from the `AlgorithmResult` and values are vectors
            containing keys of type `H` that share the same value.
        """

    def max(self):
        """Returns a tuple of the max result with its key"""

    def median(self):
        """Returns a tuple of the median result with its key"""

    def min(self):
        """Returns a tuple of the min result with its key"""

    def sort_by_node(self, reverse: Any = True):
        """
        Sorts by node id in ascending or descending order.

        Arguments:
            reverse: If `true`, sorts the result in descending order; otherwise, sorts in ascending order. Defaults to True.

        Returns:
            A sorted list of tuples containing node names and values.
        """

    def sort_by_node_name(self, reverse: bool = True):
        """
        The function `sort_by_node_name` sorts a vector of tuples containing a node and an optional
        value by the node name in either ascending or descending order.

        Arguments:
            reverse (bool): A boolean value indicating whether the sorting should be done in reverse order or not. Defaults to True.
                If reverse is true, the sorting will be done in descending order, otherwise it will be done in
                ascending order.

        Returns:
            The function sort_by_node_name returns a vector of tuples. Each tuple contains a Node and value
        """

    def sort_by_value(self, reverse: bool = True):
        """
        Sorts the `AlgorithmResult` by its values in ascending or descending order.

        Arguments:
            reverse (bool): If `true`, sorts the result in descending order, otherwise, sorts in ascending order. Defaults to True.

        Returns:
            A sorted vector of tuples containing keys of type `H` and values of type `Y`.
        """

    def to_df(self) -> DataFrame:
        """
        Creates a dataframe from the result

        Returns:
            DataFrame: A `pandas.DataFrame` containing the result
        """

    def to_string(self):
        """Returns a formatted string representation of the algorithm."""

    def top_k(self, k: int, percentage: bool = False, reverse: bool = True):
        """
        Retrieves the top-k elements from the `AlgorithmResult` based on its values.

        Arguments:
            k (int): The number of elements to retrieve.
            percentage (bool): If `True`, the `k` parameter is treated as a percentage of total elements. Defaults to False.
            reverse (bool): If `True`, retrieves the elements in descending order, otherwise, in ascending order. Defaults to True.

        Returns:
            An Option containing a vector of tuples with keys of type `H` and values of type `Y`.
            If percentage is true, the returned vector contains the top `k` percentage of elements.
            If percentage is false, the returned vector contains the top `k` elements.
            Returns None if the result is empty or if `k` is 0.
        """

class ConstProperties(object):
    """A view of constant properties of an entity"""

    def __contains__(self, key):
        """Return key in self."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def as_dict(self):
        """
        as_dict() -> dict[str, Any]

        convert the properties view to a python dict
        """

    def get(self, key: Any):
        """
        get(key: str) -> Any | None

        Arguments:
            key: the name of the property

        get property value by key (returns `None` if key does not exist)
        """

    def items(self):
        """
        items() -> list[tuple[str, Any]]

        lists the property keys together with the corresponding value
        """

    def keys(self):
        """
        keys() -> list[str]

        lists the available property keys
        """

    def values(self):
        """
        values() -> list[Any]

        lists the property values
        """

class DiskGraphStorage(object):
    def __repr__(self):
        """Return repr(self)."""

    def append_node_temporal_properties(self, location, chunk_size=20000000): ...
    def graph_dir(self): ...
    @staticmethod
    def load_from_dir(graph_dir): ...
    @staticmethod
    def load_from_pandas(graph_dir, edge_df, time_col, src_col, dst_col): ...
    @staticmethod
    def load_from_parquets(
        graph_dir,
        layer_parquet_cols,
        node_properties,
        chunk_size,
        t_props_chunk_size,
        num_threads,
        node_type_col,
    ): ...
    def load_node_const_properties(self, location, col_names=None, chunk_size=None): ...
    def merge_by_sorted_gids(self, other, graph_dir):
        """
        Merge this graph with another `DiskGraph`. Note that both graphs should have nodes that are
        sorted by their global ids or the resulting graph will be nonsense!
        """

    def to_events(self): ...
    def to_persistent(self): ...

class Edge(object):
    """
    PyEdge is a Python class that represents an edge in the graph.
    An edge is a directed connection between two nodes.
    """

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __hash__(self):
        """Return hash(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput):
        """
         Create a view of the Edge including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             Edge
        """

    def at(self, time: TimeInput):
        """
         Create a view of the Edge including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             Edge
        """

    def before(self, end: TimeInput):
        """
         Create a view of the Edge including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             Edge
        """

    @property
    def date_time(self):
        """
        Gets the datetime of an exploded edge.

        Returns:
            Datetime: the datetime of an exploded edge
        """

    def default_layer(self) -> Edge:
        """
         Return a view of Edge containing only the default edge layer
        Returns:
             Edge: The layered view
        """

    def deletions(self) -> List[int]:
        """
        Returns a list of timestamps of when an edge is deleted

        Returns:
            List[int]: A list of unix timestamps
        """

    def deletions_data_time(self):
        """
        Returns a list of timestamps of when an edge is deleted

        Returns:
            List[Datetime]
        """

    @property
    def dst(self):
        """Returns the destination node of the edge."""

    @property
    def earliest_date_time(self):
        """
        Gets of earliest datetime of an edge.

        Returns:
            Datetime: the earliest datetime of an edge
        """

    @property
    def earliest_time(self):
        """
        Gets the earliest time of an edge.

        Returns:
            int: The earliest time of an edge
        """

    @property
    def end(self):
        """
         Gets the latest time that this Edge is valid.

        Returns:
           Optional[int]: The latest time that this Edge is valid or None if the Edge is valid for all times.
        """

    @property
    def end_date_time(self):
        """
         Gets the latest datetime that this Edge is valid

        Returns:
             Optional[Datetime]: The latest datetime that this Edge is valid or None if the Edge is valid for all times.
        """

    def exclude_layer(self, name: str) -> Edge:
        """
         Return a view of Edge containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             Edge: The layered view
        """

    def exclude_layers(self, names: list[str]) -> Edge:
        """
         Return a view of Edge containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             Edge: The layered view
        """

    def exclude_valid_layer(self, name: str) -> Edge:
        """
         Return a view of Edge containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             Edge: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> Edge:
        """
         Return a view of Edge containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             Edge: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def explode(self):
        """Explodes returns an edge object for each update within the original edge."""

    def explode_layers(self):
        """Explode layers returns an edge object for each layer within the original edge. These new edge object contains only updates from respective layers."""

    def has_layer(self, name: str):
        """
         Check if Edge has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool
        """

    def history(self) -> List[int]:
        """
        Returns a list of timestamps of when an edge is added or change to an edge is made.

        Returns:
           List[int]:  A list of unix timestamps.

        """

    def history_counts(self) -> int:
        """
        Returns the number of times an edge is added or change to an edge is made.

        Returns:
           int: The number of times an edge is added or change to an edge is made.

        """

    def history_date_time(self):
        """
        Returns a list of timestamps of when an edge is added or change to an edge is made.

        Returns:
            List[Datetime]

        """

    @property
    def id(self):
        """The id of the edge."""

    def is_active(self):
        """
        Check if the edge is currently active (i.e., has at least one update within this period)
        Returns:
            bool
        """

    def is_deleted(self):
        """
        Check if the edge is currently deleted
        Returns:
            bool
        """

    def is_self_loop(self):
        """
        Check if the edge is on the same node
        Returns:
            bool
        """

    def is_valid(self):
        """
        Check if the edge is currently valid (i.e., not deleted)
        Returns:
            bool
        """

    def latest(self):
        """
         Create a view of the Edge including all events at the latest time.

        Returns:
             Edge
        """

    @property
    def latest_date_time(self):
        """
        Gets of latest datetime of an edge.

        Returns:
            Datetime: the latest datetime of an edge
        """

    @property
    def latest_time(self):
        """
        Gets the latest time of an edge.

        Returns:
            int: The latest time of an edge
        """

    def layer(self, name: str) -> Edge:
        """
         Return a view of Edge containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             Edge: The layered view
        """

    @property
    def layer_name(self):
        """
        Gets the name of the layer this edge belongs to - assuming it only belongs to one layer

        Returns:
            str: The name of the layer
        """

    @property
    def layer_names(self):
        """
        Gets the names of the layers this edge belongs to

        Returns:
            List[str]-  The name of the layer
        """

    def layers(self, names: list[str]) -> Edge:
        """
         Return a view of Edge containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             Edge: The layered view
        """

    @property
    def nbr(self):
        """Returns the node at the other end of the edge (same as `dst()` for out-edges and `src()` for in-edges)"""

    @property
    def properties(self):
        """
        Returns a view of the properties of the edge.

        Returns:
          Properties on the Edge.
        """

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput):
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             Edge
        """

    def shrink_start(self, start: TimeInput):
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             Edge
        """

    def shrink_window(self, start: TimeInput, end: TimeInput):
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        """

    def snapshot_at(self, time: TimeInput):
        """
         Create a view of the Edge including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `EventGraph`s and `at(time)` for `PersitentGraph`s

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             Edge
        """

    def snapshot_latest(self):
        """
         Create a view of the Edge including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `EventGraph`s and `latest()` for `PersitentGraph`s

        Returns:
             Edge
        """

    @property
    def src(self):
        """Returns the source node of the edge."""

    @property
    def start(self):
        """
         Gets the start time for rolling and expanding windows for this Edge

        Returns:
            Optional[int]: The earliest time that this Edge is valid or None if the Edge is valid for all times.
        """

    @property
    def start_date_time(self):
        """
         Gets the earliest datetime that this Edge is valid

        Returns:
             Optional[Datetime]: The earliest datetime that this Edge is valid or None if the Edge is valid for all times.
        """

    @property
    def time(self):
        """
        Gets the time of an exploded edge.

        Returns:
            int: The time of an exploded edge
        """

    def valid_layers(self, names: list[str]) -> Edge:
        """
         Return a view of Edge containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             Edge: The layered view
        """

    def window(self, start: TimeInput | None, end: TimeInput | None):
        """
         Create a view of the Edge including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
        r    Edge
        """

    @property
    def window_size(self):
        """
         Get the window size (difference between start and end) for this Edge

        Returns:
            Optional[int]
        """

class Edges(object):
    """A list of edges that can be iterated over."""

    def __bool__(self):
        """True if self else False"""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput):
        """
         Create a view of the Edges including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             Edges
        """

    def at(self, time: TimeInput):
        """
         Create a view of the Edges including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             Edges
        """

    def before(self, end: TimeInput):
        """
         Create a view of the Edges including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             Edges
        """

    def collect(self) -> list[Edge]:
        """
         Collect all edges into a list

        Returns:
             list[Edge]: the list of edges
        """

    def count(self):
        """Returns the number of edges"""

    @property
    def date_time(self):
        """
        Returns the date times of exploded edges

        Returns:
           A list of date times.
        """

    def default_layer(self) -> Edges:
        """
         Return a view of Edges containing only the default edge layer
        Returns:
             Edges: The layered view
        """

    def deletions(self):
        """
        Returns all timestamps of edges where an edge is deleted

        Returns:
            A list of lists of unix timestamps
        """

    def deletions_date_time(self):
        """
        Returns all timestamps of edges where an edge is deleted

        Returns:
            A list of lists of DateTime objects
        """

    @property
    def dst(self):
        """Returns the destination node of the edge."""

    @property
    def earliest_date_time(self):
        """
        Returns the earliest date time of the edges.

        Returns:
         Earliest date time of the edges.
        """

    @property
    def earliest_time(self):
        """
        Returns the earliest time of the edges.

        Returns:
        Earliest time of the edges.
        """

    @property
    def end(self):
        """
         Gets the latest time that this Edges is valid.

        Returns:
           Optional[int]: The latest time that this Edges is valid or None if the Edges is valid for all times.
        """

    @property
    def end_date_time(self):
        """
         Gets the latest datetime that this Edges is valid

        Returns:
             Optional[Datetime]: The latest datetime that this Edges is valid or None if the Edges is valid for all times.
        """

    def exclude_layer(self, name: str) -> Edges:
        """
         Return a view of Edges containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             Edges: The layered view
        """

    def exclude_layers(self, names: list[str]) -> Edges:
        """
         Return a view of Edges containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             Edges: The layered view
        """

    def exclude_valid_layer(self, name: str) -> Edges:
        """
         Return a view of Edges containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             Edges: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> Edges:
        """
         Return a view of Edges containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             Edges: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def explode(self):
        """Explodes returns an edge object for each update within the original edge."""

    def explode_layers(self):
        """Explode layers returns an edge object for each layer within the original edge. These new edge object contains only updates from respective layers."""

    def has_layer(self, name: str):
        """
         Check if Edges has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool
        """

    def history(self):
        """
        Returns all timestamps of edges, when an edge is added or change to an edge is made.

        Returns:
           A list of lists unix timestamps.

        """

    def history_counts(self): ...
    def history_date_time(self):
        """
        Returns all timestamps of edges, when an edge is added or change to an edge is made.

        Returns:
           A list of lists of timestamps.

        """

    @property
    def id(self):
        """Returns all ids of the edges."""

    def is_active(self): ...
    def is_deleted(self):
        """Check if the edges are deleted"""

    def is_self_loop(self):
        """Check if the edges are on the same node"""

    def is_valid(self):
        """Check if the edges are valid (i.e. not deleted)"""

    def latest(self):
        """
         Create a view of the Edges including all events at the latest time.

        Returns:
             Edges
        """

    @property
    def latest_date_time(self):
        """
        Returns the latest date time of the edges.

        Returns:
          Latest date time of the edges.
        """

    @property
    def latest_time(self):
        """
        Returns the latest time of the edges.

        Returns:
         Latest time of the edges.
        """

    def layer(self, name: str) -> Edges:
        """
         Return a view of Edges containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             Edges: The layered view
        """

    @property
    def layer_name(self):
        """
        Get the layer name that all edges belong to - assuming they only belong to one layer

        Returns:
         The name of the layer
        """

    @property
    def layer_names(self):
        """
        Get the layer names that all edges belong to - assuming they only belong to one layer

        Returns:
          A list of layer names
        """

    def layers(self, names: list[str]) -> Edges:
        """
         Return a view of Edges containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             Edges: The layered view
        """

    @property
    def nbr(self):
        """Returns the node at the other end of the edge (same as `dst()` for out-edges and `src()` for in-edges)"""

    @property
    def properties(self):
        """Returns all properties of the edges"""

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput):
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             Edges
        """

    def shrink_start(self, start: TimeInput):
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             Edges
        """

    def shrink_window(self, start: TimeInput, end: TimeInput):
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        """

    def snapshot_at(self, time: TimeInput):
        """
         Create a view of the Edges including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `EventGraph`s and `at(time)` for `PersitentGraph`s

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             Edges
        """

    def snapshot_latest(self):
        """
         Create a view of the Edges including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `EventGraph`s and `latest()` for `PersitentGraph`s

        Returns:
             Edges
        """

    @property
    def src(self):
        """Returns the source node of the edge."""

    @property
    def start(self):
        """
         Gets the start time for rolling and expanding windows for this Edges

        Returns:
            Optional[int]: The earliest time that this Edges is valid or None if the Edges is valid for all times.
        """

    @property
    def start_date_time(self):
        """
         Gets the earliest datetime that this Edges is valid

        Returns:
             Optional[Datetime]: The earliest datetime that this Edges is valid or None if the Edges is valid for all times.
        """

    @property
    def time(self):
        """
        Returns the times of exploded edges

        Returns:
          Time of edge
        """

    def to_df(
        self,
        include_property_history: bool = True,
        convert_datetime: bool = False,
        explode: bool = False,
    ) -> DataFrame:
        """
        Converts the graph's edges into a Pandas DataFrame.

        This method will create a DataFrame with the following columns:
        - "src": The source node of the edge.
        - "dst": The destination node of the edge.
        - "layer": The layer of the edge.
        - "properties": The properties of the edge.
        - "update_history": The update history of the edge. This column will be included if `include_update_history` is set to `true`.

        Args:
            include_property_history (bool): A boolean, if set to `True`, the history of each property is included, if `False`, only the latest value is shown. Ignored if exploded. Defaults to True.
            convert_datetime (bool): A boolean, if set to `True` will convert the timestamp to python datetimes. Defaults to False.
            explode (bool): A boolean, if set to `True`, will explode each edge update into its own row. Defaults to False.

        Returns:
            DataFrame: If successful, this PyObject will be a Pandas DataFrame.
        """

    def valid_layers(self, names: list[str]) -> Edges:
        """
         Return a view of Edges containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             Edges: The layered view
        """

    def window(self, start: TimeInput | None, end: TimeInput | None):
        """
         Create a view of the Edges including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
        r    Edges
        """

    @property
    def window_size(self):
        """
         Get the window size (difference between start and end) for this Edges

        Returns:
            Optional[int]
        """

class Graph(GraphView):
    """
    A temporal graph with event semantics.

    Arguments:
        num_shards (int, optional): The number of locks to use in the storage to allow for multithreaded updates.
    """

    def __new__(cls, num_shards: Optional[int] = None) -> Graph:
        """Create and return a new object.  See help(type) for accurate signature."""

    def __reduce__(self): ...
    def add_constant_properties(self, properties: PropInput) -> None:
        """
        Adds static properties to the graph.

        Arguments:
            properties (PropInput): The static properties of the graph.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def add_edge(
        self,
        timestamp: TimeInput,
        src: str | int,
        dst: str | int,
        properties: Optional[PropInput] = None,
        layer: Optional[str] = None,
        secondary_index=None,
    ) -> MutableEdge:
        """
        Adds a new edge with the given source and destination nodes and properties to the graph.

        Arguments:
           timestamp (TimeInput): The timestamp of the edge.
           src (str|int): The id of the source node.
           dst (str|int): The id of the destination node.
           properties (PropInput, optional): The properties of the edge, as a dict of string and properties.
           layer (str, optional): The layer of the edge.
            secondary_index (int, optional): The optional integer which will be used as a secondary index

        Returns:
            MutableEdge: The added edge.

        Raises:
            GraphError: If the operation fails.
        """

    def add_node(
        self,
        timestamp: TimeInput,
        id: str | int,
        properties: Optional[PropInput] = None,
        node_type: Optional[str] = None,
        secondary_index: Optional[int] = None,
    ) -> MutableNode:
        """
        Adds a new node with the given id and properties to the graph.

        Arguments:
           timestamp (TimeInput): The timestamp of the node.
           id (str|int): The id of the node.
           properties (PropInput, optional): The properties of the node.
           node_type (str, optional): The optional string which will be used as a node type
           secondary_index (int, optional): The optional integer which will be used as a secondary index

        Returns:
            MutableNode: The added node.

        Raises:
            GraphError: If the operation fails.
        """

    def add_properties(
        self,
        timestamp: TimeInput,
        properties: PropInput,
        secondary_index: Optional[int] = None,
    ) -> None:
        """
        Adds properties to the graph.

        Arguments:
           timestamp (TimeInput): The timestamp of the temporal property.
           properties (PropInput): The temporal properties of the graph.
           secondary_index (int, optional): The optional integer which will be used as a secondary index

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def cache(self, path: str):
        """
         Write Graph to cache file and initialise the cache.

        Future updates are tracked. Use `write_updates` to persist them to the
        cache file. If the file already exists its contents are overwritten.

        Arguments:
            path (str): The path to the cache file
        """

    def create_node(
        self,
        timestamp: TimeInput,
        id: str | int,
        properties: Optional[PropInput] = None,
        node_type: Optional[str] = None,
        secondary_index: Optional[int] = None,
    ) -> MutableNode:
        """
        Creates a new node with the given id and properties to the graph. It fails if the node already exists.

        Arguments:
           timestamp (TimeInput): The timestamp of the node.
           id (str|int): The id of the node.
           properties (PropInput, optional): The properties of the node.
           node_type (str, optional): The optional string which will be used as a node type
           secondary_index (int, optional): The optional integer which will be used as a secondary index

        Returns:
            MutableNode: The created node.

        Raises:
            GraphError: If the operation fails.
        """

    @staticmethod
    def deserialise(bytes: bytes):
        """
         Load Graph from serialised bytes.

        Arguments:
          bytes (bytes): The serialised bytes to decode

        Returns:
           Graph
        """

    def edge(self, src: str | int, dst: str | int) -> Edge:
        """
        Gets the edge with the specified source and destination nodes

        Arguments:
            src (str|int): the source node id
            dst (str|int): the destination node id

        Returns:
            Edge: the edge with the specified source and destination nodes, or None if the edge does not exist
        """

    def event_graph(self): ...
    def get_all_node_types(self):
        """
        Returns all the node types in the graph.

        Returns:
        List[str]
        """

    def import_edge(self, edge: Edge, merge: bool = False):
        """
        Import a single edge into the graph.

        Arguments:
            edge (Edge): A Edge object representing the edge to be imported.
            merge (bool): An optional boolean flag.
                          If merge is false, the function will return an error if the imported edge already exists in the graph.
                          If merge is true, the function merges the histories of the imported edge and the existing edge (in the graph).

        Returns:
            EdgeView: An EdgeView object if the edge was successfully imported.

        Raises:
            GraphError: If the operation fails.
        """

    def import_edge_as(self, edge: Edge, new_id: tuple, merge: bool = False):
        """
        Import a single edge into the graph with new id.

        Arguments:
            edge (Edge): A Edge object representing the edge to be imported.
            new_id (tuple) : The ID of the new edge. It's a tuple of the source and destination node ids.
            merge (bool): An optional boolean flag.
                          If merge is false, the function will return an error if the imported edge already exists in the graph.
                          If merge is true, the function merges the histories of the imported edge and the existing edge (in the graph).

        Returns:
            EdgeView: An EdgeView object if the edge was successfully imported.

        Raises:
            GraphError: If the operation fails.
        """

    def import_edges(self, edges: List[Edge], merge: bool = False) -> None:
        """
        Import multiple edges into the graph.

        Arguments:
            edges (List[Edge]): A list of Edge objects representing the edges to be imported.
            merge (bool): An optional boolean flag.
                          If merge is false, the function will return an error if any of the imported edges already exists in the graph.
                          If merge is true, the function merges the histories of the imported edges and the existing edges (in the graph).

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def import_edges_as(self, edges, new_ids, merge=False):
        """
        Import multiple edges into the graph with new ids.

        Arguments:
            edges (List[Edge]): A list of Edge objects representing the edges to be imported.
            new_ids (List[tuple]) - The IDs of the new edges. It's a vector of tuples of the source and destination node ids.
            merge (bool): An optional boolean flag.
                          If merge is false, the function will return an error if any of the imported edges already exists in the graph.
                          If merge is true, the function merges the histories of the imported edges and the existing edges (in the graph).

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def import_node(self, node: Node, merge: bool = False) -> Node:
        """
        Import a single node into the graph.

        Arguments:
            node (Node): A Node object representing the node to be imported.
            merge (bool): An optional boolean flag.
                          If merge is false, the function will return an error if the imported node already exists in the graph.
                          If merge is true, the function merges the histories of the imported node and the existing node (in the graph).

        Returns:
            Node: A node object if the node was successfully imported.

        Raises:
            GraphError: If the operation fails.
        """

    def import_node_as(
        self, node: Node, new_id: str | int, merge: bool = False
    ) -> Node:
        """
        Import a single node into the graph with new id.

        Arguments:
            node (Node): A Node object representing the node to be imported.
            new_id (str|int): The new node id.
            merge (bool): An optional boolean flag.
                          If merge is false, the function will return an error if the imported node already exists in the graph.
                          If merge is true, the function merges the histories of the imported node and the existing node (in the graph).

        Returns:
            Node: A node object if the node was successfully imported.

        Raises:
            GraphError: If the operation fails.
        """

    def import_nodes(self, nodes: List[Node], merge: bool = False) -> None:
        """
        Import multiple nodes into the graph.

        Arguments:
            nodes (List[Node]): A vector of Node objects representing the nodes to be imported.
            merge (bool): An optional boolean flag.
                          If merge is false, the function will return an error if any of the imported nodes already exists in the graph.
                          If merge is true, the function merges the histories of the imported nodes and the existing nodes (in the graph).

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def import_nodes_as(
        self, nodes: List[Node], new_ids: List[str | int], merge: bool = False
    ) -> None:
        """
        Import multiple nodes into the graph with new ids.

        Arguments:
            nodes (List[Node]): A vector of Node objects representing the nodes to be imported.
            new_ids (List[str|int]): A list of node IDs to use for the imported nodes.
            merge (bool): An optional boolean flag.
                          If merge is false, the function will return an error if any of the imported nodes already exists in the graph.
                          If merge is true, the function merges the histories of the imported nodes and the existing nodes (in the graph).

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def largest_connected_component(self):
        """
        Gives the large connected component of a graph.

        # Example Usage:
        g.largest_connected_component()

        # Returns:
        Graph: sub-graph of the graph `g` containing the largest connected component

        """

    @staticmethod
    def load_cached(path: str):
        """
         Load Graph from a file and initialise it as a cache file.

        Future updates are tracked. Use `write_updates` to persist them to the
        cache file.

        Arguments:
          path (str): The path to the cache file

        Returns:
           Graph
        """

    def load_edge_props_from_pandas(
        self,
        df: DataFrame,
        src: str,
        dst: str,
        constant_properties: List[str] = None,
        shared_constant_properties: PropInput = None,
        layer: str = None,
        layer_col: str = None,
    ) -> None:
        """
        Load edge properties from a Pandas DataFrame.

        Arguments:
            df (DataFrame): The Pandas DataFrame containing edge information.
            src (str): The column name for the source node.
            dst (str): The column name for the destination node.
            constant_properties (List[str]): List of constant edge property column names. Defaults to None. (optional)
            shared_constant_properties (PropInput): A dictionary of constant properties that will be added to every edge. Defaults to None. (optional)
            layer (str): The edge layer name (optional) Defaults to None.
            layer_col (str): The edge layer col name in dataframe (optional) Defaults to None.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_edge_props_from_parquet(
        self,
        parquet_path: str,
        src: str,
        dst: str,
        constant_properties: List[str] = None,
        shared_constant_properties: PropInput = None,
        layer: str = None,
        layer_col: str = None,
    ) -> None:
        """
        Load edge properties from parquet file

        Arguments:
            parquet_path (str): Parquet file or directory of Parquet files path containing edge information.
            src (str): The column name for the source node.
            dst (str): The column name for the destination node.
            constant_properties (List[str]): List of constant edge property column names. Defaults to None. (optional)
            shared_constant_properties (PropInput): A dictionary of constant properties that will be added to every edge. Defaults to None. (optional)
            layer (str): The edge layer name (optional) Defaults to None.
            layer_col (str): The edge layer col name in dataframe (optional) Defaults to None.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_edges_from_pandas(
        self,
        df: DataFrame,
        time: str,
        src: str,
        dst: str,
        properties: List[str] = None,
        constant_properties: List[str] = None,
        shared_constant_properties: PropInput = None,
        layer: str = None,
        layer_col: str = None,
    ) -> None:
        """
        Load edges from a Pandas DataFrame into the graph.

        Arguments:
            df (DataFrame): The Pandas DataFrame containing the edges.
            time (str): The column name for the update timestamps.
            src (str): The column name for the source node ids.
            dst (str): The column name for the destination node ids.
            properties (List[str]): List of edge property column names. Defaults to None. (optional)
            constant_properties (List[str]): List of constant edge property column names. Defaults to None. (optional)
            shared_constant_properties (PropInput): A dictionary of constant properties that will be added to every edge. Defaults to None. (optional)
            layer (str): A constant value to use as the layer for all edges (optional) Defaults to None. (cannot be used in combination with layer_col)
            layer_col (str): The edge layer col name in dataframe (optional) Defaults to None. (cannot be used in combination with layer)

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_edges_from_parquet(
        self,
        parquet_path: str,
        time: str,
        src: str,
        dst: str,
        properties: List[str] = None,
        constant_properties: List[str] = None,
        shared_constant_properties: PropInput = None,
        layer: str = None,
        layer_col: str = None,
    ) -> None:
        """
        Load edges from a Parquet file into the graph.

        Arguments:
            parquet_path (str): Parquet file or directory of Parquet files path containing edges
            time (str): The column name for the update timestamps.
            src (str): The column name for the source node ids.
            dst (str): The column name for the destination node ids.
            properties (List[str]): List of edge property column names. Defaults to None. (optional)
            constant_properties (List[str]): List of constant edge property column names. Defaults to None. (optional)
            shared_constant_properties (PropInput): A dictionary of constant properties that will be added to every edge. Defaults to None. (optional)
            layer (str): A constant value to use as the layer for all edges (optional) Defaults to None. (cannot be used in combination with layer_col)
            layer_col (str): The edge layer col name in dataframe (optional) Defaults to None. (cannot be used in combination with layer)

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    @staticmethod
    def load_from_file(path: str):
        """
         Load Graph from a file.

        Arguments:
          path (str): The path to the file.

        Returns:
           Graph
        """

    def load_node_props_from_pandas(
        self,
        df: DataFrame,
        id: str,
        node_type: str = None,
        node_type_col: str = None,
        constant_properties: List[str] = None,
        shared_constant_properties: PropInput = None,
    ) -> None:
        """
        Load node properties from a Pandas DataFrame.

        Arguments:
            df (DataFrame): The Pandas DataFrame containing node information.
            id(str): The column name for the node IDs.
            node_type (str): A constant value to use as the node type for all nodes (optional). Defaults to None. (cannot be used in combination with node_type_col)
            node_type_col (str): The node type col name in dataframe (optional) Defaults to None. (cannot be used in combination with node_type)
            constant_properties (List[str]): List of constant node property column names. Defaults to None. (optional)
            shared_constant_properties (PropInput): A dictionary of constant properties that will be added to every node. Defaults to None. (optional)

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_node_props_from_parquet(
        self,
        parquet_path: str,
        id: str,
        node_type: str = None,
        node_type_col: str = None,
        constant_properties: List[str] = None,
        shared_constant_properties: PropInput = None,
    ) -> None:
        """
        Load node properties from a parquet file.

        Arguments:
            parquet_path (str): Parquet file or directory of Parquet files path containing node information.
            id(str): The column name for the node IDs.
            node_type (str): A constant value to use as the node type for all nodes (optional). Defaults to None. (cannot be used in combination with node_type_col)
            node_type_col (str): The node type col name in dataframe (optional) Defaults to None. (cannot be used in combination with node_type)
            constant_properties (List[str]): List of constant node property column names. Defaults to None. (optional)
            shared_constant_properties (PropInput): A dictionary of constant properties that will be added to every node. Defaults to None. (optional)

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_nodes_from_pandas(
        self,
        df: DataFrame,
        time: str,
        id: str,
        node_type: str = None,
        node_type_col: str = None,
        properties: List[str] = None,
        constant_properties: List[str] = None,
        shared_constant_properties: PropInput = None,
    ) -> None:
        """
        Load nodes from a Pandas DataFrame into the graph.

        Arguments:
            df (DataFrame): The Pandas DataFrame containing the nodes.
            time (str): The column name for the timestamps.
            id (str): The column name for the node IDs.
            node_type (str): A constant value to use as the node type for all nodes (optional). Defaults to None. (cannot be used in combination with node_type_col)
            node_type_col (str): The node type col name in dataframe (optional) Defaults to None. (cannot be used in combination with node_type)
            properties (List[str]): List of node property column names. Defaults to None. (optional)
            constant_properties (List[str]): List of constant node property column names. Defaults to None.  (optional)
            shared_constant_properties (PropInput): A dictionary of constant properties that will be added to every node. Defaults to None. (optional)

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_nodes_from_parquet(
        self,
        parquet_path: str,
        time: str,
        id: str,
        node_type: str = None,
        node_type_col: str = None,
        properties: List[str] = None,
        constant_properties: List[str] = None,
        shared_constant_properties: PropInput = None,
    ) -> None:
        """
        Load nodes from a Parquet file into the graph.

        Arguments:
            parquet_path (str): Parquet file or directory of Parquet files containing the nodes
            time (str): The column name for the timestamps.
            id (str): The column name for the node IDs.
            node_type (str): A constant value to use as the node type for all nodes (optional). Defaults to None. (cannot be used in combination with node_type_col)
            node_type_col (str): The node type col name in dataframe (optional) Defaults to None. (cannot be used in combination with node_type)
            properties (List[str]): List of node property column names. Defaults to None. (optional)
            constant_properties (List[str]): List of constant node property column names. Defaults to None.  (optional)
            shared_constant_properties (PropInput): A dictionary of constant properties that will be added to every node. Defaults to None. (optional)

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def node(self, id: str | int) -> Node:
        """
        Gets the node with the specified id

        Arguments:
          id (str|int): the node id

        Returns:
          Node: The node object with the specified id, or None if the node does not exist
        """

    def persist_as_disk_graph(self, graph_dir):
        """save graph in disk_graph format and memory map the result"""

    def persistent_graph(self):
        """Get persistent graph"""

    def save_to_file(self, path: str):
        """
         Saves the Graph to the given path.

        Arguments:
         path (str): The path to the file.
        """

    def save_to_zip(self, path: str):
        """
         Saves the Graph to the given path.

        Arguments:
         path (str): The path to the file.
        """

    def serialise(self):
        """
         Serialise Graph to bytes.

        Returns:
          bytes
        """

    def to_disk_graph(self, graph_dir): ...
    def update_constant_properties(self, properties: PropInput) -> None:
        """
        Updates static properties to the graph.

        Arguments:
            properties (PropInput): The static properties of the graph.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def write_updates(self):
        """Persist the new updates by appending them to the cache file."""

class GraphIndex(object):
    """
    A searchable Index for a `Graph`. This allows for fuzzy and exact searches of nodes and edges.
    This makes use of Tantivity internally to provide the search functionality.
    To create a graph index, call `graph.index()` on any `Graph` object in python.
    """

    def fuzzy_search_edges(
        self,
        query: str,
        limit: int = 25,
        offset: int = 0,
        prefix: bool = False,
        levenshtein_distance: int = 0,
    ) -> list[Edge]:
        """
        Searches for edges which match the given query. This uses Tantivy's fuzzy search.

        Arguments:
           query(str): The query to search for.
           limit(int): The maximum number of results to return. Defaults to 25.
           offset(int): The number of results to skip. This is useful for pagination. Returns the first page of results by default.
           prefix(bool):  If prefix is set to true, the fuzzy matching will be applied as a prefix search, meaning it matches terms that start with the query term. Defaults to False.
           levenshtein_distance(int): The levenshtein_distance parameter defines the maximum edit distance allowed for fuzzy matching. It specifies the number of changes (insertions, deletions, or substitutions) required to match the query term. Defaults to 0.
                The default value corresponds to exact matching.

        Returns:
           list[Edge]: A list of edges which match the query. The list will be empty if no edges match the query.
        """

    def fuzzy_search_nodes(
        self,
        query: str,
        limit: int = 25,
        offset: int = 0,
        prefix: bool = False,
        levenshtein_distance: int = 0,
    ) -> list[Node]:
        """
        Searches for nodes which match the given query. This uses Tantivy's fuzzy search.
        If you would like to better understand the query syntax, please visit our documentation at https://docs.raphtory.com

        Arguments:
           query(str): The query to search for.
           limit(int): The maximum number of results to return. Defaults to 25.
           offset(int): The number of results to skip. This is useful for pagination.
                Returns the first page of results by default.
           prefix(bool):  If prefix is set to true, the fuzzy matching will be applied as a prefix search, meaning it matches terms that start with the query term. Defaults to False.
           levenshtein_distance(int): The levenshtein_distance parameter defines the maximum edit distance allowed for fuzzy matching. It specifies the number of changes (insertions, deletions, or substitutions) required to match the query term. Defaults to 0.
                The default corresponds to exact matching.

        Returns:
           list[Node]: A list of nodes which match the query. The list will be empty if no nodes match.
        """

    def search_edges(self, query: str, limit: int = 25, offset: int = 0) -> list[Edge]:
        """
        Searches for edges which match the given query. This uses Tantivy's exact search.

        Arguments:
           query(str): The query to search for.
           limit(int): The maximum number of results to return. Defaults to 25.
           offset(int): The number of results to skip. This is useful for pagination. Defaults to 0.

        Returns:
           list[Edge]: A list of edges which match the query. The list will be empty if no edges match the query.
        """

    def search_nodes(self, query: str, limit: int = 25, offset: int = 0) -> list[Node]:
        """
        Searches for nodes which match the given query. This uses Tantivy's exact search.

        Arguments:
           query(str): The query to search for.
           limit(int): The maximum number of results to return. Defaults to 25.
           offset(int): The number of results to skip. This is useful for pagination. Defaults to 0.

        Returns:
           list[Node]: A list of nodes which match the query. The list will be empty if no nodes match.
        """

class GraphView(object):
    """Graph view is a read-only version of a graph at a certain point in time."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __le__(self, value):
        """Return self<=value."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput):
        """
         Create a view of the GraphView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             GraphView
        """

    def at(self, time: TimeInput):
        """
         Create a view of the GraphView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             GraphView
        """

    def before(self, end: TimeInput):
        """
         Create a view of the GraphView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             GraphView
        """

    def cache_view(self):
        """
        Applies the filters to the graph and retains the node ids and the edge ids
        in the graph that satisfy the filters
        creates bitsets per layer for nodes and edges

        Returns:
          MaskedGraph: Returns the masked graph
        """

    def count_edges(self) -> int:
        """
        Number of edges in the graph

        Returns:
           int: the number of edges in the graph
        """

    def count_nodes(self) -> int:
        """
        Number of nodes in the graph

        Returns:
          int: the number of nodes in the graph
        """

    def count_temporal_edges(self) -> int:
        """
        Number of edges in the graph

        Returns:
           int: the number of temporal edges in the graph
        """

    def default_layer(self) -> GraphView:
        """
         Return a view of GraphView containing only the default edge layer
        Returns:
             GraphView: The layered view
        """

    @property
    def earliest_date_time(self):
        """
        DateTime of earliest activity in the graph

        Returns:
            Optional[Datetime]: the datetime of the earliest activity in the graph
        """

    @property
    def earliest_time(self):
        """
        Timestamp of earliest activity in the graph

        Returns:
            Optional[int]: the timestamp of the earliest activity in the graph
        """

    def edge(self, src: str or int, dst: str or int) -> Optional[Edge]:
        """
        Gets the edge with the specified source and destination nodes

        Arguments:
            src (str or int): the source node id
            dst (str or int): the destination node id

        Returns:
            Optional[Edge]: the edge with the specified source and destination nodes, or None if the edge does not exist
        """

    @property
    def edges(self):
        """
        Gets all edges in the graph

        Returns:
          Edges: the edges in the graph
        """

    @property
    def end(self):
        """
         Gets the latest time that this GraphView is valid.

        Returns:
           Optional[int]: The latest time that this GraphView is valid or None if the GraphView is valid for all times.
        """

    @property
    def end_date_time(self):
        """
         Gets the latest datetime that this GraphView is valid

        Returns:
             Optional[Datetime]: The latest datetime that this GraphView is valid or None if the GraphView is valid for all times.
        """

    def exclude_layer(self, name: str) -> GraphView:
        """
         Return a view of GraphView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             GraphView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> GraphView:
        """
         Return a view of GraphView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             GraphView: The layered view
        """

    def exclude_nodes(self, nodes: list[InputNode]) -> GraphView:
        """
        Returns a subgraph given a set of nodes that are excluded from the subgraph

        Arguments:
          nodes (list[InputNode]): set of nodes

        Returns:
           GraphView: Returns the subgraph
        """

    def exclude_valid_layer(self, name: str) -> GraphView:
        """
         Return a view of GraphView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             GraphView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> GraphView:
        """
         Return a view of GraphView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             GraphView: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def filter_edges(self, filter) -> GraphView:
        """
        Return a filtered view that only includes edges that satisfy the filter

        Arguments
            filter (PropertyFilter): The filter to apply to the edge properties. Construct a
                                     filter using `Prop`.

        Returns:
            GraphView: The filtered view
        """

    def filter_exploded_edges(self, filter: PropertyFilter) -> GraphView:
        """
        Return a filtered view that only includes exploded edges that satisfy the filter

        Arguments:
            filter (PropertyFilter): The filter to apply to the exploded edge properties. Construct a
                                     filter using `Prop`.

        Returns:
            GraphView: The filtered view
        """

    def filter_nodes(self, filter) -> GraphView:
        """
        Return a filtered view that only includes nodes that satisfy the filter

        Arguments
            filter (PropertyFilter): The filter to apply to the node properties. Construct a
                                     filter using `Prop`.

        Returns:
            GraphView: The filtered view
        """

    def find_edges(self, properties_dict) -> list[Edge]:
        """
        Get the edges that match the properties name and value
        Arguments:
            property_dict (dict[str, Prop]): the properties name and value
        Returns:
           list[Edge]: the edges that match the properties name and value
        """

    def find_nodes(self, properties_dict) -> list[Node]:
        """
        Get the nodes that match the properties name and value
        Arguments:
            property_dict (dict[str, Prop]): the properties name and value
        Returns:
           list[Node]: the nodes that match the properties name and value
        """

    def has_edge(self, src: str or int, dst: str or int) -> bool:
        """
        Returns true if the graph contains the specified edge

        Arguments:
          src (str or int): the source node id
          dst (str or int): the destination node id

        Returns:
            bool: true if the graph contains the specified edge, false otherwise
        """

    def has_layer(self, name: str):
        """
         Check if GraphView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool
        """

    def has_node(self, id: str or int) -> bool:
        """
        Returns true if the graph contains the specified node

        Arguments:
           id (str or int): the node id

        Returns:
          bool: true if the graph contains the specified node, false otherwise
        """

    def index(self):
        """
        Indexes all node and edge properties.
        Returns a GraphIndex which allows the user to search the edges and nodes of the graph via tantivity fuzzy matching queries.
        Note this is currently immutable and will not update if the graph changes. This is to be improved in a future release.

        Returns:
           GraphIndex - Returns a GraphIndex
        """

    def latest(self):
        """
         Create a view of the GraphView including all events at the latest time.

        Returns:
             GraphView
        """

    @property
    def latest_date_time(self):
        """
        DateTime of latest activity in the graph

        Returns:
            Optional[Datetime]: the datetime of the latest activity in the graph
        """

    @property
    def latest_time(self):
        """
        Timestamp of latest activity in the graph

        Returns:
            Optional[int]: the timestamp of the latest activity in the graph
        """

    def layer(self, name: str) -> GraphView:
        """
         Return a view of GraphView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             GraphView: The layered view
        """

    def layers(self, names: list[str]) -> GraphView:
        """
         Return a view of GraphView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             GraphView: The layered view
        """

    def materialize(self) -> GraphView:
        """
        Returns a 'materialized' clone of the graph view - i.e. a new graph with a copy of the data seen within the view instead of just a mask over the original graph

        Returns:
           GraphView: Returns a graph clone
        """

    def node(self, id: str or int) -> Optional[Node]:
        """
        Gets the node with the specified id

        Arguments:
          id (str or int): the node id

        Returns:
            Optional[Node]: the node with the specified id, or None if the node does not exist
        """

    @property
    def nodes(self):
        """
        Gets the nodes in the graph

        Returns:
          Nodes: the nodes in the graph
        """

    @property
    def properties(self):
        """
        Get all graph properties


        Returns:
            Properties: Properties paired with their names
        """

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput):
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             GraphView
        """

    def shrink_start(self, start: TimeInput):
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             GraphView
        """

    def shrink_window(self, start: TimeInput, end: TimeInput):
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        """

    def snapshot_at(self, time: TimeInput):
        """
         Create a view of the GraphView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `EventGraph`s and `at(time)` for `PersitentGraph`s

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             GraphView
        """

    def snapshot_latest(self):
        """
         Create a view of the GraphView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `EventGraph`s and `latest()` for `PersitentGraph`s

        Returns:
             GraphView
        """

    @property
    def start(self):
        """
         Gets the start time for rolling and expanding windows for this GraphView

        Returns:
            Optional[int]: The earliest time that this GraphView is valid or None if the GraphView is valid for all times.
        """

    @property
    def start_date_time(self):
        """
         Gets the earliest datetime that this GraphView is valid

        Returns:
             Optional[Datetime]: The earliest datetime that this GraphView is valid or None if the GraphView is valid for all times.
        """

    def subgraph(self, nodes: list[InputNode]) -> GraphView:
        """
        Returns a subgraph given a set of nodes

        Arguments:
          nodes (list[InputNode]): set of nodes

        Returns:
           GraphView: Returns the subgraph
        """

    def subgraph_node_types(self, node_types: list[str]) -> GraphView:
        """
        Returns a subgraph filtered by node types given a set of node types

        Arguments:
          node_types (list[str]): set of node types

        Returns:
           GraphView: Returns the subgraph
        """

    def to_networkx(
        self,
        explode_edges: bool = False,
        include_node_properties: bool = True,
        include_edge_properties: bool = True,
        include_update_history: bool = True,
        include_property_history: bool = True,
    ):
        """
        Returns a graph with NetworkX.

            Network X is a required dependency.
            If you intend to use this function make sure that
            you install Network X with ``pip install networkx``

            Args:
                explode_edges (bool): A boolean that is set to True if you want to explode the edges in the graph. By default this is set to False.
                include_node_properties (bool): A boolean that is set to True if you want to include the node properties in the graph. By default this is set to True.
                include_edge_properties (bool): A boolean that is set to True if you want to include the edge properties in the graph. By default this is set to True.
                include_update_history (bool): A boolean that is set to True if you want to include the update histories in the graph. By default this is set to True.
                include_property_history (bool): A boolean that is set to True if you want to include the histories in the graph. By default this is set to True.

            Returns:
                A Networkx MultiDiGraph.
        """

    def to_pyvis(
        self,
        explode_edges=False,
        edge_color="#000000",
        shape=None,
        node_image=None,
        edge_weight=None,
        edge_label=None,
        colour_nodes_by_type=False,
        notebook=False,
        **kwargs
    ):
        """
        Draw a graph with PyVis.
        Pyvis is a required dependency. If you intend to use this function make sure that you install Pyvis
        with ``pip install pyvis``

            Args:
                graph (graph): A Raphtory graph.
                explode_edges (bool): A boolean that is set to True if you want to explode the edges in the graph. Defaults to False.
                edge_color (str): A string defining the colour of the edges in the graph. Defaults to "#000000".
                shape (str): An optional string defining what the node looks like. Defaults to "dot".
                    There are two types of nodes. One type has the label inside of it and the other type has the label underneath it.
                    The types with the label inside of it are: ellipse, circle, database, box, text.
                    The ones with the label outside of it are: image, circularImage, diamond, dot, star, triangle, triangleDown, square and icon.
                node_image (str, optional): An optional string defining the url of a custom node image.
                edge_weight (str, optional): An optional string defining the name of the property where edge weight is set on your Raphtory graph.
                    If not provided, the edge weight is set to `1.0` for all edges.
                edge_label (str): An optional string defining the name of the property where edge label is set on your Raphtory graph. By default, an empty string as the label is set.
                notebook (bool): A boolean that is set to True if using jupyter notebook. Defaults to False
                kwargs: Additional keyword arguments that are passed to the pyvis Network class.

            Returns:
                A pyvis network
        """

    @property
    def unique_layers(self):
        """
        Return all the layer ids in the graph

        Returns:
            list[str]
        """

    def valid_layers(self, names: list[str]) -> GraphView:
        """
         Return a view of GraphView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             GraphView: The layered view
        """

    def vectorise(
        self,
        embedding: Callable[[list], list],
        cache: str = None,
        overwrite_cache: bool = False,
        graph_template: str = None,
        node_template: str = None,
        edge_template: str = None,
        graph_name=None,
        verbose: bool = False,
    ):
        """
        Create a VectorisedGraph from the current graph

        Args:
          embedding (Callable[[list], list]): the embedding function to translate documents to embeddings
          cache (str): the file to be used as a cache to avoid calling the embedding function (optional)
          overwrite_cache (bool): whether or not to overwrite the cache if there are new embeddings (optional)
          graph_template (str): the document template for the graphs (optional)
          node_template (str): the document template for the nodes (optional)
          edge_template (str): the document template for the edges (optional)
          verbose (bool): whether or not to print logs reporting the progress

        Returns:
          A VectorisedGraph with all the documents/embeddings computed and with an initial empty selection
        """

    def window(self, start: TimeInput | None, end: TimeInput | None):
        """
         Create a view of the GraphView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
        r    GraphView
        """

    @property
    def window_size(self):
        """
         Get the window size (difference between start and end) for this GraphView

        Returns:
            Optional[int]
        """

class MutableEdge(Edge):
    def __repr__(self):
        """Return repr(self)."""

    def add_constant_properties(
        self, properties: PropInput, layer: Optional[str] = None
    ):
        """
        Add constant properties to an edge in the graph.
        This function is used to add properties to an edge that remain constant and do not
        change over time. These properties are fundamental attributes of the edge.

        Parameters:
            properties (PropInput): A dictionary of properties to be added to the edge.
            layer (str, optional): The layer you want these properties to be added on to.
        """

    def add_updates(
        self,
        t: TimeInput,
        properties: Optional[PropInput] = None,
        layer: Optional[str] = None,
        secondary_index: Optional[int] = None,
    ) -> None:
        """
        Add updates to an edge in the graph at a specified time.
        This function allows for the addition of property updates to an edge within the graph. The updates are time-stamped, meaning they are applied at the specified time.

        Parameters:
           t (TimeInput): The timestamp at which the updates should be applied.
           properties (PropInput, optional): A dictionary of properties to update.
           layer (str, optional): The layer you want these properties to be added on to.
           secondary_index (int, optional): The optional integer which will be used as a secondary index

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def delete(self, t: TimeInput, layer: Optional[str] = None):
        """
        Mark the edge as deleted at the specified time.

        Parameters:
            t (TimeInput): The timestamp at which the deletion should be applied.
            layer (str, optional): The layer you want the deletion applied to .
        """

    def update_constant_properties(
        self, properties: PropInput, layer: Optional[str] = None
    ):
        """
        Update constant properties of an edge in the graph overwriting existing values.
        This function is used to add properties to an edge that remains constant and does not
        change over time. These properties are fundamental attributes of the edge.

        Parameters:
            properties (PropInput): A dictionary of properties to be added to the edge.
            layer (str, optional): The layer you want these properties to be added on to.
        """

class MutableNode(Node):
    def __repr__(self):
        """Return repr(self)."""

    def add_constant_properties(self, properties: PropInput):
        """
        Add constant properties to a node in the graph.
        This function is used to add properties to a node that remain constant and do not
        change over time. These properties are fundamental attributes of the node.

        Parameters:
            properties (PropInput): A dictionary of properties to be added to the node. Each key is a string representing the property name, and each value is of type Prop representing the property value.
        """

    def add_updates(
        self,
        t: TimeInput,
        properties: PropInput = None,
        secondary_index: Optional[int] = None,
    ) -> None:
        """
        Add updates to a node in the graph at a specified time.
        This function allows for the addition of property updates to a node within the graph. The updates are time-stamped, meaning they are applied at the specified time.

        Parameters:
           t (TimeInput): The timestamp at which the updates should be applied.
           properties (PropInput): A dictionary of properties to update. Each key is a string representing the property name, and each value is of type Prop representing the property value. If None, no properties are updated.
           secondary_index (int, optional): The optional integer which will be used as a secondary index

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def set_node_type(self, new_type: str):
        """
        Set the type on the node. This only works if the type has not been previously set, otherwise will
        throw an error

        Parameters:
            new_type (str): The new type to be set
        """

    def update_constant_properties(self, properties: PropInput):
        """
        Update constant properties of a node in the graph overwriting existing values.
        This function is used to add properties to a node that remain constant and do not
        change over time. These properties are fundamental attributes of the node.

        Parameters:
            properties (PropInput): A dictionary of properties to be added to the node. Each key is a string representing the property name, and each value is of type Prop representing the property value.
        """

class Node(object):
    """A node (or node) in the graph."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __hash__(self):
        """Return hash(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput):
        """
         Create a view of the Node including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             Node
        """

    def at(self, time: TimeInput):
        """
         Create a view of the Node including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             Node
        """

    def before(self, end: TimeInput):
        """
         Create a view of the Node including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             Node
        """

    def default_layer(self) -> Node:
        """
         Return a view of Node containing only the default edge layer
        Returns:
             Node: The layered view
        """

    def degree(self):
        """
        Get the degree of this node (i.e., the number of edges that are incident to it).

        Returns
            int: The degree of this node.
        """

    @property
    def earliest_date_time(self):
        """
        Returns the earliest datetime that the node exists.

        Returns:
            Datetime: The earliest datetime that the node exists as a Datetime.
        """

    @property
    def earliest_time(self):
        """
        Returns the earliest time that the node exists.

        Returns:
            int: The earliest time that the node exists as an integer.
        """

    @property
    def edges(self):
        """
        Get the edges that are incident to this node.

        Returns:

        An iterator over the edges that are incident to this node.
        """

    @property
    def end(self):
        """
         Gets the latest time that this Node is valid.

        Returns:
           Optional[int]: The latest time that this Node is valid or None if the Node is valid for all times.
        """

    @property
    def end_date_time(self):
        """
         Gets the latest datetime that this Node is valid

        Returns:
             Optional[Datetime]: The latest datetime that this Node is valid or None if the Node is valid for all times.
        """

    def exclude_layer(self, name: str) -> Node:
        """
         Return a view of Node containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             Node: The layered view
        """

    def exclude_layers(self, names: list[str]) -> Node:
        """
         Return a view of Node containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             Node: The layered view
        """

    def exclude_valid_layer(self, name: str) -> Node:
        """
         Return a view of Node containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             Node: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> Node:
        """
         Return a view of Node containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             Node: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def filter_edges(self, filter) -> Node:
        """
        Return a filtered view that only includes edges that satisfy the filter

        Arguments
            filter (PropertyFilter): The filter to apply to the edge properties. Construct a
                                     filter using `Prop`.

        Returns:
            Node: The filtered view
        """

    def filter_exploded_edges(self, filter: PropertyFilter) -> Node:
        """
        Return a filtered view that only includes exploded edges that satisfy the filter

        Arguments:
            filter (PropertyFilter): The filter to apply to the exploded edge properties. Construct a
                                     filter using `Prop`.

        Returns:
            Node: The filtered view
        """

    def filter_nodes(self, filter) -> Node:
        """
        Return a filtered view that only includes nodes that satisfy the filter

        Arguments
            filter (PropertyFilter): The filter to apply to the node properties. Construct a
                                     filter using `Prop`.

        Returns:
            Node: The filtered view
        """

    def has_layer(self, name: str):
        """
         Check if Node has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool
        """

    def history(self) -> List[int]:
        """
        Returns the history of a node, including node additions and changes made to node.

        Returns:
            List[int]: A list of unix timestamps of the event history of node.
        """

    def history_date_time(self) -> List[datetime]:
        """
        Returns the history of a node, including node additions and changes made to node.

        Returns:
            List[datetime]: A list of timestamps of the event history of node.

        """

    @property
    def id(self):
        """
        Returns the id of the node.
        This is a unique identifier for the node.

        Returns:
           (str|int): The id of the node.
        """

    def in_degree(self) -> int:
        """
        Get the in-degree of this node (i.e., the number of edges that are incident to it from other nodes).

        Returns:
           int: The in-degree of this node.
        """

    @property
    def in_edges(self):
        """
        Get the edges that point into this node.

        Returns:

        An iterator over the edges that point into this node.
        """

    @property
    def in_neighbours(self):
        """
        Get the neighbours of this node that point into this node.

        Returns:

        An iterator over the neighbours of this node that point into this node.
        """

    def is_active(self): ...
    def latest(self):
        """
         Create a view of the Node including all events at the latest time.

        Returns:
             Node
        """

    @property
    def latest_date_time(self):
        """
        Returns the latest datetime that the node exists.

        Arguments:
           None

        Returns:
            Datetime: The latest datetime that the node exists as a Datetime.
        """

    @property
    def latest_time(self):
        """
        Returns the latest time that the node exists.

        Returns:
           int:  The latest time that the node exists as an integer.
        """

    def layer(self, name: str) -> Node:
        """
         Return a view of Node containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             Node: The layered view
        """

    def layers(self, names: list[str]) -> Node:
        """
         Return a view of Node containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             Node: The layered view
        """

    @property
    def name(self):
        """
        Returns the name of the node.

        Returns:
            str: The id of the node as a string.
        """

    @property
    def neighbours(self):
        """
        Get the neighbours of this node.

        Returns:

        An iterator over the neighbours of this node.
        """

    @property
    def node_type(self):
        """Returns the type of node"""

    def out_degree(self) -> int:
        """
        Get the out-degree of this node (i.e., the number of edges that are incident to it from this node).

        Returns:
          int: The out-degree of this node.
        """

    @property
    def out_edges(self):
        """
        Get the edges that point out of this node.

        Returns:

        An iterator over the edges that point out of this node.
        """

    @property
    def out_neighbours(self):
        """
        Get the neighbours of this node that point out of this node.

        Returns:

        An iterator over the neighbours of this node that point out of this node.
        """

    @property
    def properties(self):
        """
        The properties of the node

        Returns:
            Properties: A list of properties.
        """

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput):
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             Node
        """

    def shrink_start(self, start: TimeInput):
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             Node
        """

    def shrink_window(self, start: TimeInput, end: TimeInput):
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        """

    def snapshot_at(self, time: TimeInput):
        """
         Create a view of the Node including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `EventGraph`s and `at(time)` for `PersitentGraph`s

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             Node
        """

    def snapshot_latest(self):
        """
         Create a view of the Node including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `EventGraph`s and `latest()` for `PersitentGraph`s

        Returns:
             Node
        """

    @property
    def start(self):
        """
         Gets the start time for rolling and expanding windows for this Node

        Returns:
            Optional[int]: The earliest time that this Node is valid or None if the Node is valid for all times.
        """

    @property
    def start_date_time(self):
        """
         Gets the earliest datetime that this Node is valid

        Returns:
             Optional[Datetime]: The earliest datetime that this Node is valid or None if the Node is valid for all times.
        """

    def valid_layers(self, names: list[str]) -> Node:
        """
         Return a view of Node containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             Node: The layered view
        """

    def window(self, start: TimeInput | None, end: TimeInput | None):
        """
         Create a view of the Node including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
        r    Node
        """

    @property
    def window_size(self):
        """
         Get the window size (difference between start and end) for this Node

        Returns:
            Optional[int]
        """

class Nodes(object):
    """A list of nodes that can be iterated over."""

    def __bool__(self):
        """True if self else False"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput):
        """
         Create a view of the Nodes including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             Nodes
        """

    def at(self, time: TimeInput):
        """
         Create a view of the Nodes including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             Nodes
        """

    def before(self, end: TimeInput):
        """
         Create a view of the Nodes including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             Nodes
        """

    def collect(self) -> list[Node]:
        """
         Collect all nodes into a list

        Returns:
             list[Node]: the list of nodes
        """

    def default_layer(self) -> Nodes:
        """
         Return a view of Nodes containing only the default edge layer
        Returns:
             Nodes: The layered view
        """

    def degree(self):
        """
        Returns the number of edges of the nodes

        Returns:
            An iterator of the number of edges of the nodes
        """

    @property
    def earliest_date_time(self):
        """
        Returns the earliest time of the nodes.

        Returns:
        Earliest time of the nodes.
        """

    @property
    def earliest_time(self):
        """Returns an iterator over the nodes earliest time"""

    @property
    def edges(self):
        """
        Get the edges that are incident to this node.

        Returns:

        An iterator over the edges that are incident to this node.
        """

    @property
    def end(self):
        """
         Gets the latest time that this Nodes is valid.

        Returns:
           Optional[int]: The latest time that this Nodes is valid or None if the Nodes is valid for all times.
        """

    @property
    def end_date_time(self):
        """
         Gets the latest datetime that this Nodes is valid

        Returns:
             Optional[Datetime]: The latest datetime that this Nodes is valid or None if the Nodes is valid for all times.
        """

    def exclude_layer(self, name: str) -> Nodes:
        """
         Return a view of Nodes containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             Nodes: The layered view
        """

    def exclude_layers(self, names: list[str]) -> Nodes:
        """
         Return a view of Nodes containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             Nodes: The layered view
        """

    def exclude_valid_layer(self, name: str) -> Nodes:
        """
         Return a view of Nodes containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             Nodes: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> Nodes:
        """
         Return a view of Nodes containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             Nodes: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def filter_edges(self, filter) -> Nodes:
        """
        Return a filtered view that only includes edges that satisfy the filter

        Arguments
            filter (PropertyFilter): The filter to apply to the edge properties. Construct a
                                     filter using `Prop`.

        Returns:
            Nodes: The filtered view
        """

    def filter_exploded_edges(self, filter: PropertyFilter) -> Nodes:
        """
        Return a filtered view that only includes exploded edges that satisfy the filter

        Arguments:
            filter (PropertyFilter): The filter to apply to the exploded edge properties. Construct a
                                     filter using `Prop`.

        Returns:
            Nodes: The filtered view
        """

    def filter_nodes(self, filter) -> Nodes:
        """
        Return a filtered view that only includes nodes that satisfy the filter

        Arguments
            filter (PropertyFilter): The filter to apply to the node properties. Construct a
                                     filter using `Prop`.

        Returns:
            Nodes: The filtered view
        """

    def has_layer(self, name: str):
        """
         Check if Nodes has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool
        """

    def history(self):
        """
        Returns all timestamps of nodes, when an node is added or change to an node is made.

        Returns:
           A list of unix timestamps.

        """

    def history_date_time(self):
        """
        Returns all timestamps of nodes, when an node is added or change to an node is made.

        Returns:
           An  list of timestamps.

        """

    @property
    def id(self):
        """Returns an iterator over the nodes ids"""

    def in_degree(self):
        """
        Returns the number of in edges of the nodes

        Returns:
            An iterator of the number of in edges of the nodes
        """

    @property
    def in_edges(self):
        """
        Get the edges that point into this node.

        Returns:

        An iterator over the edges that point into this node.
        """

    @property
    def in_neighbours(self):
        """
        Get the neighbours of this node that point into this node.

        Returns:

        An iterator over the neighbours of this node that point into this node.
        """

    def latest(self):
        """
         Create a view of the Nodes including all events at the latest time.

        Returns:
             Nodes
        """

    @property
    def latest_date_time(self):
        """
        Returns the latest date time of the nodes.

        Returns:
          Latest date time of the nodes.
        """

    @property
    def latest_time(self):
        """Returns an iterator over the nodes latest time"""

    def layer(self, name: str) -> Nodes:
        """
         Return a view of Nodes containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             Nodes: The layered view
        """

    def layers(self, names: list[str]) -> Nodes:
        """
         Return a view of Nodes containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             Nodes: The layered view
        """

    @property
    def name(self):
        """Returns an iterator over the nodes name"""

    @property
    def neighbours(self):
        """
        Get the neighbours of this node.

        Returns:

        An iterator over the neighbours of this node.
        """

    @property
    def node_type(self):
        """Returns the type of node"""

    def out_degree(self):
        """
        Returns the number of out edges of the nodes

        Returns:
            An iterator of the number of out edges of the nodes
        """

    @property
    def out_edges(self):
        """
        Get the edges that point out of this node.

        Returns:

        An iterator over the edges that point out of this node.
        """

    @property
    def out_neighbours(self):
        """
        Get the neighbours of this node that point out of this node.

        Returns:

        An iterator over the neighbours of this node that point out of this node.
        """

    @property
    def properties(self):
        """
        The properties of the node

        Returns:
            A List of properties
        """

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput):
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             Nodes
        """

    def shrink_start(self, start: TimeInput):
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             Nodes
        """

    def shrink_window(self, start: TimeInput, end: TimeInput):
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        """

    def snapshot_at(self, time: TimeInput):
        """
         Create a view of the Nodes including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `EventGraph`s and `at(time)` for `PersitentGraph`s

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             Nodes
        """

    def snapshot_latest(self):
        """
         Create a view of the Nodes including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `EventGraph`s and `latest()` for `PersitentGraph`s

        Returns:
             Nodes
        """

    @property
    def start(self):
        """
         Gets the start time for rolling and expanding windows for this Nodes

        Returns:
            Optional[int]: The earliest time that this Nodes is valid or None if the Nodes is valid for all times.
        """

    @property
    def start_date_time(self):
        """
         Gets the earliest datetime that this Nodes is valid

        Returns:
             Optional[Datetime]: The earliest datetime that this Nodes is valid or None if the Nodes is valid for all times.
        """

    def to_df(
        self, include_property_history: bool = False, convert_datetime: bool = False
    ):
        """
        Converts the graph's nodes into a Pandas DataFrame.

        This method will create a DataFrame with the following columns:
        - "name": The name of the node.
        - "properties": The properties of the node.
        - "update_history": The update history of the node.

        Args:
            include_property_history (bool): A boolean, if set to `true`, the history of each property is included, if `false`, only the latest value is shown.
            convert_datetime (bool): A boolean, if set to `true` will convert the timestamp to python datetimes, defaults to `false`

        Returns:
            If successful, this PyObject will be a Pandas DataFrame.
        """

    def type_filter(self, node_types): ...
    def valid_layers(self, names: list[str]) -> Nodes:
        """
         Return a view of Nodes containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             Nodes: The layered view
        """

    def window(self, start: TimeInput | None, end: TimeInput | None):
        """
         Create a view of the Nodes including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
        r    Nodes
        """

    @property
    def window_size(self):
        """
         Get the window size (difference between start and end) for this Nodes

        Returns:
            Optional[int]
        """

class PersistentGraph(GraphView):
    """A temporal graph that allows edges and nodes to be deleted."""

    def __new__(cls) -> PersistentGraph:
        """Create and return a new object.  See help(type) for accurate signature."""

    def __reduce__(self): ...
    def add_constant_properties(self, properties: dict) -> None:
        """
        Adds static properties to the graph.

        Arguments:
            properties (dict): The static properties of the graph.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def add_edge(
        self,
        timestamp: int,
        src: str | int,
        dst: str | int,
        properties: dict = None,
        layer: str = None,
        secondary_index: Optional[int] = None,
    ) -> None:
        """
        Adds a new edge with the given source and destination nodes and properties to the graph.

        Arguments:
           timestamp (int): The timestamp of the edge.
           src (str | int): The id of the source node.
           dst (str | int): The id of the destination node.
           properties (dict): The properties of the edge, as a dict of string and properties
           layer (str): The layer of the edge.
           secondary_index (int, optional): The optional integer which will be used as a secondary index

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def add_node(
        self,
        timestamp: TimeInput,
        id: str | int,
        properties: dict = None,
        node_type: str = None,
        secondary_index: Optional[int] = None,
    ) -> None:
        """
        Adds a new node with the given id and properties to the graph.

        Arguments:
           timestamp (TimeInput): The timestamp of the node.
           id (str | int): The id of the node.
           properties (dict): The properties of the node.
           node_type (str) : The optional string which will be used as a node type
           secondary_index (int, optional): The optional integer which will be used as a secondary index

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def add_properties(
        self,
        timestamp: TimeInput,
        properties: dict,
        secondary_index: Optional[int] = None,
    ) -> None:
        """
        Adds properties to the graph.

        Arguments:
           timestamp (TimeInput): The timestamp of the temporal property.
           properties (dict): The temporal properties of the graph.
           secondary_index (int, optional): The optional integer which will be used as a secondary index

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def cache(self, path: str):
        """
         Write PersistentGraph to cache file and initialise the cache.

        Future updates are tracked. Use `write_updates` to persist them to the
        cache file. If the file already exists its contents are overwritten.

        Arguments:
            path (str): The path to the cache file
        """

    def create_node(
        self,
        timestamp: TimeInput,
        id: str | int,
        properties: dict = None,
        node_type: str = None,
        secondary_index: Optional[int] = None,
    ):
        """
        Creates a new node with the given id and properties to the graph. It fails if the node already exists.

        Arguments:
           timestamp (TimeInput): The timestamp of the node.
           id (str | int): The id of the node.
           properties (dict): The properties of the node.
           node_type (str) : The optional string which will be used as a node type
           secondary_index (int, optional): The optional integer which will be used as a secondary index

        Returns:
          MutableNode

        Raises:
            GraphError: If the operation fails.
        """

    def delete_edge(
        self,
        timestamp: int,
        src: str | int,
        dst: str | int,
        layer: str = None,
        secondary_index: Optional[int] = None,
    ):
        """
        Deletes an edge given the timestamp, src and dst nodes and layer (optional)

        Arguments:
          timestamp (int): The timestamp of the edge.
          src (str | int): The id of the source node.
          dst (str | int): The id of the destination node.
          layer (str): The layer of the edge. (optional)
          secondary_index (int, optional): The optional integer which will be used as a secondary index

        Returns:
         The deleted edge

        Raises:
            GraphError: If the operation fails.
        """

    @staticmethod
    def deserialise(bytes: bytes):
        """
         Load PersistentGraph from serialised bytes.

        Arguments:
          bytes (bytes): The serialised bytes to decode

        Returns:
           PersistentGraph
        """

    def edge(self, src: str | int, dst: str | int):
        """
        Gets the edge with the specified source and destination nodes

        Arguments:
            src (str | int): the source node id
            dst (str | int): the destination node id

        Returns:
            The edge with the specified source and destination nodes, or None if the edge does not exist
        """

    def event_graph(self):
        """Get event graph"""

    def get_all_node_types(self):
        """
        Returns all the node types in the graph.

        Returns:
            A list of node types
        """

    def import_edge(self, edge: Edge, merge: bool = False) -> Edge:
        """
        Import a single edge into the graph.

        This function takes an edge object and an optional boolean flag. If the flag is set to true,
        the function will merge the import of the edge even if it already exists in the graph.

        Arguments:
            edge (Edge): An edge object representing the edge to be imported.
            merge (bool): An optional boolean flag indicating whether to merge the import of the edge. Defaults to False.

        Returns:
            Edge: The imported edge.

        Raises:
            GraphError: If the operation fails.
        """

    def import_edge_as(self, edge: Edge, new_id: tuple, merge: bool = False) -> Edge:
        """
        Import a single edge into the graph with new id.

        This function takes a edge object, a new edge id and an optional boolean flag. If the flag is set to true,
        the function will merge the import of the edge even if it already exists in the graph.

        Arguments:
            edge (Edge): A edge object representing the edge to be imported.
            new_id (tuple) : The ID of the new edge. It's a tuple of the source and destination node ids.
            merge (bool): An optional boolean flag indicating whether to merge the import of the edge. Defaults to False.

        Returns:
            Edge: The imported edge.

        Raises:
            GraphError: If the operation fails.
        """

    def import_edges(self, edges: List[Edge], merge: bool = False) -> None:
        """
        Import multiple edges into the graph.

        This function takes a vector of edge objects and an optional boolean flag. If the flag is set to true,
        the function will merge the import of the edges even if they already exist in the graph.

        Arguments:
            edges (List[Edge]): A vector of edge objects representing the edges to be imported.
            merge (bool): An optional boolean flag indicating whether to merge the import of the edges. Defaults to False.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def import_edges_as(self, edges: List[Edge], new_ids, merge: bool = False) -> None:
        """
        Import multiple edges into the graph with new ids.

        This function takes a vector of edge objects, a list of new edge ids and an optional boolean flag. If the flag is set to true,
        the function will merge the import of the edges even if they already exist in the graph.

        Arguments:
            edges (List[Edge]): A vector of edge objects representing the edges to be imported.
            merge (bool): An optional boolean flag indicating whether to merge the import of the edges. Defaults to False.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def import_node(self, node: Node, merge: bool = False):
        """
        Import a single node into the graph.

        This function takes a node object and an optional boolean flag. If the flag is set to true,
        the function will merge the import of the node even if it already exists in the graph.

        Arguments:
            node (Node): A node object representing the node to be imported.
            merge (bool): An optional boolean flag indicating whether to merge the import of the node. Defaults to False.

        Returns:
            NodeView: A nodeview object if the node was successfully imported, and an error otherwise.

        Raises:
            GraphError: If the operation fails.
        """

    def import_node_as(self, node: Node, new_id: str | int, merge: bool = False):
        """
        Import a single node into the graph with new id.

        This function takes a node object, a new node id and an optional boolean flag. If the flag is set to true,
        the function will merge the import of the node even if it already exists in the graph.

        Arguments:
            node (Node): A node object representing the node to be imported.
            new_id (str|int): The new node id.
            merge (bool): An optional boolean flag indicating whether to merge the import of the node. Defaults to False.

        Returns:
            NodeView: A nodeview object if the node was successfully imported, and an error otherwise.

        Raises:
            GraphError: If the operation fails.
        """

    def import_nodes(self, nodes: List[Node], merge: bool = False) -> None:
        """
        Import multiple nodes into the graph.

        This function takes a vector of node objects and an optional boolean flag. If the flag is set to true,
        the function will merge the import of the nodes even if they already exist in the graph.

        Arguments:
            nodes (List[Node]):  A vector of node objects representing the nodes to be imported.
            merge (bool): An optional boolean flag indicating whether to merge the import of the nodes. Defaults to False.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def import_nodes_as(
        self, nodes: List[Node], new_ids: List[str | int], merge: bool = False
    ) -> None:
        """
        Import multiple nodes into the graph with new ids.

        This function takes a vector of node objects, a list of new node ids and an optional boolean flag. If the flag is set to true,
        the function will merge the import of the nodes even if they already exist in the graph.

        Arguments:
            nodes (List[Node]):  A vector of node objects representing the nodes to be imported.
            new_ids (List[str|int]): A list of node IDs to use for the imported nodes.
            merge (bool): An optional boolean flag indicating whether to merge the import of the nodes. Defaults to False.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    @staticmethod
    def load_cached(path: str):
        """
         Load PersistentGraph from a file and initialise it as a cache file.

        Future updates are tracked. Use `write_updates` to persist them to the
        cache file.

        Arguments:
          path (str): The path to the cache file

        Returns:
           PersistentGraph
        """

    def load_edge_deletions_from_pandas(
        self,
        df: DataFrame,
        time: str,
        src: str,
        dst: str,
        layer: str = None,
        layer_col: str = None,
    ) -> None:
        """
        Load edges deletions from a Pandas DataFrame into the graph.

        Arguments:
            df (DataFrame): The Pandas DataFrame containing the edges.
            time (str): The column name for the update timestamps.
            src (str): The column name for the source node ids.
            dst (str): The column name for the destination node ids.
            layer (str): A constant value to use as the layer for all edges (optional) Defaults to None. (cannot be used in combination with layer_col)
            layer_col (str): The edge layer col name in dataframe (optional) Defaults to None. (cannot be used in combination with layer)

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_edge_deletions_from_parquet(
        self,
        parquet_path: str,
        time: str,
        src: str,
        dst: str,
        layer: str = None,
        layer_col: str = None,
    ) -> None:
        """
        Load edges deletions from a Parquet file into the graph.

        Arguments:
            parquet_path (str): Parquet file or directory of Parquet files path containing node information.
            src (str): The column name for the source node ids.
            dst (str): The column name for the destination node ids.
            time (str): The column name for the update timestamps.
            layer (str): A constant value to use as the layer for all edges (optional) Defaults to None. (cannot be used in combination with layer_col)
            layer_col (str): The edge layer col name in dataframe (optional) Defaults to None. (cannot be used in combination with layer)

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_edge_props_from_pandas(
        self,
        df: DataFrame,
        src: str,
        dst: str,
        constant_properties: List[str] = None,
        shared_constant_properties: dict = None,
        layer: str = None,
        layer_col: str = None,
    ) -> None:
        """
        Load edge properties from a Pandas DataFrame.

        Arguments:
            df (DataFrame): The Pandas DataFrame containing edge information.
            src (str): The column name for the source node.
            dst (str): The column name for the destination node.
            constant_properties (List[str]): List of constant edge property column names. Defaults to None. (optional)
            shared_constant_properties (dict): A dictionary of constant properties that will be added to every edge. Defaults to None. (optional)
            layer (str): The edge layer name (optional) Defaults to None.
            layer_col (str): The edge layer col name in dataframe (optional) Defaults to None.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_edge_props_from_parquet(
        self,
        parquet_path: str,
        src: str,
        dst: str,
        constant_properties: List[str] = None,
        shared_constant_properties: dict = None,
        layer: str = None,
        layer_col: str = None,
    ) -> None:
        """
        Load edge properties from parquet file

        Arguments:
            parquet_path (str): Parquet file or directory of Parquet files path containing edge information.
            src (str): The column name for the source node.
            dst (str): The column name for the destination node.
            constant_properties (List[str]): List of constant edge property column names. Defaults to None. (optional)
            shared_constant_properties (dict): A dictionary of constant properties that will be added to every edge. Defaults to None. (optional)
            layer (str): The edge layer name (optional) Defaults to None.
            layer_col (str): The edge layer col name in dataframe (optional) Defaults to None.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_edges_from_pandas(
        self,
        df: DataFrame,
        time: str,
        src: str,
        dst: str,
        properties: List[str] = None,
        constant_properties: List[str] = None,
        shared_constant_properties: dict = None,
        layer: str = None,
        layer_col: str = None,
    ) -> None:
        """
        Load edges from a Pandas DataFrame into the graph.

        Arguments:
            df (DataFrame): The Pandas DataFrame containing the edges.
            time (str): The column name for the update timestamps.
            src (str): The column name for the source node ids.
            dst (str): The column name for the destination node ids.
            properties (List[str]): List of edge property column names. Defaults to None. (optional)
            constant_properties (List[str]): List of constant edge property column names. Defaults to None. (optional)
            shared_constant_properties (dict): A dictionary of constant properties that will be added to every edge. Defaults to None. (optional)
            layer (str): A constant value to use as the layer for all edges (optional) Defaults to None. (cannot be used in combination with layer_col)
            layer_col (str): The edge layer col name in dataframe (optional) Defaults to None. (cannot be used in combination with layer)

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_edges_from_parquet(
        self,
        parquet_path: str,
        time: str,
        src: str,
        dst: str,
        properties: List[str] = None,
        constant_properties: List[str] = None,
        shared_constant_properties: dict = None,
        layer: str = None,
        layer_col: str = None,
    ) -> None:
        """
        Load edges from a Parquet file into the graph.

        Arguments:
            parquet_path (str): Parquet file or directory of Parquet files path containing edges
            time (str): The column name for the update timestamps.
            src (str): The column name for the source node ids.
            dst (str): The column name for the destination node ids.
            properties (List[str]): List of edge property column names. Defaults to None. (optional)
            constant_properties (List[str]): List of constant edge property column names. Defaults to None. (optional)
            shared_constant_properties (dict): A dictionary of constant properties that will be added to every edge. Defaults to None. (optional)
            layer (str): A constant value to use as the layer for all edges (optional) Defaults to None. (cannot be used in combination with layer_col)
            layer_col (str): The edge layer col name in dataframe (optional) Defaults to None. (cannot be used in combination with layer)

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    @staticmethod
    def load_from_file(path: str):
        """
         Load PersistentGraph from a file.

        Arguments:
          path (str): The path to the file.

        Returns:
           PersistentGraph
        """

    def load_node_props_from_pandas(
        self,
        df: DataFrame,
        id: str,
        node_type: str = None,
        node_type_col: str = None,
        constant_properties: List[str] = None,
        shared_constant_properties: dict = None,
    ) -> None:
        """
        Load node properties from a Pandas DataFrame.

        Arguments:
            df (DataFrame): The Pandas DataFrame containing node information.
            id(str): The column name for the node IDs.
            node_type (str): A constant value to use as the node type for all nodes (optional). Defaults to None. (cannot be used in combination with node_type_col)
            node_type_col (str): The node type col name in dataframe (optional) Defaults to None. (cannot be used in combination with node_type)
            constant_properties (List[str]): List of constant node property column names. Defaults to None. (optional)
            shared_constant_properties (dict): A dictionary of constant properties that will be added to every node. Defaults to None. (optional)

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_node_props_from_parquet(
        self,
        parquet_path: str,
        id: str,
        node_type: str = None,
        node_type_col: str = None,
        constant_properties: List[str] = None,
        shared_constant_properties: dict = None,
    ) -> None:
        """
        Load node properties from a parquet file.

        Arguments:
            parquet_path (str): Parquet file or directory of Parquet files path containing node information.
            id(str): The column name for the node IDs.
            node_type (str): A constant value to use as the node type for all nodes (optional). Defaults to None. (cannot be used in combination with node_type_col)
            node_type_col (str): The node type col name in dataframe (optional) Defaults to None. (cannot be used in combination with node_type)
            constant_properties (List[str]): List of constant node property column names. Defaults to None. (optional)
            shared_constant_properties (dict): A dictionary of constant properties that will be added to every node. Defaults to None. (optional)

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_nodes_from_pandas(
        self,
        df: DataFrame,
        time: str,
        id: str,
        node_type: str = None,
        node_type_col: str = None,
        properties: List[str] = None,
        constant_properties: List[str] = None,
        shared_constant_properties: dict = None,
    ) -> None:
        """
        Load nodes from a Pandas DataFrame into the graph.

        Arguments:
            df (DataFrame): The Pandas DataFrame containing the nodes.
            time (str): The column name for the timestamps.
            id (str): The column name for the node IDs.
            node_type (str): A constant value to use as the node type for all nodes (optional). Defaults to None. (cannot be used in combination with node_type_col)
            node_type_col (str): The node type col name in dataframe (optional) Defaults to None. (cannot be used in combination with node_type)
            properties (List[str]): List of node property column names. Defaults to None. (optional)
            constant_properties (List[str]): List of constant node property column names. Defaults to None.  (optional)
            shared_constant_properties (dict): A dictionary of constant properties that will be added to every node. Defaults to None. (optional)

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def load_nodes_from_parquet(
        self,
        parquet_path: str,
        time: str,
        id: str,
        node_type: str = None,
        node_type_col: str = None,
        properties: List[str] = None,
        constant_properties: List[str] = None,
        shared_constant_properties: dict = None,
    ) -> None:
        """
        Load nodes from a Parquet file into the graph.

        Arguments:
            parquet_path (str): Parquet file or directory of Parquet files containing the nodes
            time (str): The column name for the timestamps.
            id (str): The column name for the node IDs.
            node_type (str): A constant value to use as the node type for all nodes (optional). Defaults to None. (cannot be used in combination with node_type_col)
            node_type_col (str): The node type col name in dataframe (optional) Defaults to None. (cannot be used in combination with node_type)
            properties (List[str]): List of node property column names. Defaults to None. (optional)
            constant_properties (List[str]): List of constant node property column names. Defaults to None.  (optional)
            shared_constant_properties (dict): A dictionary of constant properties that will be added to every node. Defaults to None. (optional)

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def node(self, id: str | int):
        """
        Gets the node with the specified id

        Arguments:
          id (str | int): the node id

        Returns:
          The node with the specified id, or None if the node does not exist
        """

    def persistent_graph(self): ...
    def save_to_file(self, path: str):
        """
         Saves the PersistentGraph to the given path.

        Arguments:
         path (str): The path to the file.
        """

    def save_to_zip(self, path: str):
        """
         Saves the PersistentGraph to the given path.

        Arguments:
         path (str): The path to the file.
        """

    def serialise(self):
        """
         Serialise PersistentGraph to bytes.

        Returns:
          bytes
        """

    def update_constant_properties(self, properties: dict) -> None:
        """
        Updates static properties to the graph.

        Arguments:
            properties (dict): The static properties of the graph.

        Returns:
            None: This function does not return a value, if the operation is successful.

        Raises:
            GraphError: If the operation fails.
        """

    def write_updates(self):
        """Persist the new updates by appending them to the cache file."""

class Prop(object):
    """
    A reference to a property used for constructing filters

    Use `==`, `!=`, `<`, `<=`, `>`, `>=` to filter based on
    property value (these filters always exclude entities that do not
    have the property) or use one of the methods to construct
    other kinds of filters.
    """

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __le__(self, value):
        """Return self<=value."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __new__(cls, name) -> Prop:
        """Create and return a new object.  See help(type) for accurate signature."""

    def any(self, values):
        """Create a filter that keeps entities if their property value is in the set"""

    def is_none(self):
        """Create a filter that only keeps entities that do not have the property"""

    def is_some(self):
        """Create a filter that only keeps entities if they have the property"""

    def not_any(self, values):
        """
        Create a filter that keeps entities if their property value is not in the set or
        if they don't have the property
        """

class Properties(object):
    """A view of the properties of an entity"""

    def __contains__(self, key):
        """Return key in self."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def as_dict(self):
        """Convert properties view to a dict"""

    @property
    def constant(self):
        """Get a view of the constant properties (meta-data) only."""

    def get(self, key):
        """
        Get property value.

        First searches temporal properties and returns latest value if it exists.
        If not, it falls back to static properties.
        """

    def items(self):
        """Get a list of key-value pairs"""

    def keys(self):
        """Get the names for all properties (includes temporal and static properties)"""

    @property
    def temporal(self):
        """Get a view of the temporal properties only."""

    def values(self):
        """
        Get the values of the properties

        If a property exists as both temporal and static, temporal properties take priority with
        fallback to the static property if the temporal value does not exist.
        """

class PropertyFilter(object): ...

class PyGraphEncoder(object):
    def __call__(self, *args, **kwargs):
        """Call self as a function."""

    def __getstate__(self): ...
    def __new__(cls) -> PyGraphEncoder:
        """Create and return a new object.  See help(type) for accurate signature."""

    def __setstate__(self): ...

class TemporalProp(object):
    """A view of a temporal property"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def at(self, t):
        """Get the value of the property at time `t`"""

    def average(self) -> Prop:
        """
        Compute the average of all property values. Alias for mean().

        Returns:
            Prop: The average of each property values, or None if count is zero.
        """

    def count(self) -> int:
        """
        Count the number of properties.

        Returns:
            int: The number of properties.
        """

    def history(self):
        """Get the timestamps at which the property was updated"""

    def history_date_time(self):
        """Get the timestamps at which the property was updated"""

    def items(self):
        """List update timestamps and corresponding property values"""

    def items_date_time(self):
        """List update timestamps and corresponding property values"""

    def max(self):
        """
        Find the maximum property value and its associated time.

        Returns:
            (i64, Prop): A tuple containing the time and the maximum property value.
        """

    def mean(self) -> Prop:
        """
        Compute the mean of all property values. Alias for mean().

        Returns:
            Prop: The mean of each property values, or None if count is zero.
        """

    def median(self):
        """
        Compute the median of all property values.

        Returns:
            (i64, Prop): A tuple containing the time and the median property value, or None if empty
        """

    def min(self):
        """
        Find the minimum property value and its associated time.

        Returns:
            (i64, Prop): A tuple containing the time and the minimum property value.
        """

    def ordered_dedupe(self, latest_time): ...
    def sum(self) -> Prop:
        """
        Compute the sum of all property values.

        Returns:
            Prop: The sum of all property values.
        """

    def unique(self): ...
    def value(self):
        """Get the latest value of the property"""

    def values(self):
        """Get the property values for each update"""

class TemporalProperties(object):
    """A view of the temporal properties of an entity"""

    def __contains__(self, key):
        """Return key in self."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def get(self, key):
        """
        get(key: str) -> Optional[TemporalProp]

        Get property value for `key` if it exists

        Returns:
            the property view if it exists, otherwise `None`
        """

    def histories(self) -> dict[str, list[(int, Any)]]:
        """
        Get the histories of all properties

        Returns:
            dict[str, list[(int, Any)]]: the mapping of property keys to histories
        """

    def histories_date_time(self) -> dict[str, list[(datetime, Any)]]:
        """
        Get the histories of all properties

        Returns:
            dict[str, list[(datetime, Any)]]: the mapping of property keys to histories
        """

    def items(self):
        """List the property keys together with the corresponding values"""

    def keys(self):
        """List the available property keys"""

    def latest(self) -> dict[str, Any]:
        """
        Get the latest value of all properties

        Returns:
            dict[str, Any]: the mapping of property keys to latest values
        """

    def values(self) -> list[TemporalProp]:
        """
        List the values of the properties

        Returns:
            list[TemporalProp]: the list of property views
        """

class WindowSet(object):
    def __iter__(self):
        """Implement iter(self)."""

    def time_index(self, center: bool = False) -> Iterable:
        """
        Returns the time index of this window set

        It uses the last time of each window as the reference or the center of each if `center` is
        set to `True`

        Arguments:
            center (bool): if True time indexes are centered. Defaults to False

        Returns:
            Iterable: the time index"
        """
