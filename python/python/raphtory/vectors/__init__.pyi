from __future__ import annotations

###############################################################################
#                                                                             #
#                      AUTOGENERATED TYPE STUB FILE                           #
#                                                                             #
#    This file was automatically generated. Do not modify it directly.        #
#    Any changes made here may be lost when the file is regenerated.          #
#                                                                             #
###############################################################################

from typing import *
from raphtory import *
import raphtory.filter as filter
from raphtory.algorithms import *
from raphtory.node_state import *
from raphtory.graphql import *
from raphtory.typing import *
import numpy as np
from numpy.typing import NDArray
from datetime import datetime
from pandas import DataFrame
from pyarrow import DataType  # type: ignore[import-untyped]
from os import PathLike
import networkx as nx  # type: ignore
import pyvis  # type: ignore
from raphtory.iterables import *

__all__ = [
    "VectorisedGraph",
    "Document",
    "Embedding",
    "VectorSelection",
    "OpenAIEmbeddings",
    "embedding_server",
]

class VectorisedGraph(object):
    """VectorisedGraph object that contains embedded documents that correspond to graph entities."""

    def edges_by_similarity(
        self,
        query: str | list,
        limit: int,
        window: Optional[Tuple[int | str, int | str]] = None,
    ) -> VectorSelection:
        """
        Perform a similarity search between each edge's associated document and a specified `query`. Returns a number of edges up to a specified `limit` ranked in ascending order of distance.

        Args:
          query (str | list): The text or the embedding to calculate the distance from.
          limit (int): The maximum number of new edges in the results.
          window (Tuple[int | str, int | str], optional): The window that documents need to belong to in order to be considered.

        Returns:
          VectorSelection: The vector selection resulting from the search.
        """

    def empty_selection(self):
        """Return an empty selection of entities."""

    def entities_by_similarity(
        self,
        query: str | list,
        limit: int,
        window: Optional[Tuple[int | str, int | str]] = None,
    ) -> VectorSelection:
        """
        Perform a similarity search between each entity's associated document and a specified `query`. Returns a number of entities up to a specified `limit` ranked in ascending order of distance.

        Args:
          query (str | list): The text or the embedding to calculate the distance from.
          limit (int): The maximum number of new entities in the result.
          window (Tuple[int | str, int | str], optional): The window that documents need to belong to in order to be considered.

        Returns:
          VectorSelection: The vector selection resulting from the search.
        """

    def nodes_by_similarity(
        self,
        query: str | list,
        limit: int,
        window: Optional[Tuple[int | str, int | str]] = None,
    ) -> VectorSelection:
        """
        Perform a similarity search between each node's associated document and a specified `query`. Returns a number of nodes up to a specified `limit` ranked in ascending order of distance.

        Args:
          query (str | list): The text or the embedding to calculate the distance from.
          limit (int): The maximum number of new nodes in the result.
          window (Tuple[int | str, int | str], optional): The window where documents need to belong to in order to be considered.

        Returns:
          VectorSelection: The vector selection resulting from the search.
        """

    def optimize_index(self):
        """Optmize the vector index"""

class Document(object):
    """A document corresponding to a graph entity. Used to generate embeddings."""

    def __repr__(self):
        """Return repr(self)."""

    @property
    def content(self) -> str:
        """
        The document content.

        Returns:
            str: Content of the document.
        """

    @property
    def embedding(self) -> Optional[Embedding]:
        """
        The embedding of the document.

        Returns:
            Optional[Embedding]: The embedding of the document if it was computed.
        """

    @property
    def entity(self) -> Optional[Any]:
        """
        The graph entity corresponding to the document.

        Returns:
            Optional[Any]:
        """

class Embedding(object):
    def __repr__(self):
        """Return repr(self)."""

class VectorSelection(object):
    def add_edges(self, edges: list) -> None:
        """
        Add all the documents associated with the specified `edges` to the current selection.

        Documents added by this call are assumed to have a distance of 0.

        Args:
          edges (list):  List of the edge ids or edges to add.

        Returns:
            None:
        """

    def add_nodes(self, nodes: list) -> None:
        """
        Add all the documents associated with the specified `nodes` to the current selection.

        Documents added by this call are assumed to have a distance of 0.

        Args:
          nodes (list): List of the node ids or nodes to add.

        Returns:
            None:
        """

    def append(self, selection: VectorSelection) -> VectorSelection:
        """
        Add all the documents in a specified `selection` to the current selection.

        Args:
          selection (VectorSelection): Selection to be added.

        Returns:
          VectorSelection: The combined selection.
        """

    def edges(self) -> list[Edge]:
        """
        Returns the edges present in the current selection.

        Returns:
            list[Edge]: List of edges in the current selection.
        """

    def expand(
        self, hops: int, window: Optional[Tuple[int | str, int | str]] = None
    ) -> None:
        """
        Add all the documents a specified number of `hops` away from the selection.

        Two documents A and B are considered to be 1 hop away from each other if they are on the same
        entity or if they are on the same node/edge pair. Provided that two nodes A and C are n
        hops away of each other if there is a document B such that A is n - 1 hops away of B and B
        is 1 hop away of C.

        Args:
          hops (int): The number of hops to carry out the expansion.
          window (Tuple[int | str, int | str], optional): The window that documents need to belong to in order to be considered.

        Returns:
            None:
        """

    def expand_edges_by_similarity(
        self,
        query: str | list,
        limit: int,
        window: Optional[Tuple[int | str, int | str]] = None,
    ) -> None:
        """
        Add to the selection the `limit` adjacent edges closest to `query`

        This function has the same behaviour as expand_entities_by_similarity but it only considers edges.

        Args:
          query (str | list): The text or the embedding to calculate the distance from.
          limit (int): The maximum number of new edges to add.
          window (Tuple[int | str, int | str], optional): The window that documents need to belong to in order to be considered.

        Returns:
            None:
        """

    def expand_entities_by_similarity(
        self,
        query: str | list,
        limit: int,
        window: Optional[Tuple[int | str, int | str]] = None,
    ) -> None:
        """
        Add to the selection the `limit` adjacent entities closest to `query`

        The expansion algorithm is a loop with two steps on each iteration:

        1. All the entities 1 hop away of some of the entities included on the selection (and
           not already selected) are marked as candidates.
        2. Those candidates are added to the selection in ascending distance from `query`.

        This loops goes on until the number of new entities reaches a total of `limit`
        entities or until no more documents are available

        Args:
          query (str | list): The text or the embedding to calculate the distance from.
          limit (int): The number of documents to add.
          window (Tuple[int | str, int | str], optional): The window that documents need to belong to in order to be considered.

        Returns:
            None:
        """

    def expand_nodes_by_similarity(
        self,
        query: str | list,
        limit: int,
        window: Optional[Tuple[int | str, int | str]] = None,
    ) -> None:
        """
        Add to the selection the `limit` adjacent nodes closest to `query`

        This function has the same behaviour as expand_entities_by_similarity but it only considers nodes.

        Args:
          query (str | list): The text or the embedding to calculate the distance from.
          limit (int): The maximum number of new nodes to add.
          window (Tuple[int | str, int | str], optional): The window that documents need to belong to in order to be considered.

        Returns:
            None:
        """

    def get_documents(self) -> list[Document]:
        """
        Returns the documents present in the current selection.

        Returns:
            list[Document]: List of documents in the current selection.
        """

    def get_documents_with_distances(self) -> list[Tuple[Document, float]]:
        """
        Returns the documents present in the current selection alongside their distances.

        Returns:
            list[Tuple[Document, float]]: List of documents and distances.
        """

    def nodes(self) -> list[Node]:
        """
        Returns the nodes present in the current selection.

        Returns:
            list[Node]: List of nodes in the current selection.
        """

class OpenAIEmbeddings(object):
    def __new__(
        cls,
        model="text-embedding-3-small",
        api_base=None,
        api_key_env=None,
        org_id=None,
        project_id=None,
    ) -> OpenAIEmbeddings:
        """Create and return a new object.  See help(type) for accurate signature."""

def embedding_server(address): ...
