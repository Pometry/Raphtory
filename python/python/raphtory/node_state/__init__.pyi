###############################################################################
#                                                                             #
#                      AUTOGENERATED TYPE STUB FILE                           #
#                                                                             #
#    This file was automatically generated. Do not modify it directly.        #
#    Any changes made here may be lost when the file is regenerated.          #
#                                                                             #
###############################################################################

from typing import *
from raphtory import *
from raphtory.algorithms import *
from raphtory.vectors import *
from raphtory.node_state import *
from raphtory.graphql import *
from raphtory.typing import *
from datetime import datetime
from pandas import DataFrame

class DegreeView(object):
    """A lazy view over node values"""

    def __repr__(self):
        """Return repr(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __le__(self, value):
        """Return self<=value."""

    def __eq__(self, value):
        """Return self==value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __getitem__(self, key):
        """Return self[key]."""

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def default_layer(self) -> DegreeView:
        """
         Return a view of DegreeView containing only the default edge layer
        Returns:
             DegreeView: The layered view
        """

    def layer(self, name: str) -> DegreeView:
        """
         Return a view of DegreeView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             DegreeView: The layered view
        """

    def exclude_layer(self, name: str) -> DegreeView:
        """
         Return a view of DegreeView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             DegreeView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> DegreeView:
        """
         Return a view of DegreeView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             DegreeView: The layered view
        """

    def has_layer(self, name: str):
        """
         Check if DegreeView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool
        """

    def layers(self, names: list[str]) -> DegreeView:
        """
         Return a view of DegreeView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             DegreeView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> DegreeView:
        """
         Return a view of DegreeView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             DegreeView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> DegreeView:
        """
         Return a view of DegreeView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             DegreeView: The layered view
        """

    def valid_layers(self, names: list[str]) -> DegreeView:
        """
         Return a view of DegreeView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             DegreeView: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def window(self, start: TimeInput | None, end: TimeInput | None):
        """
         Create a view of the DegreeView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
        r    DegreeView
        """

    def at(self, time: TimeInput):
        """
         Create a view of the DegreeView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             DegreeView
        """

    def latest(self):
        """
         Create a view of the DegreeView including all events at the latest time.

        Returns:
             DegreeView
        """

    def snapshot_at(self, time: TimeInput):
        """
         Create a view of the DegreeView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `EventGraph`s and `at(time)` for `PersitentGraph`s

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             DegreeView
        """

    def snapshot_latest(self):
        """
         Create a view of the DegreeView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `EventGraph`s and `latest()` for `PersitentGraph`s

        Returns:
             DegreeView
        """

    def before(self, end: TimeInput):
        """
         Create a view of the DegreeView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             DegreeView
        """

    def after(self, start: TimeInput):
        """
         Create a view of the DegreeView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             DegreeView
        """

    def shrink_start(self, start: TimeInput):
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             DegreeView
        """

    def shrink_end(self, end: TimeInput):
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             DegreeView
        """

    def shrink_window(self, start: TimeInput, end: TimeInput):
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        """

    def sum(self) -> int:
        """
        sum of values over all nodes

        Returns:
                int: the sum
        """

    def mean(self) -> float:
        """
        mean of values over all nodes

        Returns:
            float: mean value
        """

    def sorted(self, reverse: bool = False) -> NodeStateUsize:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateUsize: Sorted node state
        """

    def top_k(self, k: int) -> NodeStateUsize:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateUsize: The k largest values as a node state
        """

    def bottom_k(self, k: int) -> NodeStateUsize:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateUsize: The k smallest values as a node state
        """

    def min_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The Node and minimum value or `None` if empty
        """

    def min(self) -> Optional[int]:
        """
        Return the minimum value

        Returns:
             Optional[int]: The minimum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The Node and maximum value or `None` if empty
        """

    def max(self) -> Optional[int]:
        """
        Return the maximum value

        Returns:
             Optional[int]: The maximum value or `None` if empty
        """

    def median(self):
        """
        Return the median value

        Returns:
             Optional[int]
        """

    def median_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The median value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def items(self):
        """
        Returns:
             Iterator[Tuple[Node, int]]: Iterator over items
        """

    def values(self):
        """
        Returns:
             Iterator[int]: Iterator over values
        """

    def sorted_by_id(self) -> NodeStateUsize:
        """
        Sort results by node id

        Returns:
             NodeStateUsize: The sorted node state
        """

    def compute(self):
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateUsize
        """

    def collect(self):
        """
        Compute all values and return the result as a list

        Returns
             list[int]: all values as a list
        """

    @property
    def end(self):
        """
         Gets the latest time that this DegreeView is valid.

        Returns:
           Optional[int]: The latest time that this DegreeView is valid or None if the DegreeView is valid for all times.
        """

    @property
    def end_date_time(self):
        """
         Gets the latest datetime that this DegreeView is valid

        Returns:
             Optional[Datetime]: The latest datetime that this DegreeView is valid or None if the DegreeView is valid for all times.
        """

    @property
    def start(self):
        """
         Gets the start time for rolling and expanding windows for this DegreeView

        Returns:
            Optional[int]: The earliest time that this DegreeView is valid or None if the DegreeView is valid for all times.
        """

    @property
    def start_date_time(self):
        """
         Gets the earliest datetime that this DegreeView is valid

        Returns:
             Optional[Datetime]: The earliest datetime that this DegreeView is valid or None if the DegreeView is valid for all times.
        """

    @property
    def window_size(self):
        """
         Get the window size (difference between start and end) for this DegreeView

        Returns:
            Optional[int]
        """

class NodeStateUsize(object):
    def __repr__(self):
        """Return repr(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __le__(self, value):
        """Return self<=value."""

    def __eq__(self, value):
        """Return self==value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __getitem__(self, key):
        """Return self[key]."""

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def sum(self) -> int:
        """
        sum of values over all nodes

        Returns:
                int: the sum
        """

    def mean(self) -> float:
        """
        mean of values over all nodes

        Returns:
            float: mean value
        """

    def sorted(self, reverse: bool = False) -> NodeStateUsize:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateUsize: Sorted node state
        """

    def top_k(self, k: int) -> NodeStateUsize:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateUsize: The k largest values as a node state
        """

    def bottom_k(self, k: int) -> NodeStateUsize:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateUsize: The k smallest values as a node state
        """

    def min_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The Node and minimum value or `None` if empty
        """

    def min(self) -> Optional[int]:
        """
        Return the minimum value

        Returns:
             Optional[int]: The minimum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The Node and maximum value or `None` if empty
        """

    def max(self) -> Optional[int]:
        """
        Return the maximum value

        Returns:
             Optional[int]: The maximum value or `None` if empty
        """

    def median(self):
        """
        Return the median value

        Returns:
             Optional[int]
        """

    def median_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The median value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def items(self):
        """
        Returns:
             Iterator[Tuple[Node, int]]: Iterator over items
        """

    def values(self):
        """
        Returns:
             Iterator[int]: Iterator over values
        """

    def sorted_by_id(self) -> NodeStateUsize:
        """
        Sort results by node id

        Returns:
             NodeStateUsize: The sorted node state
        """

class NodeStateU64(object):
    def __repr__(self):
        """Return repr(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __le__(self, value):
        """Return self<=value."""

    def __eq__(self, value):
        """Return self==value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __getitem__(self, key):
        """Return self[key]."""

    def sum(self) -> int:
        """
        sum of values over all nodes

        Returns:
                int: the sum
        """

    def mean(self) -> float:
        """
        mean of values over all nodes

        Returns:
            float: mean value
        """

    def sorted(self, reverse: bool = False) -> NodeStateU64:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateU64: Sorted node state
        """

    def top_k(self, k: int) -> NodeStateU64:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateU64: The k largest values as a node state
        """

    def bottom_k(self, k: int) -> NodeStateU64:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateU64: The k smallest values as a node state
        """

    def min_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The Node and minimum value or `None` if empty
        """

    def min(self) -> Optional[int]:
        """
        Return the minimum value

        Returns:
             Optional[int]: The minimum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The Node and maximum value or `None` if empty
        """

    def max(self) -> Optional[int]:
        """
        Return the maximum value

        Returns:
             Optional[int]: The maximum value or `None` if empty
        """

    def median(self):
        """
        Return the median value

        Returns:
             Optional[int]
        """

    def median_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The median value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def items(self):
        """
        Returns:
             Iterator[Tuple[Node, int]]: Iterator over items
        """

    def values(self):
        """
        Returns:
             Iterator[int]: Iterator over values
        """

    def sorted_by_id(self) -> NodeStateU64:
        """
        Sort results by node id

        Returns:
             NodeStateU64: The sorted node state
        """

class IdView(object):
    """A lazy view over node values"""

    def __repr__(self):
        """Return repr(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __le__(self, value):
        """Return self<=value."""

    def __eq__(self, value):
        """Return self==value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __getitem__(self, key):
        """Return self[key]."""

    def sorted(self, reverse: bool = False) -> NodeStateGID:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateGID: Sorted node state
        """

    def top_k(self, k: int) -> NodeStateGID:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateGID: The k largest values as a node state
        """

    def bottom_k(self, k: int) -> NodeStateGID:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateGID: The k smallest values as a node state
        """

    def min_item(self) -> Optional[Tuple[Node, GID]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, GID]]: The Node and minimum value or `None` if empty
        """

    def min(self) -> Optional[GID]:
        """
        Return the minimum value

        Returns:
             Optional[GID]: The minimum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, GID]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, GID]]: The Node and maximum value or `None` if empty
        """

    def max(self) -> Optional[GID]:
        """
        Return the maximum value

        Returns:
             Optional[GID]: The maximum value or `None` if empty
        """

    def median(self):
        """
        Return the median value

        Returns:
             Optional[GID]
        """

    def median_item(self) -> Optional[Tuple[Node, GID]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, GID]]: The median value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def items(self):
        """
        Returns:
             Iterator[Tuple[Node, GID]]: Iterator over items
        """

    def values(self):
        """
        Returns:
             Iterator[GID]: Iterator over values
        """

    def sorted_by_id(self) -> NodeStateGID:
        """
        Sort results by node id

        Returns:
             NodeStateGID: The sorted node state
        """

    def compute(self):
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateGID
        """

    def collect(self):
        """
        Compute all values and return the result as a list

        Returns
             list[GID]: all values as a list
        """

class NodeStateGID(object):
    def __repr__(self):
        """Return repr(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __le__(self, value):
        """Return self<=value."""

    def __eq__(self, value):
        """Return self==value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __getitem__(self, key):
        """Return self[key]."""

    def sorted(self, reverse: bool = False) -> NodeStateGID:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateGID: Sorted node state
        """

    def top_k(self, k: int) -> NodeStateGID:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateGID: The k largest values as a node state
        """

    def bottom_k(self, k: int) -> NodeStateGID:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateGID: The k smallest values as a node state
        """

    def min_item(self) -> Optional[Tuple[Node, GID]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, GID]]: The Node and minimum value or `None` if empty
        """

    def min(self) -> Optional[GID]:
        """
        Return the minimum value

        Returns:
             Optional[GID]: The minimum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, GID]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, GID]]: The Node and maximum value or `None` if empty
        """

    def max(self) -> Optional[GID]:
        """
        Return the maximum value

        Returns:
             Optional[GID]: The maximum value or `None` if empty
        """

    def median(self):
        """
        Return the median value

        Returns:
             Optional[GID]
        """

    def median_item(self) -> Optional[Tuple[Node, GID]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, GID]]: The median value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def items(self):
        """
        Returns:
             Iterator[Tuple[Node, GID]]: Iterator over items
        """

    def values(self):
        """
        Returns:
             Iterator[GID]: Iterator over values
        """

    def sorted_by_id(self) -> NodeStateGID:
        """
        Sort results by node id

        Returns:
             NodeStateGID: The sorted node state
        """

class EarliestTimeView(object):
    """A lazy view over node values"""

    def __repr__(self):
        """Return repr(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __le__(self, value):
        """Return self<=value."""

    def __eq__(self, value):
        """Return self==value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __getitem__(self, key):
        """Return self[key]."""

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def default_layer(self) -> EarliestTimeView:
        """
         Return a view of EarliestTimeView containing only the default edge layer
        Returns:
             EarliestTimeView: The layered view
        """

    def layer(self, name: str) -> EarliestTimeView:
        """
         Return a view of EarliestTimeView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             EarliestTimeView: The layered view
        """

    def exclude_layer(self, name: str) -> EarliestTimeView:
        """
         Return a view of EarliestTimeView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             EarliestTimeView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> EarliestTimeView:
        """
         Return a view of EarliestTimeView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             EarliestTimeView: The layered view
        """

    def has_layer(self, name: str):
        """
         Check if EarliestTimeView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool
        """

    def layers(self, names: list[str]) -> EarliestTimeView:
        """
         Return a view of EarliestTimeView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             EarliestTimeView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> EarliestTimeView:
        """
         Return a view of EarliestTimeView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             EarliestTimeView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> EarliestTimeView:
        """
         Return a view of EarliestTimeView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             EarliestTimeView: The layered view
        """

    def valid_layers(self, names: list[str]) -> EarliestTimeView:
        """
         Return a view of EarliestTimeView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             EarliestTimeView: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def window(self, start: TimeInput | None, end: TimeInput | None):
        """
         Create a view of the EarliestTimeView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
        r    EarliestTimeView
        """

    def at(self, time: TimeInput):
        """
         Create a view of the EarliestTimeView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             EarliestTimeView
        """

    def latest(self):
        """
         Create a view of the EarliestTimeView including all events at the latest time.

        Returns:
             EarliestTimeView
        """

    def snapshot_at(self, time: TimeInput):
        """
         Create a view of the EarliestTimeView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `EventGraph`s and `at(time)` for `PersitentGraph`s

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             EarliestTimeView
        """

    def snapshot_latest(self):
        """
         Create a view of the EarliestTimeView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `EventGraph`s and `latest()` for `PersitentGraph`s

        Returns:
             EarliestTimeView
        """

    def before(self, end: TimeInput):
        """
         Create a view of the EarliestTimeView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             EarliestTimeView
        """

    def after(self, start: TimeInput):
        """
         Create a view of the EarliestTimeView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             EarliestTimeView
        """

    def shrink_start(self, start: TimeInput):
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             EarliestTimeView
        """

    def shrink_end(self, end: TimeInput):
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             EarliestTimeView
        """

    def shrink_window(self, start: TimeInput, end: TimeInput):
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        """

    def sorted(self, reverse: bool = False):
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionI64: Sorted node state
        """

    def top_k(self, k: int):
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionI64: The k largest values as a node state
        """

    def bottom_k(self, k: int):
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionI64: The k smallest values as a node state
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and minimum value or `None` if empty
        """

    def min(self) -> Optional[Optional[int]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[int]]: The minimum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and maximum value or `None` if empty
        """

    def max(self) -> Optional[Optional[int]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[int]]: The maximum value or `None` if empty
        """

    def median(self):
        """
        Return the median value

        Returns:
             Optional[Optional[int]]
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The median value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def items(self):
        """
        Returns:
             Iterator[Tuple[Node, Optional[int]]]: Iterator over items
        """

    def values(self):
        """
        Returns:
             Iterator[Optional[int]]: Iterator over values
        """

    def sorted_by_id(self):
        """
        Sort results by node id

        Returns:
             NodeStateOptionI64: The sorted node state
        """

    def compute(self):
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateOptionI64
        """

    def collect(self):
        """
        Compute all values and return the result as a list

        Returns
             list[Optional[int]]: all values as a list
        """

    @property
    def start_date_time(self):
        """
         Gets the earliest datetime that this EarliestTimeView is valid

        Returns:
             Optional[Datetime]: The earliest datetime that this EarliestTimeView is valid or None if the EarliestTimeView is valid for all times.
        """

    @property
    def start(self):
        """
         Gets the start time for rolling and expanding windows for this EarliestTimeView

        Returns:
            Optional[int]: The earliest time that this EarliestTimeView is valid or None if the EarliestTimeView is valid for all times.
        """

    @property
    def end_date_time(self):
        """
         Gets the latest datetime that this EarliestTimeView is valid

        Returns:
             Optional[Datetime]: The latest datetime that this EarliestTimeView is valid or None if the EarliestTimeView is valid for all times.
        """

    @property
    def window_size(self):
        """
         Get the window size (difference between start and end) for this EarliestTimeView

        Returns:
            Optional[int]
        """

    @property
    def end(self):
        """
         Gets the latest time that this EarliestTimeView is valid.

        Returns:
           Optional[int]: The latest time that this EarliestTimeView is valid or None if the EarliestTimeView is valid for all times.
        """

class LatestTimeView(object):
    """A lazy view over node values"""

    def __repr__(self):
        """Return repr(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __le__(self, value):
        """Return self<=value."""

    def __eq__(self, value):
        """Return self==value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __getitem__(self, key):
        """Return self[key]."""

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def default_layer(self) -> LatestTimeView:
        """
         Return a view of LatestTimeView containing only the default edge layer
        Returns:
             LatestTimeView: The layered view
        """

    def layer(self, name: str) -> LatestTimeView:
        """
         Return a view of LatestTimeView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             LatestTimeView: The layered view
        """

    def exclude_layer(self, name: str) -> LatestTimeView:
        """
         Return a view of LatestTimeView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             LatestTimeView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> LatestTimeView:
        """
         Return a view of LatestTimeView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             LatestTimeView: The layered view
        """

    def has_layer(self, name: str):
        """
         Check if LatestTimeView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool
        """

    def layers(self, names: list[str]) -> LatestTimeView:
        """
         Return a view of LatestTimeView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             LatestTimeView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> LatestTimeView:
        """
         Return a view of LatestTimeView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             LatestTimeView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> LatestTimeView:
        """
         Return a view of LatestTimeView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             LatestTimeView: The layered view
        """

    def valid_layers(self, names: list[str]) -> LatestTimeView:
        """
         Return a view of LatestTimeView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             LatestTimeView: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def window(self, start: TimeInput | None, end: TimeInput | None):
        """
         Create a view of the LatestTimeView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
        r    LatestTimeView
        """

    def at(self, time: TimeInput):
        """
         Create a view of the LatestTimeView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             LatestTimeView
        """

    def latest(self):
        """
         Create a view of the LatestTimeView including all events at the latest time.

        Returns:
             LatestTimeView
        """

    def snapshot_at(self, time: TimeInput):
        """
         Create a view of the LatestTimeView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `EventGraph`s and `at(time)` for `PersitentGraph`s

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             LatestTimeView
        """

    def snapshot_latest(self):
        """
         Create a view of the LatestTimeView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `EventGraph`s and `latest()` for `PersitentGraph`s

        Returns:
             LatestTimeView
        """

    def before(self, end: TimeInput):
        """
         Create a view of the LatestTimeView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             LatestTimeView
        """

    def after(self, start: TimeInput):
        """
         Create a view of the LatestTimeView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             LatestTimeView
        """

    def shrink_start(self, start: TimeInput):
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             LatestTimeView
        """

    def shrink_end(self, end: TimeInput):
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             LatestTimeView
        """

    def shrink_window(self, start: TimeInput, end: TimeInput):
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        """

    def sorted(self, reverse: bool = False):
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionI64: Sorted node state
        """

    def top_k(self, k: int):
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionI64: The k largest values as a node state
        """

    def bottom_k(self, k: int):
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionI64: The k smallest values as a node state
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and minimum value or `None` if empty
        """

    def min(self) -> Optional[Optional[int]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[int]]: The minimum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and maximum value or `None` if empty
        """

    def max(self) -> Optional[Optional[int]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[int]]: The maximum value or `None` if empty
        """

    def median(self):
        """
        Return the median value

        Returns:
             Optional[Optional[int]]
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The median value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def items(self):
        """
        Returns:
             Iterator[Tuple[Node, Optional[int]]]: Iterator over items
        """

    def values(self):
        """
        Returns:
             Iterator[Optional[int]]: Iterator over values
        """

    def sorted_by_id(self):
        """
        Sort results by node id

        Returns:
             NodeStateOptionI64: The sorted node state
        """

    def compute(self):
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateOptionI64
        """

    def collect(self):
        """
        Compute all values and return the result as a list

        Returns
             list[Optional[int]]: all values as a list
        """

    @property
    def end(self):
        """
         Gets the latest time that this LatestTimeView is valid.

        Returns:
           Optional[int]: The latest time that this LatestTimeView is valid or None if the LatestTimeView is valid for all times.
        """

    @property
    def start_date_time(self):
        """
         Gets the earliest datetime that this LatestTimeView is valid

        Returns:
             Optional[Datetime]: The earliest datetime that this LatestTimeView is valid or None if the LatestTimeView is valid for all times.
        """

    @property
    def end_date_time(self):
        """
         Gets the latest datetime that this LatestTimeView is valid

        Returns:
             Optional[Datetime]: The latest datetime that this LatestTimeView is valid or None if the LatestTimeView is valid for all times.
        """

    @property
    def start(self):
        """
         Gets the start time for rolling and expanding windows for this LatestTimeView

        Returns:
            Optional[int]: The earliest time that this LatestTimeView is valid or None if the LatestTimeView is valid for all times.
        """

    @property
    def window_size(self):
        """
         Get the window size (difference between start and end) for this LatestTimeView

        Returns:
            Optional[int]
        """

class NameView(object):
    """A lazy view over node values"""

    def __repr__(self):
        """Return repr(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __le__(self, value):
        """Return self<=value."""

    def __eq__(self, value):
        """Return self==value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __getitem__(self, key):
        """Return self[key]."""

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateString:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateString: Sorted node state
        """

    def top_k(self, k: int) -> NodeStateString:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateString: The k largest values as a node state
        """

    def bottom_k(self, k: int) -> NodeStateString:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateString: The k smallest values as a node state
        """

    def min_item(self) -> Optional[Tuple[Node, str]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, str]]: The Node and minimum value or `None` if empty
        """

    def min(self) -> Optional[str]:
        """
        Return the minimum value

        Returns:
             Optional[str]: The minimum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, str]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, str]]: The Node and maximum value or `None` if empty
        """

    def max(self) -> Optional[str]:
        """
        Return the maximum value

        Returns:
             Optional[str]: The maximum value or `None` if empty
        """

    def median(self):
        """
        Return the median value

        Returns:
             Optional[str]
        """

    def median_item(self) -> Optional[Tuple[Node, str]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, str]]: The median value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def items(self):
        """
        Returns:
             Iterator[Tuple[Node, str]]: Iterator over items
        """

    def values(self):
        """
        Returns:
             Iterator[str]: Iterator over values
        """

    def sorted_by_id(self) -> NodeStateString:
        """
        Sort results by node id

        Returns:
             NodeStateString: The sorted node state
        """

    def compute(self):
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateString
        """

    def collect(self):
        """
        Compute all values and return the result as a list

        Returns
             list[str]: all values as a list
        """

class NodeStateString(object):
    def __repr__(self):
        """Return repr(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __le__(self, value):
        """Return self<=value."""

    def __eq__(self, value):
        """Return self==value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __getitem__(self, key):
        """Return self[key]."""

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateString:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateString: Sorted node state
        """

    def top_k(self, k: int) -> NodeStateString:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateString: The k largest values as a node state
        """

    def bottom_k(self, k: int) -> NodeStateString:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateString: The k smallest values as a node state
        """

    def min_item(self) -> Optional[Tuple[Node, str]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, str]]: The Node and minimum value or `None` if empty
        """

    def min(self) -> Optional[str]:
        """
        Return the minimum value

        Returns:
             Optional[str]: The minimum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, str]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, str]]: The Node and maximum value or `None` if empty
        """

    def max(self) -> Optional[str]:
        """
        Return the maximum value

        Returns:
             Optional[str]: The maximum value or `None` if empty
        """

    def median(self):
        """
        Return the median value

        Returns:
             Optional[str]
        """

    def median_item(self) -> Optional[Tuple[Node, str]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, str]]: The median value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def items(self):
        """
        Returns:
             Iterator[Tuple[Node, str]]: Iterator over items
        """

    def values(self):
        """
        Returns:
             Iterator[str]: Iterator over values
        """

    def sorted_by_id(self) -> NodeStateString:
        """
        Sort results by node id

        Returns:
             NodeStateString: The sorted node state
        """

class EarliestDateTimeView(object):
    """A lazy view over node values"""

    def __repr__(self):
        """Return repr(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __le__(self, value):
        """Return self<=value."""

    def __eq__(self, value):
        """Return self==value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __getitem__(self, key):
        """Return self[key]."""

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def default_layer(self) -> EarliestDateTimeView:
        """
         Return a view of EarliestDateTimeView containing only the default edge layer
        Returns:
             EarliestDateTimeView: The layered view
        """

    def layer(self, name: str) -> EarliestDateTimeView:
        """
         Return a view of EarliestDateTimeView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             EarliestDateTimeView: The layered view
        """

    def exclude_layer(self, name: str) -> EarliestDateTimeView:
        """
         Return a view of EarliestDateTimeView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             EarliestDateTimeView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> EarliestDateTimeView:
        """
         Return a view of EarliestDateTimeView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             EarliestDateTimeView: The layered view
        """

    def has_layer(self, name: str):
        """
         Check if EarliestDateTimeView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool
        """

    def layers(self, names: list[str]) -> EarliestDateTimeView:
        """
         Return a view of EarliestDateTimeView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             EarliestDateTimeView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> EarliestDateTimeView:
        """
         Return a view of EarliestDateTimeView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             EarliestDateTimeView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> EarliestDateTimeView:
        """
         Return a view of EarliestDateTimeView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             EarliestDateTimeView: The layered view
        """

    def valid_layers(self, names: list[str]) -> EarliestDateTimeView:
        """
         Return a view of EarliestDateTimeView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             EarliestDateTimeView: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def window(self, start: TimeInput | None, end: TimeInput | None):
        """
         Create a view of the EarliestDateTimeView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
        r    EarliestDateTimeView
        """

    def at(self, time: TimeInput):
        """
         Create a view of the EarliestDateTimeView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             EarliestDateTimeView
        """

    def latest(self):
        """
         Create a view of the EarliestDateTimeView including all events at the latest time.

        Returns:
             EarliestDateTimeView
        """

    def snapshot_at(self, time: TimeInput):
        """
         Create a view of the EarliestDateTimeView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `EventGraph`s and `at(time)` for `PersitentGraph`s

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             EarliestDateTimeView
        """

    def snapshot_latest(self):
        """
         Create a view of the EarliestDateTimeView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `EventGraph`s and `latest()` for `PersitentGraph`s

        Returns:
             EarliestDateTimeView
        """

    def before(self, end: TimeInput):
        """
         Create a view of the EarliestDateTimeView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             EarliestDateTimeView
        """

    def after(self, start: TimeInput):
        """
         Create a view of the EarliestDateTimeView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             EarliestDateTimeView
        """

    def shrink_start(self, start: TimeInput):
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             EarliestDateTimeView
        """

    def shrink_end(self, end: TimeInput):
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             EarliestDateTimeView
        """

    def shrink_window(self, start: TimeInput, end: TimeInput):
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionDateTime:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionDateTime: Sorted node state
        """

    def top_k(self, k: int) -> NodeStateOptionDateTime:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionDateTime: The k largest values as a node state
        """

    def bottom_k(self, k: int) -> NodeStateOptionDateTime:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionDateTime: The k smallest values as a node state
        """

    def min_item(self):
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[Datetime]]]: The Node and minimum value or `None` if empty
        """

    def min(self):
        """
        Return the minimum value

        Returns:
             Optional[Optional[Datetime]]: The minimum value or `None` if empty
        """

    def max_item(self):
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[Datetime]]]: The Node and maximum value or `None` if empty
        """

    def max(self):
        """
        Return the maximum value

        Returns:
             Optional[Optional[Datetime]]: The maximum value or `None` if empty
        """

    def median(self):
        """
        Return the median value

        Returns:
             Optional[Optional[Datetime]]
        """

    def median_item(self):
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[Datetime]]]: The median value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def items(self):
        """
        Returns:
             Iterator[Tuple[Node, Optional[Datetime]]]: Iterator over items
        """

    def values(self):
        """
        Returns:
             Iterator[Optional[Datetime]]: Iterator over values
        """

    def sorted_by_id(self) -> NodeStateOptionDateTime:
        """
        Sort results by node id

        Returns:
             NodeStateOptionDateTime: The sorted node state
        """

    def compute(self):
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateOptionDateTime
        """

    def collect(self):
        """
        Compute all values and return the result as a list

        Returns
             list[Optional[Datetime]]: all values as a list
        """

    @property
    def window_size(self):
        """
         Get the window size (difference between start and end) for this EarliestDateTimeView

        Returns:
            Optional[int]
        """

    @property
    def start(self):
        """
         Gets the start time for rolling and expanding windows for this EarliestDateTimeView

        Returns:
            Optional[int]: The earliest time that this EarliestDateTimeView is valid or None if the EarliestDateTimeView is valid for all times.
        """

    @property
    def start_date_time(self):
        """
         Gets the earliest datetime that this EarliestDateTimeView is valid

        Returns:
             Optional[Datetime]: The earliest datetime that this EarliestDateTimeView is valid or None if the EarliestDateTimeView is valid for all times.
        """

    @property
    def end_date_time(self):
        """
         Gets the latest datetime that this EarliestDateTimeView is valid

        Returns:
             Optional[Datetime]: The latest datetime that this EarliestDateTimeView is valid or None if the EarliestDateTimeView is valid for all times.
        """

    @property
    def end(self):
        """
         Gets the latest time that this EarliestDateTimeView is valid.

        Returns:
           Optional[int]: The latest time that this EarliestDateTimeView is valid or None if the EarliestDateTimeView is valid for all times.
        """

class LatestDateTimeView(object):
    """A lazy view over node values"""

    def __repr__(self):
        """Return repr(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __le__(self, value):
        """Return self<=value."""

    def __eq__(self, value):
        """Return self==value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __getitem__(self, key):
        """Return self[key]."""

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def default_layer(self) -> LatestDateTimeView:
        """
         Return a view of LatestDateTimeView containing only the default edge layer
        Returns:
             LatestDateTimeView: The layered view
        """

    def layer(self, name: str) -> LatestDateTimeView:
        """
         Return a view of LatestDateTimeView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             LatestDateTimeView: The layered view
        """

    def exclude_layer(self, name: str) -> LatestDateTimeView:
        """
         Return a view of LatestDateTimeView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             LatestDateTimeView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> LatestDateTimeView:
        """
         Return a view of LatestDateTimeView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             LatestDateTimeView: The layered view
        """

    def has_layer(self, name: str):
        """
         Check if LatestDateTimeView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool
        """

    def layers(self, names: list[str]) -> LatestDateTimeView:
        """
         Return a view of LatestDateTimeView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             LatestDateTimeView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> LatestDateTimeView:
        """
         Return a view of LatestDateTimeView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             LatestDateTimeView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> LatestDateTimeView:
        """
         Return a view of LatestDateTimeView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             LatestDateTimeView: The layered view
        """

    def valid_layers(self, names: list[str]) -> LatestDateTimeView:
        """
         Return a view of LatestDateTimeView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             LatestDateTimeView: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def window(self, start: TimeInput | None, end: TimeInput | None):
        """
         Create a view of the LatestDateTimeView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
        r    LatestDateTimeView
        """

    def at(self, time: TimeInput):
        """
         Create a view of the LatestDateTimeView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             LatestDateTimeView
        """

    def latest(self):
        """
         Create a view of the LatestDateTimeView including all events at the latest time.

        Returns:
             LatestDateTimeView
        """

    def snapshot_at(self, time: TimeInput):
        """
         Create a view of the LatestDateTimeView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `EventGraph`s and `at(time)` for `PersitentGraph`s

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             LatestDateTimeView
        """

    def snapshot_latest(self):
        """
         Create a view of the LatestDateTimeView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `EventGraph`s and `latest()` for `PersitentGraph`s

        Returns:
             LatestDateTimeView
        """

    def before(self, end: TimeInput):
        """
         Create a view of the LatestDateTimeView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             LatestDateTimeView
        """

    def after(self, start: TimeInput):
        """
         Create a view of the LatestDateTimeView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             LatestDateTimeView
        """

    def shrink_start(self, start: TimeInput):
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             LatestDateTimeView
        """

    def shrink_end(self, end: TimeInput):
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             LatestDateTimeView
        """

    def shrink_window(self, start: TimeInput, end: TimeInput):
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionDateTime:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionDateTime: Sorted node state
        """

    def top_k(self, k: int) -> NodeStateOptionDateTime:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionDateTime: The k largest values as a node state
        """

    def bottom_k(self, k: int) -> NodeStateOptionDateTime:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionDateTime: The k smallest values as a node state
        """

    def min_item(self):
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[Datetime]]]: The Node and minimum value or `None` if empty
        """

    def min(self):
        """
        Return the minimum value

        Returns:
             Optional[Optional[Datetime]]: The minimum value or `None` if empty
        """

    def max_item(self):
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[Datetime]]]: The Node and maximum value or `None` if empty
        """

    def max(self):
        """
        Return the maximum value

        Returns:
             Optional[Optional[Datetime]]: The maximum value or `None` if empty
        """

    def median(self):
        """
        Return the median value

        Returns:
             Optional[Optional[Datetime]]
        """

    def median_item(self):
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[Datetime]]]: The median value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def items(self):
        """
        Returns:
             Iterator[Tuple[Node, Optional[Datetime]]]: Iterator over items
        """

    def values(self):
        """
        Returns:
             Iterator[Optional[Datetime]]: Iterator over values
        """

    def sorted_by_id(self) -> NodeStateOptionDateTime:
        """
        Sort results by node id

        Returns:
             NodeStateOptionDateTime: The sorted node state
        """

    def compute(self):
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateOptionDateTime
        """

    def collect(self):
        """
        Compute all values and return the result as a list

        Returns
             list[Optional[Datetime]]: all values as a list
        """

    @property
    def window_size(self):
        """
         Get the window size (difference between start and end) for this LatestDateTimeView

        Returns:
            Optional[int]
        """

    @property
    def end(self):
        """
         Gets the latest time that this LatestDateTimeView is valid.

        Returns:
           Optional[int]: The latest time that this LatestDateTimeView is valid or None if the LatestDateTimeView is valid for all times.
        """

    @property
    def start_date_time(self):
        """
         Gets the earliest datetime that this LatestDateTimeView is valid

        Returns:
             Optional[Datetime]: The earliest datetime that this LatestDateTimeView is valid or None if the LatestDateTimeView is valid for all times.
        """

    @property
    def end_date_time(self):
        """
         Gets the latest datetime that this LatestDateTimeView is valid

        Returns:
             Optional[Datetime]: The latest datetime that this LatestDateTimeView is valid or None if the LatestDateTimeView is valid for all times.
        """

    @property
    def start(self):
        """
         Gets the start time for rolling and expanding windows for this LatestDateTimeView

        Returns:
            Optional[int]: The earliest time that this LatestDateTimeView is valid or None if the LatestDateTimeView is valid for all times.
        """

class NodeStateOptionDateTime(object):
    def __repr__(self):
        """Return repr(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __le__(self, value):
        """Return self<=value."""

    def __eq__(self, value):
        """Return self==value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __getitem__(self, key):
        """Return self[key]."""

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionDateTime:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionDateTime: Sorted node state
        """

    def top_k(self, k: int) -> NodeStateOptionDateTime:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionDateTime: The k largest values as a node state
        """

    def bottom_k(self, k: int) -> NodeStateOptionDateTime:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionDateTime: The k smallest values as a node state
        """

    def min_item(self):
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[Datetime]]]: The Node and minimum value or `None` if empty
        """

    def min(self):
        """
        Return the minimum value

        Returns:
             Optional[Optional[Datetime]]: The minimum value or `None` if empty
        """

    def max_item(self):
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[Datetime]]]: The Node and maximum value or `None` if empty
        """

    def max(self):
        """
        Return the maximum value

        Returns:
             Optional[Optional[Datetime]]: The maximum value or `None` if empty
        """

    def median(self):
        """
        Return the median value

        Returns:
             Optional[Optional[Datetime]]
        """

    def median_item(self):
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[Datetime]]]: The median value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def items(self):
        """
        Returns:
             Iterator[Tuple[Node, Optional[Datetime]]]: Iterator over items
        """

    def values(self):
        """
        Returns:
             Iterator[Optional[Datetime]]: Iterator over values
        """

    def sorted_by_id(self) -> NodeStateOptionDateTime:
        """
        Sort results by node id

        Returns:
             NodeStateOptionDateTime: The sorted node state
        """

class HistoryView(object):
    """A lazy view over node values"""

    def __repr__(self):
        """Return repr(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __le__(self, value):
        """Return self<=value."""

    def __eq__(self, value):
        """Return self==value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __getitem__(self, key):
        """Return self[key]."""

    def default_layer(self) -> HistoryView:
        """
         Return a view of HistoryView containing only the default edge layer
        Returns:
             HistoryView: The layered view
        """

    def layer(self, name: str) -> HistoryView:
        """
         Return a view of HistoryView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             HistoryView: The layered view
        """

    def exclude_layer(self, name: str) -> HistoryView:
        """
         Return a view of HistoryView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             HistoryView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> HistoryView:
        """
         Return a view of HistoryView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             HistoryView: The layered view
        """

    def has_layer(self, name: str):
        """
         Check if HistoryView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool
        """

    def layers(self, names: list[str]) -> HistoryView:
        """
         Return a view of HistoryView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             HistoryView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> HistoryView:
        """
         Return a view of HistoryView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             HistoryView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> HistoryView:
        """
         Return a view of HistoryView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             HistoryView: The layered view
        """

    def valid_layers(self, names: list[str]) -> HistoryView:
        """
         Return a view of HistoryView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             HistoryView: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def window(self, start: TimeInput | None, end: TimeInput | None):
        """
         Create a view of the HistoryView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
        r    HistoryView
        """

    def at(self, time: TimeInput):
        """
         Create a view of the HistoryView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             HistoryView
        """

    def latest(self):
        """
         Create a view of the HistoryView including all events at the latest time.

        Returns:
             HistoryView
        """

    def snapshot_at(self, time: TimeInput):
        """
         Create a view of the HistoryView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `EventGraph`s and `at(time)` for `PersitentGraph`s

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             HistoryView
        """

    def snapshot_latest(self):
        """
         Create a view of the HistoryView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `EventGraph`s and `latest()` for `PersitentGraph`s

        Returns:
             HistoryView
        """

    def before(self, end: TimeInput):
        """
         Create a view of the HistoryView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             HistoryView
        """

    def after(self, start: TimeInput):
        """
         Create a view of the HistoryView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             HistoryView
        """

    def shrink_start(self, start: TimeInput):
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             HistoryView
        """

    def shrink_end(self, end: TimeInput):
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             HistoryView
        """

    def shrink_window(self, start: TimeInput, end: TimeInput):
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        """

    def sorted(self, reverse: bool = False) -> NodeStateListI64:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateListI64: Sorted node state
        """

    def top_k(self, k: int) -> NodeStateListI64:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateListI64: The k largest values as a node state
        """

    def bottom_k(self, k: int) -> NodeStateListI64:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateListI64: The k smallest values as a node state
        """

    def min_item(self) -> Optional[Tuple[Node, list[int]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, list[int]]]: The Node and minimum value or `None` if empty
        """

    def min(self) -> Optional[list[int]]:
        """
        Return the minimum value

        Returns:
             Optional[list[int]]: The minimum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, list[int]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, list[int]]]: The Node and maximum value or `None` if empty
        """

    def max(self) -> Optional[list[int]]:
        """
        Return the maximum value

        Returns:
             Optional[list[int]]: The maximum value or `None` if empty
        """

    def median(self):
        """
        Return the median value

        Returns:
             Optional[list[int]]
        """

    def median_item(self) -> Optional[Tuple[Node, list[int]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, list[int]]]: The median value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def items(self):
        """
        Returns:
             Iterator[Tuple[Node, list[int]]]: Iterator over items
        """

    def values(self):
        """
        Returns:
             Iterator[list[int]]: Iterator over values
        """

    def sorted_by_id(self) -> NodeStateListI64:
        """
        Sort results by node id

        Returns:
             NodeStateListI64: The sorted node state
        """

    def compute(self):
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateListI64
        """

    def collect(self):
        """
        Compute all values and return the result as a list

        Returns
             list[list[int]]: all values as a list
        """

    @property
    def end_date_time(self):
        """
         Gets the latest datetime that this HistoryView is valid

        Returns:
             Optional[Datetime]: The latest datetime that this HistoryView is valid or None if the HistoryView is valid for all times.
        """

    @property
    def start_date_time(self):
        """
         Gets the earliest datetime that this HistoryView is valid

        Returns:
             Optional[Datetime]: The earliest datetime that this HistoryView is valid or None if the HistoryView is valid for all times.
        """

    @property
    def end(self):
        """
         Gets the latest time that this HistoryView is valid.

        Returns:
           Optional[int]: The latest time that this HistoryView is valid or None if the HistoryView is valid for all times.
        """

    @property
    def start(self):
        """
         Gets the start time for rolling and expanding windows for this HistoryView

        Returns:
            Optional[int]: The earliest time that this HistoryView is valid or None if the HistoryView is valid for all times.
        """

    @property
    def window_size(self):
        """
         Get the window size (difference between start and end) for this HistoryView

        Returns:
            Optional[int]
        """

class NodeStateListI64(object):
    def __repr__(self):
        """Return repr(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __le__(self, value):
        """Return self<=value."""

    def __eq__(self, value):
        """Return self==value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __getitem__(self, key):
        """Return self[key]."""

    def sorted(self, reverse: bool = False) -> NodeStateListI64:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateListI64: Sorted node state
        """

    def top_k(self, k: int) -> NodeStateListI64:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateListI64: The k largest values as a node state
        """

    def bottom_k(self, k: int) -> NodeStateListI64:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateListI64: The k smallest values as a node state
        """

    def min_item(self) -> Optional[Tuple[Node, list[int]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, list[int]]]: The Node and minimum value or `None` if empty
        """

    def min(self) -> Optional[list[int]]:
        """
        Return the minimum value

        Returns:
             Optional[list[int]]: The minimum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, list[int]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, list[int]]]: The Node and maximum value or `None` if empty
        """

    def max(self) -> Optional[list[int]]:
        """
        Return the maximum value

        Returns:
             Optional[list[int]]: The maximum value or `None` if empty
        """

    def median(self):
        """
        Return the median value

        Returns:
             Optional[list[int]]
        """

    def median_item(self) -> Optional[Tuple[Node, list[int]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, list[int]]]: The median value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def items(self):
        """
        Returns:
             Iterator[Tuple[Node, list[int]]]: Iterator over items
        """

    def values(self):
        """
        Returns:
             Iterator[list[int]]: Iterator over values
        """

    def sorted_by_id(self) -> NodeStateListI64:
        """
        Sort results by node id

        Returns:
             NodeStateListI64: The sorted node state
        """

class HistoryDateTimeView(object):
    """A lazy view over node values"""

    def __repr__(self):
        """Return repr(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __le__(self, value):
        """Return self<=value."""

    def __eq__(self, value):
        """Return self==value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __getitem__(self, key):
        """Return self[key]."""

    def default_layer(self) -> HistoryDateTimeView:
        """
         Return a view of HistoryDateTimeView containing only the default edge layer
        Returns:
             HistoryDateTimeView: The layered view
        """

    def layer(self, name: str) -> HistoryDateTimeView:
        """
         Return a view of HistoryDateTimeView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             HistoryDateTimeView: The layered view
        """

    def exclude_layer(self, name: str) -> HistoryDateTimeView:
        """
         Return a view of HistoryDateTimeView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             HistoryDateTimeView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> HistoryDateTimeView:
        """
         Return a view of HistoryDateTimeView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             HistoryDateTimeView: The layered view
        """

    def has_layer(self, name: str):
        """
         Check if HistoryDateTimeView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool
        """

    def layers(self, names: list[str]) -> HistoryDateTimeView:
        """
         Return a view of HistoryDateTimeView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             HistoryDateTimeView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> HistoryDateTimeView:
        """
         Return a view of HistoryDateTimeView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             HistoryDateTimeView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> HistoryDateTimeView:
        """
         Return a view of HistoryDateTimeView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             HistoryDateTimeView: The layered view
        """

    def valid_layers(self, names: list[str]) -> HistoryDateTimeView:
        """
         Return a view of HistoryDateTimeView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             HistoryDateTimeView: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def window(self, start: TimeInput | None, end: TimeInput | None):
        """
         Create a view of the HistoryDateTimeView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
        r    HistoryDateTimeView
        """

    def at(self, time: TimeInput):
        """
         Create a view of the HistoryDateTimeView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             HistoryDateTimeView
        """

    def latest(self):
        """
         Create a view of the HistoryDateTimeView including all events at the latest time.

        Returns:
             HistoryDateTimeView
        """

    def snapshot_at(self, time: TimeInput):
        """
         Create a view of the HistoryDateTimeView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `EventGraph`s and `at(time)` for `PersitentGraph`s

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             HistoryDateTimeView
        """

    def snapshot_latest(self):
        """
         Create a view of the HistoryDateTimeView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `EventGraph`s and `latest()` for `PersitentGraph`s

        Returns:
             HistoryDateTimeView
        """

    def before(self, end: TimeInput):
        """
         Create a view of the HistoryDateTimeView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             HistoryDateTimeView
        """

    def after(self, start: TimeInput):
        """
         Create a view of the HistoryDateTimeView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             HistoryDateTimeView
        """

    def shrink_start(self, start: TimeInput):
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             HistoryDateTimeView
        """

    def shrink_end(self, end: TimeInput):
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             HistoryDateTimeView
        """

    def shrink_window(self, start: TimeInput, end: TimeInput):
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionListDateTime:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionListDateTime: Sorted node state
        """

    def top_k(self, k: int) -> NodeStateOptionListDateTime:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionListDateTime: The k largest values as a node state
        """

    def bottom_k(self, k: int) -> NodeStateOptionListDateTime:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionListDateTime: The k smallest values as a node state
        """

    def min_item(self):
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[list[Datetime]]]]: The Node and minimum value or `None` if empty
        """

    def min(self):
        """
        Return the minimum value

        Returns:
             Optional[Optional[list[Datetime]]]: The minimum value or `None` if empty
        """

    def max_item(self):
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[list[Datetime]]]]: The Node and maximum value or `None` if empty
        """

    def max(self):
        """
        Return the maximum value

        Returns:
             Optional[Optional[list[Datetime]]]: The maximum value or `None` if empty
        """

    def median(self):
        """
        Return the median value

        Returns:
             Optional[Optional[list[Datetime]]]
        """

    def median_item(self):
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[list[Datetime]]]]: The median value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def items(self):
        """
        Returns:
             Iterator[Tuple[Node, Optional[list[Datetime]]]]: Iterator over items
        """

    def values(self):
        """
        Returns:
             Iterator[Optional[list[Datetime]]]: Iterator over values
        """

    def sorted_by_id(self) -> NodeStateOptionListDateTime:
        """
        Sort results by node id

        Returns:
             NodeStateOptionListDateTime: The sorted node state
        """

    def compute(self):
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateOptionListDateTime
        """

    def collect(self):
        """
        Compute all values and return the result as a list

        Returns
             list[Optional[list[Datetime]]]: all values as a list
        """

    @property
    def end(self):
        """
         Gets the latest time that this HistoryDateTimeView is valid.

        Returns:
           Optional[int]: The latest time that this HistoryDateTimeView is valid or None if the HistoryDateTimeView is valid for all times.
        """

    @property
    def start(self):
        """
         Gets the start time for rolling and expanding windows for this HistoryDateTimeView

        Returns:
            Optional[int]: The earliest time that this HistoryDateTimeView is valid or None if the HistoryDateTimeView is valid for all times.
        """

    @property
    def end_date_time(self):
        """
         Gets the latest datetime that this HistoryDateTimeView is valid

        Returns:
             Optional[Datetime]: The latest datetime that this HistoryDateTimeView is valid or None if the HistoryDateTimeView is valid for all times.
        """

    @property
    def start_date_time(self):
        """
         Gets the earliest datetime that this HistoryDateTimeView is valid

        Returns:
             Optional[Datetime]: The earliest datetime that this HistoryDateTimeView is valid or None if the HistoryDateTimeView is valid for all times.
        """

    @property
    def window_size(self):
        """
         Get the window size (difference between start and end) for this HistoryDateTimeView

        Returns:
            Optional[int]
        """

class NodeStateOptionListDateTime(object):
    def __repr__(self):
        """Return repr(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __le__(self, value):
        """Return self<=value."""

    def __eq__(self, value):
        """Return self==value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __getitem__(self, key):
        """Return self[key]."""

    def sorted(self, reverse: bool = False) -> NodeStateOptionListDateTime:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionListDateTime: Sorted node state
        """

    def top_k(self, k: int) -> NodeStateOptionListDateTime:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionListDateTime: The k largest values as a node state
        """

    def bottom_k(self, k: int) -> NodeStateOptionListDateTime:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionListDateTime: The k smallest values as a node state
        """

    def min_item(self):
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[list[Datetime]]]]: The Node and minimum value or `None` if empty
        """

    def min(self):
        """
        Return the minimum value

        Returns:
             Optional[Optional[list[Datetime]]]: The minimum value or `None` if empty
        """

    def max_item(self):
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[list[Datetime]]]]: The Node and maximum value or `None` if empty
        """

    def max(self):
        """
        Return the maximum value

        Returns:
             Optional[Optional[list[Datetime]]]: The maximum value or `None` if empty
        """

    def median(self):
        """
        Return the median value

        Returns:
             Optional[Optional[list[Datetime]]]
        """

    def median_item(self):
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[list[Datetime]]]]: The median value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def items(self):
        """
        Returns:
             Iterator[Tuple[Node, Optional[list[Datetime]]]]: Iterator over items
        """

    def values(self):
        """
        Returns:
             Iterator[Optional[list[Datetime]]]: Iterator over values
        """

    def sorted_by_id(self) -> NodeStateOptionListDateTime:
        """
        Sort results by node id

        Returns:
             NodeStateOptionListDateTime: The sorted node state
        """

class NodeTypeView(object):
    """A lazy view over node values"""

    def __repr__(self):
        """Return repr(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __le__(self, value):
        """Return self<=value."""

    def __eq__(self, value):
        """Return self==value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __getitem__(self, key):
        """Return self[key]."""

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionStr:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionStr: Sorted node state
        """

    def top_k(self, k: int) -> NodeStateOptionStr:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionStr: The k largest values as a node state
        """

    def bottom_k(self, k: int) -> NodeStateOptionStr:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionStr: The k smallest values as a node state
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[str]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[str]]]: The Node and minimum value or `None` if empty
        """

    def min(self) -> Optional[Optional[str]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[str]]: The minimum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[str]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[str]]]: The Node and maximum value or `None` if empty
        """

    def max(self) -> Optional[Optional[str]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[str]]: The maximum value or `None` if empty
        """

    def median(self):
        """
        Return the median value

        Returns:
             Optional[Optional[str]]
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[str]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[str]]]: The median value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def items(self):
        """
        Returns:
             Iterator[Tuple[Node, Optional[str]]]: Iterator over items
        """

    def values(self):
        """
        Returns:
             Iterator[Optional[str]]: Iterator over values
        """

    def sorted_by_id(self) -> NodeStateOptionStr:
        """
        Sort results by node id

        Returns:
             NodeStateOptionStr: The sorted node state
        """

    def compute(self):
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateOptionStr
        """

    def collect(self):
        """
        Compute all values and return the result as a list

        Returns
             list[Optional[str]]: all values as a list
        """

class NodeStateOptionStr(object):
    def __repr__(self):
        """Return repr(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __le__(self, value):
        """Return self<=value."""

    def __eq__(self, value):
        """Return self==value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __getitem__(self, key):
        """Return self[key]."""

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionStr:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionStr: Sorted node state
        """

    def top_k(self, k: int) -> NodeStateOptionStr:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionStr: The k largest values as a node state
        """

    def bottom_k(self, k: int) -> NodeStateOptionStr:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionStr: The k smallest values as a node state
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[str]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[str]]]: The Node and minimum value or `None` if empty
        """

    def min(self) -> Optional[Optional[str]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[str]]: The minimum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[str]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[str]]]: The Node and maximum value or `None` if empty
        """

    def max(self) -> Optional[Optional[str]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[str]]: The maximum value or `None` if empty
        """

    def median(self):
        """
        Return the median value

        Returns:
             Optional[Optional[str]]
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[str]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[str]]]: The median value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def items(self):
        """
        Returns:
             Iterator[Tuple[Node, Optional[str]]]: Iterator over items
        """

    def values(self):
        """
        Returns:
             Iterator[Optional[str]]: Iterator over values
        """

    def sorted_by_id(self) -> NodeStateOptionStr:
        """
        Sort results by node id

        Returns:
             NodeStateOptionStr: The sorted node state
        """

class NodeStateListDateTime(object):
    def __repr__(self):
        """Return repr(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __le__(self, value):
        """Return self<=value."""

    def __eq__(self, value):
        """Return self==value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def __getitem__(self, key):
        """Return self[key]."""

    def sorted(self, reverse: bool = False) -> NodeStateListDateTime:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateListDateTime: Sorted node state
        """

    def top_k(self, k: int) -> NodeStateListDateTime:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateListDateTime: The k largest values as a node state
        """

    def bottom_k(self, k: int) -> NodeStateListDateTime:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateListDateTime: The k smallest values as a node state
        """

    def min_item(self):
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, list[Datetime]]]: The Node and minimum value or `None` if empty
        """

    def min(self):
        """
        Return the minimum value

        Returns:
             Optional[list[Datetime]]: The minimum value or `None` if empty
        """

    def max_item(self):
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, list[Datetime]]]: The Node and maximum value or `None` if empty
        """

    def max(self):
        """
        Return the maximum value

        Returns:
             Optional[list[Datetime]]: The maximum value or `None` if empty
        """

    def median(self):
        """
        Return the median value

        Returns:
             Optional[list[Datetime]]
        """

    def median_item(self):
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, list[Datetime]]]: The median value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def items(self):
        """
        Returns:
             Iterator[Tuple[Node, list[Datetime]]]: Iterator over items
        """

    def values(self):
        """
        Returns:
             Iterator[list[Datetime]]: Iterator over values
        """

    def sorted_by_id(self) -> NodeStateListDateTime:
        """
        Sort results by node id

        Returns:
             NodeStateListDateTime: The sorted node state
        """
