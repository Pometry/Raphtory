from __future__ import annotations

###############################################################################
#                                                                             #
#                      AUTOGENERATED TYPE STUB FILE                           #
#                                                                             #
#    This file was automatically generated. Do not modify it directly.        #
#    Any changes made here may be lost when the file is regenerated.          #
#                                                                             #
###############################################################################

from typing import *
from raphtory import *
import raphtory.filter as filter
from raphtory.algorithms import *
from raphtory.vectors import *
from raphtory.graphql import *
from raphtory.typing import *
import numpy as np
from numpy.typing import NDArray
from datetime import datetime
from pandas import DataFrame
from os import PathLike
import networkx as nx  # type: ignore
import pyvis  # type: ignore
from raphtory.iterables import *

__all__ = ['NodeGroups', 'DegreeView', 'NodeStateUsize', 'NodeStateOptionUsize', 'NodeStateU64', 'NodeStateOptionI64', 'NodeStateOptionEventTime', 'NodeStateOptionDateTime', 'IdView', 'NodeStateGID', 'EarliestTimeView', 'EarliestTimestampView', 'EarliestEventIdView', 'EarliestDateTimeView', 'LatestTimeView', 'LatestTimestampView', 'LatestEventIdView', 'LatestDateTimeView', 'NameView', 'NodeStateString', 'HistoryView', 'HistoryTimestampView', 'HistoryDateTimeView', 'HistoryEventIdView', 'IntervalsView', 'IntervalsFloatView', 'IntervalsIntegerView', 'EdgeHistoryCountView', 'UsizeIterable', 'NodeTypeView', 'NodeStateOptionStr', 'NodeStateListDateTime', 'NodeStateWeightedSP', 'NodeStateF64', 'NodeStateOptionF64', 'NodeStateNodes', 'NodeStateReachability', 'NodeStateListF64', 'NodeStateMotifs', 'NodeStateHits', 'NodeStateHistory', 'NodeStateHistoryTimestamp', 'NodeStateHistoryDateTime', 'NodeStateHistoryEventId', 'NodeStateIntervals', 'NodeStateSEIR', 'NodeLayout', 'NodeStateF64String']
class NodeGroups(object): 

    def __bool__(self):
        """True if self else False"""

    def __getitem__(self, key):
        """Return self[key]."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def group(self, index: int) -> Tuple[Any, Nodes]:
        """
        Get group nodes and value

        Arguments:
            index (int): the group index

        Returns:
            Tuple[Any, Nodes]: Nodes and corresponding value
        """

    def group_subgraph(self, index: int) -> Tuple[Any, GraphView]:
        """
        Get group as subgraph

        Arguments:
            index (int): the group index

        Returns:
            Tuple[Any, GraphView]: The group as a subgraph and corresponding value
        """

    def iter_subgraphs(self) -> Iterator[Tuple[Any, GraphView]]:
        """
        Iterate over group subgraphs

        Returns:
            Iterator[Tuple[Any, GraphView]]: Iterator over subgraphs with corresponding value
        """

class DegreeView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> DegreeView:
        """
         Create a view of the DegreeView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             DegreeView:
        """

    def at(self, time: TimeInput) -> DegreeView:
        """
         Create a view of the DegreeView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             DegreeView:
        """

    def before(self, end: TimeInput) -> DegreeView:
        """
         Create a view of the DegreeView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             DegreeView:
        """

    def bottom_k(self, k: int) -> NodeStateUsize:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateUsize: The k smallest values as a node state
        """

    def collect(self) -> list[int]:
        """
        Compute all values and return the result as a list

        Returns:
             list[int]: all values as a list
        """

    def compute(self) -> NodeStateUsize:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateUsize: the computed `NodeState`
        """

    def default_layer(self) -> DegreeView:
        """
         Return a view of DegreeView containing only the default edge layer
        Returns:
             DegreeView: The layered view
        """

    @property
    def end(self) -> Optional[EventTime]:
        """
         Gets the latest time that this DegreeView is valid.

        Returns:
           Optional[EventTime]: The latest time that this DegreeView is valid or None if the DegreeView is valid for all times.
        """

    def exclude_layer(self, name: str) -> DegreeView:
        """
         Return a view of DegreeView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             DegreeView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> DegreeView:
        """
         Return a view of DegreeView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             DegreeView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> DegreeView:
        """
         Return a view of DegreeView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             DegreeView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> DegreeView:
        """
         Return a view of DegreeView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             DegreeView: The layered view
        """

    def expanding(self, step: int | str, alignment_unit: str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step. For example, if the step is "1 month and 1 day",
                the windows will be aligned on days (00:00:00 to 23:59:59).
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def get(self, node: NodeInput, default: Optional[int] = None) -> Optional[int]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[int]): the default value. Defaults to None.

        Returns:
            Optional[int]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if DegreeView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def items(self) -> Iterator[Tuple[Node, int]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, int]]: Iterator over items
        """

    def latest(self) -> DegreeView:
        """
         Create a view of the DegreeView including all events at the latest time.

        Returns:
             DegreeView:
        """

    def layer(self, name: str) -> DegreeView:
        """
         Return a view of DegreeView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             DegreeView: The layered view
        """

    def layers(self, names: list[str]) -> DegreeView:
        """
         Return a view of DegreeView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             DegreeView: The layered view
        """

    def max(self) -> Optional[int]:
        """
        Return the maximum value

        Returns:
             Optional[int]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The Node and maximum value or `None` if empty
        """

    def mean(self) -> float:
        """
        mean of values over all nodes

        Returns:
            float: mean value
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[int]:
        """

    def median_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The median value or `None` if empty
        """

    def min(self) -> Optional[int]:
        """
        Return the minimum value

        Returns:
             Optional[int]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def rolling(self, window: int | str, step: int | str | None = None, alignment_unit: str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.
        If `alignment_unit` is not "unaligned" and a `step` larger than `window` is provided, some time entries
        may appear before the start of the first window and/or after the end of the last window (i.e. not included in any window).

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step (or window if no step is passed).
                For example, if the step is "1 month and 1 day",
                the first window will begin at the start of the day of the first time event.
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> DegreeView:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             DegreeView:
        """

    def shrink_start(self, start: TimeInput) -> DegreeView:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             DegreeView:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> DegreeView:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             DegreeView:
        """

    def snapshot_at(self, time: TimeInput) -> DegreeView:
        """
         Create a view of the DegreeView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             DegreeView:
        """

    def snapshot_latest(self) -> DegreeView:
        """
         Create a view of the DegreeView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             DegreeView:
        """

    def sorted(self, reverse: bool = False) -> NodeStateUsize:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateUsize: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateUsize:
        """
        Sort results by node id

        Returns:
             NodeStateUsize: The sorted node state
        """

    @property
    def start(self) -> Optional[EventTime]:
        """
         Gets the start time for rolling and expanding windows for this DegreeView

        Returns:
            Optional[EventTime]: The earliest time that this DegreeView is valid or None if the DegreeView is valid for all times.
        """

    def sum(self) -> PropValue:
        """
        sum of values over all nodes

        Returns:
            PropValue:
                int: the sum
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateUsize:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateUsize: The k largest values as a node state
        """

    def valid_layers(self, names: list[str]) -> DegreeView:
        """
         Return a view of DegreeView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             DegreeView: The layered view
        """

    def values(self) -> Iterator[int]:
        """
        Iterate over values

        Returns:
             Iterator[int]: Iterator over values
        """

    def window(self, start: TimeInput, end: TimeInput) -> DegreeView:
        """
         Create a view of the DegreeView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput): The start time of the window.
            end (TimeInput): The end time of the window.

        Returns:
            DegreeView:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this DegreeView.

        Returns:
            Optional[int]:
        """

class NodeStateUsize(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateUsize:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateUsize: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[int] = None) -> Optional[int]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[int]): the default value. Defaults to None.

        Returns:
            Optional[int]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def items(self) -> Iterator[Tuple[Node, int]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, int]]: Iterator over items
        """

    def max(self) -> Optional[int]:
        """
        Return the maximum value

        Returns:
             Optional[int]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The Node and maximum value or `None` if empty
        """

    def mean(self) -> float:
        """
        mean of values over all nodes

        Returns:
            float: mean value
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[int]:
        """

    def median_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The median value or `None` if empty
        """

    def min(self) -> Optional[int]:
        """
        Return the minimum value

        Returns:
             Optional[int]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateUsize:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateUsize: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateUsize:
        """
        Sort results by node id

        Returns:
             NodeStateUsize: The sorted node state
        """

    def sum(self) -> PropValue:
        """
        sum of values over all nodes

        Returns:
            PropValue:
                int: the sum
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateUsize:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateUsize: The k largest values as a node state
        """

    def values(self) -> Iterator[int]:
        """
        Iterate over values

        Returns:
             Iterator[int]: Iterator over values
        """

class NodeStateOptionUsize(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateOptionUsize:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionUsize: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[Optional[int]] = None) -> Optional[Optional[int]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[int]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[int]]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def items(self) -> Iterator[Tuple[Node, Optional[int]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[int]]]: Iterator over items
        """

    def max(self) -> Optional[Optional[int]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[int]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[Optional[int]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[int]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[int]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionUsize:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionUsize: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionUsize:
        """
        Sort results by node id

        Returns:
             NodeStateOptionUsize: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionUsize:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionUsize: The k largest values as a node state
        """

    def values(self) -> Iterator[Optional[int]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[int]]: Iterator over values
        """

class NodeStateU64(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateU64:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateU64: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[int] = None) -> Optional[int]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[int]): the default value. Defaults to None.

        Returns:
            Optional[int]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, int]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, int]]: Iterator over items
        """

    def max(self) -> Optional[int]:
        """
        Return the maximum value

        Returns:
             Optional[int]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The Node and maximum value or `None` if empty
        """

    def mean(self) -> float:
        """
        mean of values over all nodes

        Returns:
            float: mean value
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[int]:
        """

    def median_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The median value or `None` if empty
        """

    def min(self) -> Optional[int]:
        """
        Return the minimum value

        Returns:
             Optional[int]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateU64:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateU64: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateU64:
        """
        Sort results by node id

        Returns:
             NodeStateU64: The sorted node state
        """

    def sum(self) -> PropValue:
        """
        sum of values over all nodes

        Returns:
            PropValue:
                int: the sum
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateU64:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateU64: The k largest values as a node state
        """

    def values(self) -> Iterator[int]:
        """
        Iterate over values

        Returns:
             Iterator[int]: Iterator over values
        """

class NodeStateOptionI64(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateOptionI64:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionI64: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[Optional[int]] = None) -> Optional[Optional[int]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[int]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[int]]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def items(self) -> Iterator[Tuple[Node, Optional[int]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[int]]]: Iterator over items
        """

    def max(self) -> Optional[Optional[int]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[int]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[Optional[int]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[int]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[int]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionI64:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionI64: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionI64:
        """
        Sort results by node id

        Returns:
             NodeStateOptionI64: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionI64:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionI64: The k largest values as a node state
        """

    def values(self) -> Iterator[Optional[int]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[int]]: Iterator over values
        """

class NodeStateOptionEventTime(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateOptionEventTime:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionEventTime: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[Optional[EventTime]] = None) -> Optional[Optional[EventTime]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[EventTime]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[EventTime]]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def items(self) -> Iterator[Tuple[Node, Optional[EventTime]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[EventTime]]]: Iterator over items
        """

    def max(self) -> Optional[Optional[EventTime]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[EventTime]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[EventTime]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[EventTime]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[Optional[EventTime]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[EventTime]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[EventTime]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[EventTime]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[EventTime]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[EventTime]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[EventTime]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionEventTime:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionEventTime: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionEventTime:
        """
        Sort results by node id

        Returns:
             NodeStateOptionEventTime: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionEventTime:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionEventTime: The k largest values as a node state
        """

    def values(self) -> Iterator[Optional[EventTime]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[EventTime]]: Iterator over values
        """

class NodeStateOptionDateTime(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateOptionDateTime:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionDateTime: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[Optional[datetime]] = None) -> Optional[Optional[datetime]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[datetime]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[datetime]]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def items(self) -> Iterator[Tuple[Node, Optional[datetime]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[datetime]]]: Iterator over items
        """

    def max(self) -> Optional[Optional[datetime]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[datetime]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[datetime]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[datetime]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[Optional[datetime]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[datetime]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[datetime]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[datetime]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[datetime]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[datetime]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[datetime]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionDateTime:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionDateTime: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionDateTime:
        """
        Sort results by node id

        Returns:
             NodeStateOptionDateTime: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionDateTime:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionDateTime: The k largest values as a node state
        """

    def values(self) -> Iterator[Optional[datetime]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[datetime]]: Iterator over values
        """

class IdView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateGID:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateGID: The k smallest values as a node state
        """

    def collect(self) -> list[GID]:
        """
        Compute all values and return the result as a list

        Returns:
             list[GID]: all values as a list
        """

    def compute(self) -> NodeStateGID:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateGID: the computed `NodeState`
        """

    def get(self, node: NodeInput, default: Optional[GID] = None) -> Optional[GID]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[GID]): the default value. Defaults to None.

        Returns:
            Optional[GID]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, GID]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, GID]]: Iterator over items
        """

    def max(self) -> Optional[GID]:
        """
        Return the maximum value

        Returns:
             Optional[GID]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, GID]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, GID]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[GID]:
        """

    def median_item(self) -> Optional[Tuple[Node, GID]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, GID]]: The median value or `None` if empty
        """

    def min(self) -> Optional[GID]:
        """
        Return the minimum value

        Returns:
             Optional[GID]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, GID]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, GID]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateGID:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateGID: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateGID:
        """
        Sort results by node id

        Returns:
             NodeStateGID: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateGID:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateGID: The k largest values as a node state
        """

    def values(self) -> Iterator[GID]:
        """
        Iterate over values

        Returns:
             Iterator[GID]: Iterator over values
        """

class NodeStateGID(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateGID:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateGID: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[GID] = None) -> Optional[GID]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[GID]): the default value. Defaults to None.

        Returns:
            Optional[GID]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, GID]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, GID]]: Iterator over items
        """

    def max(self) -> Optional[GID]:
        """
        Return the maximum value

        Returns:
             Optional[GID]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, GID]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, GID]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[GID]:
        """

    def median_item(self) -> Optional[Tuple[Node, GID]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, GID]]: The median value or `None` if empty
        """

    def min(self) -> Optional[GID]:
        """
        Return the minimum value

        Returns:
             Optional[GID]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, GID]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, GID]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateGID:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateGID: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateGID:
        """
        Sort results by node id

        Returns:
             NodeStateGID: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateGID:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateGID: The k largest values as a node state
        """

    def values(self) -> Iterator[GID]:
        """
        Iterate over values

        Returns:
             Iterator[GID]: Iterator over values
        """

class EarliestTimeView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> EarliestTimeView:
        """
         Create a view of the EarliestTimeView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             EarliestTimeView:
        """

    def at(self, time: TimeInput) -> EarliestTimeView:
        """
         Create a view of the EarliestTimeView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             EarliestTimeView:
        """

    def before(self, end: TimeInput) -> EarliestTimeView:
        """
         Create a view of the EarliestTimeView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             EarliestTimeView:
        """

    def bottom_k(self, k: int) -> NodeStateOptionEventTime:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionEventTime: The k smallest values as a node state
        """

    def collect(self) -> list[Optional[EventTime]]:
        """
        Compute all values and return the result as a list

        Returns:
             list[Optional[EventTime]]: all values as a list
        """

    def compute(self) -> NodeStateOptionEventTime:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateOptionEventTime: the computed `NodeState`
        """

    def default_layer(self) -> EarliestTimeView:
        """
         Return a view of EarliestTimeView containing only the default edge layer
        Returns:
             EarliestTimeView: The layered view
        """

    @property
    def dt(self) -> EarliestDateTimeView:
        """
        Access earliest times as UTC DateTimes.

        Returns:
            EarliestDateTimeView: A lazy view over the earliest times for each node as datetimes.
        """

    @property
    def end(self) -> Optional[EventTime]:
        """
         Gets the latest time that this EarliestTimeView is valid.

        Returns:
           Optional[EventTime]: The latest time that this EarliestTimeView is valid or None if the EarliestTimeView is valid for all times.
        """

    @property
    def event_id(self) -> EarliestEventIdView:
        """
        Access the event ids of the earliest times.

        Returns:
            EarliestEventIdView: A lazy view over the event ids of the earliest times for each node.
        """

    def exclude_layer(self, name: str) -> EarliestTimeView:
        """
         Return a view of EarliestTimeView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             EarliestTimeView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> EarliestTimeView:
        """
         Return a view of EarliestTimeView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             EarliestTimeView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> EarliestTimeView:
        """
         Return a view of EarliestTimeView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             EarliestTimeView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> EarliestTimeView:
        """
         Return a view of EarliestTimeView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             EarliestTimeView: The layered view
        """

    def expanding(self, step: int | str, alignment_unit: str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step. For example, if the step is "1 month and 1 day",
                the windows will be aligned on days (00:00:00 to 23:59:59).
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def get(self, node: NodeInput, default: Optional[Optional[EventTime]] = None) -> Optional[Optional[EventTime]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[EventTime]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[EventTime]]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if EarliestTimeView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def items(self) -> Iterator[Tuple[Node, Optional[EventTime]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[EventTime]]]: Iterator over items
        """

    def latest(self) -> EarliestTimeView:
        """
         Create a view of the EarliestTimeView including all events at the latest time.

        Returns:
             EarliestTimeView:
        """

    def layer(self, name: str) -> EarliestTimeView:
        """
         Return a view of EarliestTimeView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             EarliestTimeView: The layered view
        """

    def layers(self, names: list[str]) -> EarliestTimeView:
        """
         Return a view of EarliestTimeView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             EarliestTimeView: The layered view
        """

    def max(self) -> Optional[Optional[EventTime]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[EventTime]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[EventTime]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[EventTime]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[Optional[EventTime]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[EventTime]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[EventTime]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[EventTime]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[EventTime]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[EventTime]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[EventTime]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def rolling(self, window: int | str, step: int | str | None = None, alignment_unit: str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.
        If `alignment_unit` is not "unaligned" and a `step` larger than `window` is provided, some time entries
        may appear before the start of the first window and/or after the end of the last window (i.e. not included in any window).

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step (or window if no step is passed).
                For example, if the step is "1 month and 1 day",
                the first window will begin at the start of the day of the first time event.
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> EarliestTimeView:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             EarliestTimeView:
        """

    def shrink_start(self, start: TimeInput) -> EarliestTimeView:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             EarliestTimeView:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> EarliestTimeView:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             EarliestTimeView:
        """

    def snapshot_at(self, time: TimeInput) -> EarliestTimeView:
        """
         Create a view of the EarliestTimeView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             EarliestTimeView:
        """

    def snapshot_latest(self) -> EarliestTimeView:
        """
         Create a view of the EarliestTimeView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             EarliestTimeView:
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionEventTime:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionEventTime: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionEventTime:
        """
        Sort results by node id

        Returns:
             NodeStateOptionEventTime: The sorted node state
        """

    @property
    def start(self) -> Optional[EventTime]:
        """
         Gets the start time for rolling and expanding windows for this EarliestTimeView

        Returns:
            Optional[EventTime]: The earliest time that this EarliestTimeView is valid or None if the EarliestTimeView is valid for all times.
        """

    @property
    def t(self) -> EarliestTimestampView:
        """
        Access earliest times as timestamps (milliseconds since the Unix epoch).

        Returns:
            EarliestTimestampView: A lazy view over the earliest times for each node as timestamps.
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionEventTime:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionEventTime: The k largest values as a node state
        """

    def valid_layers(self, names: list[str]) -> EarliestTimeView:
        """
         Return a view of EarliestTimeView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             EarliestTimeView: The layered view
        """

    def values(self) -> Iterator[Optional[EventTime]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[EventTime]]: Iterator over values
        """

    def window(self, start: TimeInput, end: TimeInput) -> EarliestTimeView:
        """
         Create a view of the EarliestTimeView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput): The start time of the window.
            end (TimeInput): The end time of the window.

        Returns:
            EarliestTimeView:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this EarliestTimeView.

        Returns:
            Optional[int]:
        """

class EarliestTimestampView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> EarliestTimestampView:
        """
         Create a view of the EarliestTimestampView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             EarliestTimestampView:
        """

    def at(self, time: TimeInput) -> EarliestTimestampView:
        """
         Create a view of the EarliestTimestampView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             EarliestTimestampView:
        """

    def before(self, end: TimeInput) -> EarliestTimestampView:
        """
         Create a view of the EarliestTimestampView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             EarliestTimestampView:
        """

    def bottom_k(self, k: int) -> NodeStateOptionI64:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionI64: The k smallest values as a node state
        """

    def collect(self) -> list[Optional[int]]:
        """
        Compute all values and return the result as a list

        Returns:
             list[Optional[int]]: all values as a list
        """

    def compute(self) -> NodeStateOptionI64:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateOptionI64: the computed `NodeState`
        """

    def default_layer(self) -> EarliestTimestampView:
        """
         Return a view of EarliestTimestampView containing only the default edge layer
        Returns:
             EarliestTimestampView: The layered view
        """

    @property
    def end(self) -> Optional[EventTime]:
        """
         Gets the latest time that this EarliestTimestampView is valid.

        Returns:
           Optional[EventTime]: The latest time that this EarliestTimestampView is valid or None if the EarliestTimestampView is valid for all times.
        """

    def exclude_layer(self, name: str) -> EarliestTimestampView:
        """
         Return a view of EarliestTimestampView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             EarliestTimestampView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> EarliestTimestampView:
        """
         Return a view of EarliestTimestampView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             EarliestTimestampView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> EarliestTimestampView:
        """
         Return a view of EarliestTimestampView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             EarliestTimestampView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> EarliestTimestampView:
        """
         Return a view of EarliestTimestampView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             EarliestTimestampView: The layered view
        """

    def expanding(self, step: int | str, alignment_unit: str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step. For example, if the step is "1 month and 1 day",
                the windows will be aligned on days (00:00:00 to 23:59:59).
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def get(self, node: NodeInput, default: Optional[Optional[int]] = None) -> Optional[Optional[int]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[int]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[int]]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if EarliestTimestampView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def items(self) -> Iterator[Tuple[Node, Optional[int]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[int]]]: Iterator over items
        """

    def latest(self) -> EarliestTimestampView:
        """
         Create a view of the EarliestTimestampView including all events at the latest time.

        Returns:
             EarliestTimestampView:
        """

    def layer(self, name: str) -> EarliestTimestampView:
        """
         Return a view of EarliestTimestampView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             EarliestTimestampView: The layered view
        """

    def layers(self, names: list[str]) -> EarliestTimestampView:
        """
         Return a view of EarliestTimestampView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             EarliestTimestampView: The layered view
        """

    def max(self) -> Optional[Optional[int]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[int]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[Optional[int]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[int]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[int]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def rolling(self, window: int | str, step: int | str | None = None, alignment_unit: str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.
        If `alignment_unit` is not "unaligned" and a `step` larger than `window` is provided, some time entries
        may appear before the start of the first window and/or after the end of the last window (i.e. not included in any window).

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step (or window if no step is passed).
                For example, if the step is "1 month and 1 day",
                the first window will begin at the start of the day of the first time event.
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> EarliestTimestampView:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             EarliestTimestampView:
        """

    def shrink_start(self, start: TimeInput) -> EarliestTimestampView:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             EarliestTimestampView:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> EarliestTimestampView:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             EarliestTimestampView:
        """

    def snapshot_at(self, time: TimeInput) -> EarliestTimestampView:
        """
         Create a view of the EarliestTimestampView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             EarliestTimestampView:
        """

    def snapshot_latest(self) -> EarliestTimestampView:
        """
         Create a view of the EarliestTimestampView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             EarliestTimestampView:
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionI64:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionI64: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionI64:
        """
        Sort results by node id

        Returns:
             NodeStateOptionI64: The sorted node state
        """

    @property
    def start(self) -> Optional[EventTime]:
        """
         Gets the start time for rolling and expanding windows for this EarliestTimestampView

        Returns:
            Optional[EventTime]: The earliest time that this EarliestTimestampView is valid or None if the EarliestTimestampView is valid for all times.
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionI64:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionI64: The k largest values as a node state
        """

    def valid_layers(self, names: list[str]) -> EarliestTimestampView:
        """
         Return a view of EarliestTimestampView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             EarliestTimestampView: The layered view
        """

    def values(self) -> Iterator[Optional[int]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[int]]: Iterator over values
        """

    def window(self, start: TimeInput, end: TimeInput) -> EarliestTimestampView:
        """
         Create a view of the EarliestTimestampView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput): The start time of the window.
            end (TimeInput): The end time of the window.

        Returns:
            EarliestTimestampView:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this EarliestTimestampView.

        Returns:
            Optional[int]:
        """

class EarliestEventIdView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> EarliestEventIdView:
        """
         Create a view of the EarliestEventIdView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             EarliestEventIdView:
        """

    def at(self, time: TimeInput) -> EarliestEventIdView:
        """
         Create a view of the EarliestEventIdView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             EarliestEventIdView:
        """

    def before(self, end: TimeInput) -> EarliestEventIdView:
        """
         Create a view of the EarliestEventIdView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             EarliestEventIdView:
        """

    def bottom_k(self, k: int) -> NodeStateOptionUsize:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionUsize: The k smallest values as a node state
        """

    def collect(self) -> list[Optional[int]]:
        """
        Compute all values and return the result as a list

        Returns:
             list[Optional[int]]: all values as a list
        """

    def compute(self) -> NodeStateOptionUsize:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateOptionUsize: the computed `NodeState`
        """

    def default_layer(self) -> EarliestEventIdView:
        """
         Return a view of EarliestEventIdView containing only the default edge layer
        Returns:
             EarliestEventIdView: The layered view
        """

    @property
    def end(self) -> Optional[EventTime]:
        """
         Gets the latest time that this EarliestEventIdView is valid.

        Returns:
           Optional[EventTime]: The latest time that this EarliestEventIdView is valid or None if the EarliestEventIdView is valid for all times.
        """

    def exclude_layer(self, name: str) -> EarliestEventIdView:
        """
         Return a view of EarliestEventIdView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             EarliestEventIdView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> EarliestEventIdView:
        """
         Return a view of EarliestEventIdView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             EarliestEventIdView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> EarliestEventIdView:
        """
         Return a view of EarliestEventIdView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             EarliestEventIdView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> EarliestEventIdView:
        """
         Return a view of EarliestEventIdView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             EarliestEventIdView: The layered view
        """

    def expanding(self, step: int | str, alignment_unit: str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step. For example, if the step is "1 month and 1 day",
                the windows will be aligned on days (00:00:00 to 23:59:59).
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def get(self, node: NodeInput, default: Optional[Optional[int]] = None) -> Optional[Optional[int]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[int]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[int]]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if EarliestEventIdView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def items(self) -> Iterator[Tuple[Node, Optional[int]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[int]]]: Iterator over items
        """

    def latest(self) -> EarliestEventIdView:
        """
         Create a view of the EarliestEventIdView including all events at the latest time.

        Returns:
             EarliestEventIdView:
        """

    def layer(self, name: str) -> EarliestEventIdView:
        """
         Return a view of EarliestEventIdView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             EarliestEventIdView: The layered view
        """

    def layers(self, names: list[str]) -> EarliestEventIdView:
        """
         Return a view of EarliestEventIdView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             EarliestEventIdView: The layered view
        """

    def max(self) -> Optional[Optional[int]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[int]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[Optional[int]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[int]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[int]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def rolling(self, window: int | str, step: int | str | None = None, alignment_unit: str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.
        If `alignment_unit` is not "unaligned" and a `step` larger than `window` is provided, some time entries
        may appear before the start of the first window and/or after the end of the last window (i.e. not included in any window).

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step (or window if no step is passed).
                For example, if the step is "1 month and 1 day",
                the first window will begin at the start of the day of the first time event.
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> EarliestEventIdView:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             EarliestEventIdView:
        """

    def shrink_start(self, start: TimeInput) -> EarliestEventIdView:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             EarliestEventIdView:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> EarliestEventIdView:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             EarliestEventIdView:
        """

    def snapshot_at(self, time: TimeInput) -> EarliestEventIdView:
        """
         Create a view of the EarliestEventIdView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             EarliestEventIdView:
        """

    def snapshot_latest(self) -> EarliestEventIdView:
        """
         Create a view of the EarliestEventIdView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             EarliestEventIdView:
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionUsize:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionUsize: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionUsize:
        """
        Sort results by node id

        Returns:
             NodeStateOptionUsize: The sorted node state
        """

    @property
    def start(self) -> Optional[EventTime]:
        """
         Gets the start time for rolling and expanding windows for this EarliestEventIdView

        Returns:
            Optional[EventTime]: The earliest time that this EarliestEventIdView is valid or None if the EarliestEventIdView is valid for all times.
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionUsize:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionUsize: The k largest values as a node state
        """

    def valid_layers(self, names: list[str]) -> EarliestEventIdView:
        """
         Return a view of EarliestEventIdView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             EarliestEventIdView: The layered view
        """

    def values(self) -> Iterator[Optional[int]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[int]]: Iterator over values
        """

    def window(self, start: TimeInput, end: TimeInput) -> EarliestEventIdView:
        """
         Create a view of the EarliestEventIdView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput): The start time of the window.
            end (TimeInput): The end time of the window.

        Returns:
            EarliestEventIdView:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this EarliestEventIdView.

        Returns:
            Optional[int]:
        """

class EarliestDateTimeView(object): 
    """A lazy view over EarliestDateTime values for each node."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> EarliestDateTimeView:
        """
         Create a view of the EarliestDateTimeView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             EarliestDateTimeView:
        """

    def at(self, time: TimeInput) -> EarliestDateTimeView:
        """
         Create a view of the EarliestDateTimeView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             EarliestDateTimeView:
        """

    def before(self, end: TimeInput) -> EarliestDateTimeView:
        """
         Create a view of the EarliestDateTimeView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             EarliestDateTimeView:
        """

    def bottom_k(self, k: int) -> NodeStateOptionDateTime:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
            NodeStateOptionDateTime: The k smallest values as a node state
        """

    def collect(self) -> list[Optional[datetime]]:
        """
        Compute all DateTime values and return the result as a list

        Returns:
            list[Optional[datetime]]: all values as a list
        """

    def collect_valid(self) -> list[datetime]:
        """
        Compute all DateTime values and return the valid results as a list. Conversion errors and empty values are ignored

        Returns:
            list[datetime]: all values as a list
        """

    def compute(self) -> NodeStateOptionDateTime:
        """
        Compute all DateTime values and return the result as a NodeState. Fails if any DateTime error is encountered.

        Returns:
            NodeStateOptionDateTime: the computed `NodeState`
        """

    def compute_valid(self) -> NodeStateOptionDateTime:
        """
        Compute all values and only return the valid results as a NodeState. DateTime errors are ignored.

        Returns:
            NodeStateOptionDateTime: the computed `NodeState`
        """

    def default_layer(self) -> EarliestDateTimeView:
        """
         Return a view of EarliestDateTimeView containing only the default edge layer
        Returns:
             EarliestDateTimeView: The layered view
        """

    @property
    def end(self) -> Optional[EventTime]:
        """
         Gets the latest time that this EarliestDateTimeView is valid.

        Returns:
           Optional[EventTime]: The latest time that this EarliestDateTimeView is valid or None if the EarliestDateTimeView is valid for all times.
        """

    def exclude_layer(self, name: str) -> EarliestDateTimeView:
        """
         Return a view of EarliestDateTimeView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             EarliestDateTimeView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> EarliestDateTimeView:
        """
         Return a view of EarliestDateTimeView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             EarliestDateTimeView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> EarliestDateTimeView:
        """
         Return a view of EarliestDateTimeView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             EarliestDateTimeView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> EarliestDateTimeView:
        """
         Return a view of EarliestDateTimeView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             EarliestDateTimeView: The layered view
        """

    def expanding(self, step: int | str, alignment_unit: str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step. For example, if the step is "1 month and 1 day",
                the windows will be aligned on days (00:00:00 to 23:59:59).
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def get(self, node: NodeInput, default=...) -> Optional[datetime]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
           default (Optional[datetime]): the default value. Defaults to None.

        Returns:
           Optional[datetime]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if EarliestDateTimeView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def items(self) -> Iterator[Tuple[Node, Optional[datetime]]]:
        """
        Iterate over DateTimes

        Returns:
            Iterator[Tuple[Node, Optional[datetime]]]: Iterator over items
        """

    def items_valid(self) -> Iterator[Tuple[Node, datetime]]:
        """
        Iterate over valid DateTimes only. Ignore error and None values.

        Returns:
            Iterator[Tuple[Node, datetime]]: Iterator over items
        """

    def iter_valid(self) -> Iterator[datetime]:
        """
        Returns an iterator over all valid DateTime values. Conversion errors and empty values are ignored

        Returns:
            Iterator[datetime]: Valid datetime values.
        """

    def latest(self) -> EarliestDateTimeView:
        """
         Create a view of the EarliestDateTimeView including all events at the latest time.

        Returns:
             EarliestDateTimeView:
        """

    def layer(self, name: str) -> EarliestDateTimeView:
        """
         Return a view of EarliestDateTimeView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             EarliestDateTimeView: The layered view
        """

    def layers(self, names: list[str]) -> EarliestDateTimeView:
        """
         Return a view of EarliestDateTimeView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             EarliestDateTimeView: The layered view
        """

    def max(self) -> Optional[datetime]:
        """
        Return the maximum value

        Returns:
            Optional[datetime]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, datetime]]:
        """
        Return largest value and corresponding node

        Returns:
            Optional[Tuple[Node, datetime]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> Optional[datetime]:
        """
        Return the median value

        Returns:
            Optional[datetime]: The median value or `None` if empty
        """

    def median_item(self) -> Optional[Tuple[Node, datetime]]:
        """
        Return median value and corresponding node

        Returns:
            Optional[Tuple[Node, datetime]]: The median value or `None` if empty
        """

    def min(self) -> Optional[datetime]:
        """
        Return the minimum value

        Returns:
            Optional[datetime]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, datetime]]:
        """
        Return smallest value and corresponding node

        Returns:
            Optional[Tuple[Node, datetime]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def rolling(self, window: int | str, step: int | str | None = None, alignment_unit: str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.
        If `alignment_unit` is not "unaligned" and a `step` larger than `window` is provided, some time entries
        may appear before the start of the first window and/or after the end of the last window (i.e. not included in any window).

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step (or window if no step is passed).
                For example, if the step is "1 month and 1 day",
                the first window will begin at the start of the day of the first time event.
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> EarliestDateTimeView:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             EarliestDateTimeView:
        """

    def shrink_start(self, start: TimeInput) -> EarliestDateTimeView:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             EarliestDateTimeView:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> EarliestDateTimeView:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             EarliestDateTimeView:
        """

    def snapshot_at(self, time: TimeInput) -> EarliestDateTimeView:
        """
         Create a view of the EarliestDateTimeView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             EarliestDateTimeView:
        """

    def snapshot_latest(self) -> EarliestDateTimeView:
        """
         Create a view of the EarliestDateTimeView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             EarliestDateTimeView:
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionDateTime:
        """
        Sort by value. Note that 'None' values will always come after valid DateTime values

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
            NodeStateOptionDateTime: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionDateTime:
        """
        Sort results by node id. Fails if any DateTime error is encountered.

        Returns:
            NodeStateOptionDateTime: The sorted node state
        """

    def sorted_by_id_valid(self) -> NodeStateOptionDateTime:
        """
        Sort only non-error DateTimes  by node id. DateTime errors are ignored.

        Returns:
            NodeStateOptionDateTime: The sorted node state
        """

    @property
    def start(self) -> Optional[EventTime]:
        """
         Gets the start time for rolling and expanding windows for this EarliestDateTimeView

        Returns:
            Optional[EventTime]: The earliest time that this EarliestDateTimeView is valid or None if the EarliestDateTimeView is valid for all times.
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: A Pandas DataFrame.
        """

    def top_k(self, k: int) -> NodeStateOptionDateTime:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
            NodeStateOptionDateTime: The k largest values as a node state
        """

    def valid_layers(self, names: list[str]) -> EarliestDateTimeView:
        """
         Return a view of EarliestDateTimeView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             EarliestDateTimeView: The layered view
        """

    def values(self) -> Iterator[Optional[datetime]]:
        """
        Iterate over DateTimes

        Returns:
            Iterator[Optional[datetime]]: Iterator over datetimes
        """

    def values_valid(self) -> Iterator[datetime]:
        """
        Iterate over valid DateTime values only. Ignore error and None values.

        Returns:
            Iterator[datetime]: Iterator over values
        """

    def window(self, start: TimeInput, end: TimeInput) -> EarliestDateTimeView:
        """
         Create a view of the EarliestDateTimeView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput): The start time of the window.
            end (TimeInput): The end time of the window.

        Returns:
            EarliestDateTimeView:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this EarliestDateTimeView.

        Returns:
            Optional[int]:
        """

class LatestTimeView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> LatestTimeView:
        """
         Create a view of the LatestTimeView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             LatestTimeView:
        """

    def at(self, time: TimeInput) -> LatestTimeView:
        """
         Create a view of the LatestTimeView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             LatestTimeView:
        """

    def before(self, end: TimeInput) -> LatestTimeView:
        """
         Create a view of the LatestTimeView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             LatestTimeView:
        """

    def bottom_k(self, k: int) -> NodeStateOptionI64:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionI64: The k smallest values as a node state
        """

    def collect(self) -> list[Optional[int]]:
        """
        Compute all values and return the result as a list

        Returns:
             list[Optional[int]]: all values as a list
        """

    def compute(self) -> NodeStateOptionI64:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateOptionI64: the computed `NodeState`
        """

    def default_layer(self) -> LatestTimeView:
        """
         Return a view of LatestTimeView containing only the default edge layer
        Returns:
             LatestTimeView: The layered view
        """

    @property
    def dt(self) -> LatestDateTimeView:
        """
        Access latest times as UTC DateTimes.

        Returns:
            LatestDateTimeView: A lazy view over the latest times for each node as datetimes.
        """

    @property
    def end(self) -> Optional[EventTime]:
        """
         Gets the latest time that this LatestTimeView is valid.

        Returns:
           Optional[EventTime]: The latest time that this LatestTimeView is valid or None if the LatestTimeView is valid for all times.
        """

    @property
    def event_id(self) -> LatestEventIdView:
        """
        Access the event ids of the latest times.

        Returns:
            LatestEventIdView: A lazy view over the event ids of the latest times for each node.
        """

    def exclude_layer(self, name: str) -> LatestTimeView:
        """
         Return a view of LatestTimeView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             LatestTimeView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> LatestTimeView:
        """
         Return a view of LatestTimeView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             LatestTimeView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> LatestTimeView:
        """
         Return a view of LatestTimeView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             LatestTimeView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> LatestTimeView:
        """
         Return a view of LatestTimeView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             LatestTimeView: The layered view
        """

    def expanding(self, step: int | str, alignment_unit: str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step. For example, if the step is "1 month and 1 day",
                the windows will be aligned on days (00:00:00 to 23:59:59).
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def get(self, node: NodeInput, default: Optional[Optional[int]] = None) -> Optional[Optional[int]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[int]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[int]]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if LatestTimeView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def items(self) -> Iterator[Tuple[Node, Optional[int]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[int]]]: Iterator over items
        """

    def latest(self) -> LatestTimeView:
        """
         Create a view of the LatestTimeView including all events at the latest time.

        Returns:
             LatestTimeView:
        """

    def layer(self, name: str) -> LatestTimeView:
        """
         Return a view of LatestTimeView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             LatestTimeView: The layered view
        """

    def layers(self, names: list[str]) -> LatestTimeView:
        """
         Return a view of LatestTimeView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             LatestTimeView: The layered view
        """

    def max(self) -> Optional[Optional[int]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[int]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[Optional[int]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[int]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[int]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def rolling(self, window: int | str, step: int | str | None = None, alignment_unit: str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.
        If `alignment_unit` is not "unaligned" and a `step` larger than `window` is provided, some time entries
        may appear before the start of the first window and/or after the end of the last window (i.e. not included in any window).

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step (or window if no step is passed).
                For example, if the step is "1 month and 1 day",
                the first window will begin at the start of the day of the first time event.
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> LatestTimeView:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             LatestTimeView:
        """

    def shrink_start(self, start: TimeInput) -> LatestTimeView:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             LatestTimeView:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> LatestTimeView:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             LatestTimeView:
        """

    def snapshot_at(self, time: TimeInput) -> LatestTimeView:
        """
         Create a view of the LatestTimeView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             LatestTimeView:
        """

    def snapshot_latest(self) -> LatestTimeView:
        """
         Create a view of the LatestTimeView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             LatestTimeView:
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionI64:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionI64: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionI64:
        """
        Sort results by node id

        Returns:
             NodeStateOptionI64: The sorted node state
        """

    @property
    def start(self) -> Optional[EventTime]:
        """
         Gets the start time for rolling and expanding windows for this LatestTimeView

        Returns:
            Optional[EventTime]: The earliest time that this LatestTimeView is valid or None if the LatestTimeView is valid for all times.
        """

    @property
    def t(self) -> LatestTimestampView:
        """
        Access latest times as timestamps (milliseconds since the Unix epoch).

        Returns:
            LatestTimestampView: A lazy view over the latest times for each node as timestamps.
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionI64:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionI64: The k largest values as a node state
        """

    def valid_layers(self, names: list[str]) -> LatestTimeView:
        """
         Return a view of LatestTimeView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             LatestTimeView: The layered view
        """

    def values(self) -> Iterator[Optional[int]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[int]]: Iterator over values
        """

    def window(self, start: TimeInput, end: TimeInput) -> LatestTimeView:
        """
         Create a view of the LatestTimeView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput): The start time of the window.
            end (TimeInput): The end time of the window.

        Returns:
            LatestTimeView:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this LatestTimeView.

        Returns:
            Optional[int]:
        """

class LatestTimestampView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> LatestTimestampView:
        """
         Create a view of the LatestTimestampView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             LatestTimestampView:
        """

    def at(self, time: TimeInput) -> LatestTimestampView:
        """
         Create a view of the LatestTimestampView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             LatestTimestampView:
        """

    def before(self, end: TimeInput) -> LatestTimestampView:
        """
         Create a view of the LatestTimestampView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             LatestTimestampView:
        """

    def bottom_k(self, k: int) -> NodeStateOptionI64:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionI64: The k smallest values as a node state
        """

    def collect(self) -> list[Optional[int]]:
        """
        Compute all values and return the result as a list

        Returns:
             list[Optional[int]]: all values as a list
        """

    def compute(self) -> NodeStateOptionI64:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateOptionI64: the computed `NodeState`
        """

    def default_layer(self) -> LatestTimestampView:
        """
         Return a view of LatestTimestampView containing only the default edge layer
        Returns:
             LatestTimestampView: The layered view
        """

    @property
    def end(self) -> Optional[EventTime]:
        """
         Gets the latest time that this LatestTimestampView is valid.

        Returns:
           Optional[EventTime]: The latest time that this LatestTimestampView is valid or None if the LatestTimestampView is valid for all times.
        """

    def exclude_layer(self, name: str) -> LatestTimestampView:
        """
         Return a view of LatestTimestampView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             LatestTimestampView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> LatestTimestampView:
        """
         Return a view of LatestTimestampView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             LatestTimestampView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> LatestTimestampView:
        """
         Return a view of LatestTimestampView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             LatestTimestampView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> LatestTimestampView:
        """
         Return a view of LatestTimestampView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             LatestTimestampView: The layered view
        """

    def expanding(self, step: int | str, alignment_unit: str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step. For example, if the step is "1 month and 1 day",
                the windows will be aligned on days (00:00:00 to 23:59:59).
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def get(self, node: NodeInput, default: Optional[Optional[int]] = None) -> Optional[Optional[int]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[int]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[int]]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if LatestTimestampView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def items(self) -> Iterator[Tuple[Node, Optional[int]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[int]]]: Iterator over items
        """

    def latest(self) -> LatestTimestampView:
        """
         Create a view of the LatestTimestampView including all events at the latest time.

        Returns:
             LatestTimestampView:
        """

    def layer(self, name: str) -> LatestTimestampView:
        """
         Return a view of LatestTimestampView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             LatestTimestampView: The layered view
        """

    def layers(self, names: list[str]) -> LatestTimestampView:
        """
         Return a view of LatestTimestampView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             LatestTimestampView: The layered view
        """

    def max(self) -> Optional[Optional[int]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[int]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[Optional[int]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[int]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[int]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def rolling(self, window: int | str, step: int | str | None = None, alignment_unit: str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.
        If `alignment_unit` is not "unaligned" and a `step` larger than `window` is provided, some time entries
        may appear before the start of the first window and/or after the end of the last window (i.e. not included in any window).

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step (or window if no step is passed).
                For example, if the step is "1 month and 1 day",
                the first window will begin at the start of the day of the first time event.
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> LatestTimestampView:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             LatestTimestampView:
        """

    def shrink_start(self, start: TimeInput) -> LatestTimestampView:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             LatestTimestampView:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> LatestTimestampView:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             LatestTimestampView:
        """

    def snapshot_at(self, time: TimeInput) -> LatestTimestampView:
        """
         Create a view of the LatestTimestampView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             LatestTimestampView:
        """

    def snapshot_latest(self) -> LatestTimestampView:
        """
         Create a view of the LatestTimestampView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             LatestTimestampView:
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionI64:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionI64: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionI64:
        """
        Sort results by node id

        Returns:
             NodeStateOptionI64: The sorted node state
        """

    @property
    def start(self) -> Optional[EventTime]:
        """
         Gets the start time for rolling and expanding windows for this LatestTimestampView

        Returns:
            Optional[EventTime]: The earliest time that this LatestTimestampView is valid or None if the LatestTimestampView is valid for all times.
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionI64:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionI64: The k largest values as a node state
        """

    def valid_layers(self, names: list[str]) -> LatestTimestampView:
        """
         Return a view of LatestTimestampView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             LatestTimestampView: The layered view
        """

    def values(self) -> Iterator[Optional[int]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[int]]: Iterator over values
        """

    def window(self, start: TimeInput, end: TimeInput) -> LatestTimestampView:
        """
         Create a view of the LatestTimestampView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput): The start time of the window.
            end (TimeInput): The end time of the window.

        Returns:
            LatestTimestampView:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this LatestTimestampView.

        Returns:
            Optional[int]:
        """

class LatestEventIdView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> LatestEventIdView:
        """
         Create a view of the LatestEventIdView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             LatestEventIdView:
        """

    def at(self, time: TimeInput) -> LatestEventIdView:
        """
         Create a view of the LatestEventIdView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             LatestEventIdView:
        """

    def before(self, end: TimeInput) -> LatestEventIdView:
        """
         Create a view of the LatestEventIdView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             LatestEventIdView:
        """

    def bottom_k(self, k: int) -> NodeStateOptionUsize:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionUsize: The k smallest values as a node state
        """

    def collect(self) -> list[Optional[int]]:
        """
        Compute all values and return the result as a list

        Returns:
             list[Optional[int]]: all values as a list
        """

    def compute(self) -> NodeStateOptionUsize:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateOptionUsize: the computed `NodeState`
        """

    def default_layer(self) -> LatestEventIdView:
        """
         Return a view of LatestEventIdView containing only the default edge layer
        Returns:
             LatestEventIdView: The layered view
        """

    @property
    def end(self) -> Optional[EventTime]:
        """
         Gets the latest time that this LatestEventIdView is valid.

        Returns:
           Optional[EventTime]: The latest time that this LatestEventIdView is valid or None if the LatestEventIdView is valid for all times.
        """

    def exclude_layer(self, name: str) -> LatestEventIdView:
        """
         Return a view of LatestEventIdView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             LatestEventIdView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> LatestEventIdView:
        """
         Return a view of LatestEventIdView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             LatestEventIdView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> LatestEventIdView:
        """
         Return a view of LatestEventIdView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             LatestEventIdView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> LatestEventIdView:
        """
         Return a view of LatestEventIdView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             LatestEventIdView: The layered view
        """

    def expanding(self, step: int | str, alignment_unit: str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step. For example, if the step is "1 month and 1 day",
                the windows will be aligned on days (00:00:00 to 23:59:59).
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def get(self, node: NodeInput, default: Optional[Optional[int]] = None) -> Optional[Optional[int]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[int]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[int]]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if LatestEventIdView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def items(self) -> Iterator[Tuple[Node, Optional[int]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[int]]]: Iterator over items
        """

    def latest(self) -> LatestEventIdView:
        """
         Create a view of the LatestEventIdView including all events at the latest time.

        Returns:
             LatestEventIdView:
        """

    def layer(self, name: str) -> LatestEventIdView:
        """
         Return a view of LatestEventIdView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             LatestEventIdView: The layered view
        """

    def layers(self, names: list[str]) -> LatestEventIdView:
        """
         Return a view of LatestEventIdView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             LatestEventIdView: The layered view
        """

    def max(self) -> Optional[Optional[int]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[int]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[Optional[int]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[int]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[int]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def rolling(self, window: int | str, step: int | str | None = None, alignment_unit: str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.
        If `alignment_unit` is not "unaligned" and a `step` larger than `window` is provided, some time entries
        may appear before the start of the first window and/or after the end of the last window (i.e. not included in any window).

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step (or window if no step is passed).
                For example, if the step is "1 month and 1 day",
                the first window will begin at the start of the day of the first time event.
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> LatestEventIdView:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             LatestEventIdView:
        """

    def shrink_start(self, start: TimeInput) -> LatestEventIdView:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             LatestEventIdView:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> LatestEventIdView:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             LatestEventIdView:
        """

    def snapshot_at(self, time: TimeInput) -> LatestEventIdView:
        """
         Create a view of the LatestEventIdView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             LatestEventIdView:
        """

    def snapshot_latest(self) -> LatestEventIdView:
        """
         Create a view of the LatestEventIdView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             LatestEventIdView:
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionUsize:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionUsize: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionUsize:
        """
        Sort results by node id

        Returns:
             NodeStateOptionUsize: The sorted node state
        """

    @property
    def start(self) -> Optional[EventTime]:
        """
         Gets the start time for rolling and expanding windows for this LatestEventIdView

        Returns:
            Optional[EventTime]: The earliest time that this LatestEventIdView is valid or None if the LatestEventIdView is valid for all times.
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionUsize:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionUsize: The k largest values as a node state
        """

    def valid_layers(self, names: list[str]) -> LatestEventIdView:
        """
         Return a view of LatestEventIdView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             LatestEventIdView: The layered view
        """

    def values(self) -> Iterator[Optional[int]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[int]]: Iterator over values
        """

    def window(self, start: TimeInput, end: TimeInput) -> LatestEventIdView:
        """
         Create a view of the LatestEventIdView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput): The start time of the window.
            end (TimeInput): The end time of the window.

        Returns:
            LatestEventIdView:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this LatestEventIdView.

        Returns:
            Optional[int]:
        """

class LatestDateTimeView(object): 
    """A lazy view over EarliestDateTime values for each node."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> LatestDateTimeView:
        """
         Create a view of the LatestDateTimeView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             LatestDateTimeView:
        """

    def at(self, time: TimeInput) -> LatestDateTimeView:
        """
         Create a view of the LatestDateTimeView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             LatestDateTimeView:
        """

    def before(self, end: TimeInput) -> LatestDateTimeView:
        """
         Create a view of the LatestDateTimeView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             LatestDateTimeView:
        """

    def bottom_k(self, k: int) -> NodeStateOptionDateTime:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
            NodeStateOptionDateTime: The k smallest values as a node state
        """

    def collect(self) -> list[Optional[datetime]]:
        """
        Compute all DateTime values and return the result as a list

        Returns:
            list[Optional[datetime]]: all values as a list
        """

    def collect_valid(self) -> list[datetime]:
        """
        Compute all DateTime values and return the valid results as a list. Conversion errors and empty values are ignored

        Returns:
            list[datetime]: all values as a list
        """

    def compute(self) -> NodeStateOptionDateTime:
        """
        Compute all DateTime values and return the result as a NodeState. Fails if any DateTime error is encountered.

        Returns:
            NodeStateOptionDateTime: the computed `NodeState`
        """

    def compute_valid(self) -> NodeStateOptionDateTime:
        """
        Compute all DateTime values and only return the valid results as a NodeState. DateTime errors are ignored.

        Returns:
            NodeStateOptionDateTime: the computed `NodeState`
        """

    def default_layer(self) -> LatestDateTimeView:
        """
         Return a view of LatestDateTimeView containing only the default edge layer
        Returns:
             LatestDateTimeView: The layered view
        """

    @property
    def end(self) -> Optional[EventTime]:
        """
         Gets the latest time that this LatestDateTimeView is valid.

        Returns:
           Optional[EventTime]: The latest time that this LatestDateTimeView is valid or None if the LatestDateTimeView is valid for all times.
        """

    def exclude_layer(self, name: str) -> LatestDateTimeView:
        """
         Return a view of LatestDateTimeView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             LatestDateTimeView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> LatestDateTimeView:
        """
         Return a view of LatestDateTimeView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             LatestDateTimeView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> LatestDateTimeView:
        """
         Return a view of LatestDateTimeView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             LatestDateTimeView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> LatestDateTimeView:
        """
         Return a view of LatestDateTimeView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             LatestDateTimeView: The layered view
        """

    def expanding(self, step: int | str, alignment_unit: str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step. For example, if the step is "1 month and 1 day",
                the windows will be aligned on days (00:00:00 to 23:59:59).
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def get(self, node: NodeInput, default: Optional[datetime] = None) -> Optional[datetime]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[datetime]): the default value. Defaults to None.

        Returns:
            Optional[datetime]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if LatestDateTimeView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def items(self) -> Iterator[Tuple[Node, Optional[datetime]]]:
        """
        Iterate over items

        Returns:
            Iterator[Tuple[Node, Optional[datetime]]]: Iterator over items
        """

    def items_valid(self) -> Iterator[Tuple[Node, datetime]]:
        """
        Iterate over valid DateTime items only. Ignore error and None values.

        Returns:
            Iterator[Tuple[Node, datetime]]: Iterator over items
        """

    def iter_valid(self) -> Iterator[datetime]:
        """
        Returns an iterator over all valid DateTime values. Conversion errors and empty values are ignored

        Returns:
            Iterator[datetime]: Valid DateTime values.
        """

    def latest(self) -> LatestDateTimeView:
        """
         Create a view of the LatestDateTimeView including all events at the latest time.

        Returns:
             LatestDateTimeView:
        """

    def layer(self, name: str) -> LatestDateTimeView:
        """
         Return a view of LatestDateTimeView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             LatestDateTimeView: The layered view
        """

    def layers(self, names: list[str]) -> LatestDateTimeView:
        """
         Return a view of LatestDateTimeView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             LatestDateTimeView: The layered view
        """

    def max(self) -> Optional[datetime]:
        """
        Return the maximum value

        Returns:
            Optional[datetime]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, datetime]]:
        """
        Return largest value and corresponding node

        Returns:
            Optional[Tuple[Node, datetime]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> Optional[datetime]:
        """
        Return the median value

        Returns:
            Optional[datetime]: The median value or `None` if empty
        """

    def median_item(self) -> Optional[Tuple[Node, datetime]]:
        """
        Return median value and corresponding node

        Returns:
            Optional[Tuple[Node, datetime]]: The median value or `None` if empty
        """

    def min(self) -> Optional[datetime]:
        """
        Return the minimum value

        Returns:
            Optional[datetime]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, datetime]]:
        """
        Return smallest value and corresponding node

        Returns:
            Optional[Tuple[Node, datetime]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def rolling(self, window: int | str, step: int | str | None = None, alignment_unit: str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.
        If `alignment_unit` is not "unaligned" and a `step` larger than `window` is provided, some time entries
        may appear before the start of the first window and/or after the end of the last window (i.e. not included in any window).

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step (or window if no step is passed).
                For example, if the step is "1 month and 1 day",
                the first window will begin at the start of the day of the first time event.
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> LatestDateTimeView:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             LatestDateTimeView:
        """

    def shrink_start(self, start: TimeInput) -> LatestDateTimeView:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             LatestDateTimeView:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> LatestDateTimeView:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             LatestDateTimeView:
        """

    def snapshot_at(self, time: TimeInput) -> LatestDateTimeView:
        """
         Create a view of the LatestDateTimeView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             LatestDateTimeView:
        """

    def snapshot_latest(self) -> LatestDateTimeView:
        """
         Create a view of the LatestDateTimeView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             LatestDateTimeView:
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionDateTime:
        """
        Sort by value. Note that 'None' values will always come after valid DateTime values

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
            NodeStateOptionDateTime: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionDateTime:
        """
        Sort results by node id. Fails if any DateTime error is encountered.

        Returns:
            NodeStateOptionDateTime: The sorted node state
        """

    def sorted_by_id_valid(self) -> NodeStateOptionDateTime:
        """
        Sort only non-error DateTimes by node id. DateTime errors are ignored.

        Returns:
            NodeStateOptionDateTime: The sorted node state
        """

    @property
    def start(self) -> Optional[EventTime]:
        """
         Gets the start time for rolling and expanding windows for this LatestDateTimeView

        Returns:
            Optional[EventTime]: The earliest time that this LatestDateTimeView is valid or None if the LatestDateTimeView is valid for all times.
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: A Pandas DataFrame.
        """

    def top_k(self, k: int) -> NodeStateOptionDateTime:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
            NodeStateOptionDateTime: The k largest values as a node state
        """

    def valid_layers(self, names: list[str]) -> LatestDateTimeView:
        """
         Return a view of LatestDateTimeView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             LatestDateTimeView: The layered view
        """

    def values(self) -> Iterator[Optional[datetime]]:
        """
        Iterate over DateTime values

        Returns:
            Iterator[Optional[datetime]]: Iterator over values
        """

    def values_valid(self) -> Iterator[datetime]:
        """
        Iterate over valid DateTime values only. Ignore error and None values.

        Returns:
            Iterator[datetime]: Iterator over values
        """

    def window(self, start: TimeInput, end: TimeInput) -> LatestDateTimeView:
        """
         Create a view of the LatestDateTimeView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput): The start time of the window.
            end (TimeInput): The end time of the window.

        Returns:
            LatestDateTimeView:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this LatestDateTimeView.

        Returns:
            Optional[int]:
        """

class NameView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateString:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateString: The k smallest values as a node state
        """

    def collect(self) -> list[str]:
        """
        Compute all values and return the result as a list

        Returns:
             list[str]: all values as a list
        """

    def compute(self) -> NodeStateString:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateString: the computed `NodeState`
        """

    def get(self, node: NodeInput, default: Optional[str] = None) -> Optional[str]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[str]): the default value. Defaults to None.

        Returns:
            Optional[str]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def items(self) -> Iterator[Tuple[Node, str]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, str]]: Iterator over items
        """

    def max(self) -> Optional[str]:
        """
        Return the maximum value

        Returns:
             Optional[str]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, str]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, str]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[str]:
        """

    def median_item(self) -> Optional[Tuple[Node, str]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, str]]: The median value or `None` if empty
        """

    def min(self) -> Optional[str]:
        """
        Return the minimum value

        Returns:
             Optional[str]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, str]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, str]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateString:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateString: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateString:
        """
        Sort results by node id

        Returns:
             NodeStateString: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateString:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateString: The k largest values as a node state
        """

    def values(self) -> Iterator[str]:
        """
        Iterate over values

        Returns:
             Iterator[str]: Iterator over values
        """

class NodeStateString(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateString:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateString: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[str] = None) -> Optional[str]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[str]): the default value. Defaults to None.

        Returns:
            Optional[str]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def items(self) -> Iterator[Tuple[Node, str]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, str]]: Iterator over items
        """

    def max(self) -> Optional[str]:
        """
        Return the maximum value

        Returns:
             Optional[str]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, str]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, str]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[str]:
        """

    def median_item(self) -> Optional[Tuple[Node, str]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, str]]: The median value or `None` if empty
        """

    def min(self) -> Optional[str]:
        """
        Return the minimum value

        Returns:
             Optional[str]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, str]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, str]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateString:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateString: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateString:
        """
        Sort results by node id

        Returns:
             NodeStateString: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateString:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateString: The k largest values as a node state
        """

    def values(self) -> Iterator[str]:
        """
        Iterate over values

        Returns:
             Iterator[str]: Iterator over values
        """

class HistoryView(object): 
    """A lazy view over History objects for each node."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> HistoryView:
        """
         Create a view of the HistoryView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             HistoryView:
        """

    def at(self, time: TimeInput) -> HistoryView:
        """
         Create a view of the HistoryView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             HistoryView:
        """

    def before(self, end: TimeInput) -> HistoryView:
        """
         Create a view of the HistoryView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             HistoryView:
        """

    def collect(self) -> list[History]:
        """
        Compute all History objects and return the result as a list

        Returns:
            list[History]: all History objects as a list
        """

    def collect_time_entries(self) -> list[EventTime]:
        """
        Compute all History objects and return the contained time entries as a sorted list

        Returns:
            list[EventTime]: all time entries as a list
        """

    def compute(self) -> NodeStateHistory:
        """
        Compute all values and return the result as a node view

        Returns:
            NodeStateHistory: the computed `NodeState`
        """

    def default_layer(self) -> HistoryView:
        """
         Return a view of HistoryView containing only the default edge layer
        Returns:
             HistoryView: The layered view
        """

    @property
    def dt(self) -> HistoryDateTimeView:
        """
        Access history events as UTC datetimes.

        Returns:
            HistoryDateTimeView: A lazy view over HistoryDateTime objects for each node.
        """

    def earliest_time(self) -> EarliestTimeView:
        """
        Get the earliest time entry.

        Returns:
            EarliestTimeView: A lazy view over the earliest time of each node as an EventTime.
        """

    @property
    def end(self) -> Optional[EventTime]:
        """
         Gets the latest time that this HistoryView is valid.

        Returns:
           Optional[EventTime]: The latest time that this HistoryView is valid or None if the HistoryView is valid for all times.
        """

    @property
    def event_id(self) -> HistoryEventIdView:
        """
        Access the unique event id of each time entry.

        Returns:
            HistoryEventIdView: A lazy view over HistoryEventId objects for each node.
        """

    def exclude_layer(self, name: str) -> HistoryView:
        """
         Return a view of HistoryView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             HistoryView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> HistoryView:
        """
         Return a view of HistoryView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             HistoryView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> HistoryView:
        """
         Return a view of HistoryView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             HistoryView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> HistoryView:
        """
         Return a view of HistoryView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             HistoryView: The layered view
        """

    def expanding(self, step: int | str, alignment_unit: str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step. For example, if the step is "1 month and 1 day",
                the windows will be aligned on days (00:00:00 to 23:59:59).
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def flatten(self) -> History:
        """
        Flattens all history objects into a single history with all time entries ordered.

        Returns:
            History: a history object containing all time entries
        """

    def get(self, node: NodeInput, default: Optional[History] = None) -> Optional[History]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[History]): the default value. Defaults to None.

        Returns:
            Optional[History]: the History object for the node or the default value
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if HistoryView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    @property
    def intervals(self) -> IntervalsView:
        """
        Access the intervals between consecutive timestamps in milliseconds.

        Returns:
            IntervalsView: A lazy view over Intervals objects for each node.
        """

    def items(self) -> Iterator[Tuple[Node, History]]:
        """
        Iterate over History objects

        Returns:
            Iterator[Tuple[Node, History]]: Iterator over histories
        """

    def latest(self) -> HistoryView:
        """
         Create a view of the HistoryView including all events at the latest time.

        Returns:
             HistoryView:
        """

    def latest_time(self) -> LatestTimeView:
        """
        Get the latest time entry.
        Returns:
            LatestTimeView: A lazy view over the latest time of each node as an EventTime.
        """

    def layer(self, name: str) -> HistoryView:
        """
         Return a view of HistoryView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             HistoryView: The layered view
        """

    def layers(self, names: list[str]) -> HistoryView:
        """
         Return a view of HistoryView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             HistoryView: The layered view
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def rolling(self, window: int | str, step: int | str | None = None, alignment_unit: str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.
        If `alignment_unit` is not "unaligned" and a `step` larger than `window` is provided, some time entries
        may appear before the start of the first window and/or after the end of the last window (i.e. not included in any window).

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step (or window if no step is passed).
                For example, if the step is "1 month and 1 day",
                the first window will begin at the start of the day of the first time event.
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> HistoryView:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             HistoryView:
        """

    def shrink_start(self, start: TimeInput) -> HistoryView:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             HistoryView:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> HistoryView:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             HistoryView:
        """

    def snapshot_at(self, time: TimeInput) -> HistoryView:
        """
         Create a view of the HistoryView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             HistoryView:
        """

    def snapshot_latest(self) -> HistoryView:
        """
         Create a view of the HistoryView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             HistoryView:
        """

    def sorted_by_id(self) -> NodeStateHistory:
        """
        Sort results by node id

        Returns:
            NodeStateHistory: The sorted node state
        """

    @property
    def start(self) -> Optional[EventTime]:
        """
         Gets the start time for rolling and expanding windows for this HistoryView

        Returns:
            Optional[EventTime]: The earliest time that this HistoryView is valid or None if the HistoryView is valid for all times.
        """

    @property
    def t(self) -> HistoryTimestampView:
        """
        Access history events as timestamps (milliseconds since the Unix epoch).

        Returns:
            HistoryTimestampView: A lazy view over HistoryTimestamp objects for each node.
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: A Pandas DataFrame.
        """

    def valid_layers(self, names: list[str]) -> HistoryView:
        """
         Return a view of HistoryView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             HistoryView: The layered view
        """

    def values(self) -> Iterator[History]:
        """
        Iterate over History objects

        Returns:
            Iterator[History]: Iterator over histories
        """

    def window(self, start: TimeInput, end: TimeInput) -> HistoryView:
        """
         Create a view of the HistoryView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput): The start time of the window.
            end (TimeInput): The end time of the window.

        Returns:
            HistoryView:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this HistoryView.

        Returns:
            Optional[int]:
        """

class HistoryTimestampView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def collect(self) -> list[HistoryTimestamp]:
        """
        Compute all values and return the result as a list

        Returns:
             list[HistoryTimestamp]: all values as a list
        """

    def compute(self) -> NodeStateHistoryTimestamp:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateHistoryTimestamp: the computed `NodeState`
        """

    def get(self, node: NodeInput, default: Optional[HistoryTimestamp] = None) -> Optional[HistoryTimestamp]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[HistoryTimestamp]): the default value. Defaults to None.

        Returns:
            Optional[HistoryTimestamp]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, HistoryTimestamp]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, HistoryTimestamp]]: Iterator over items
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted_by_id(self) -> NodeStateHistoryTimestamp:
        """
        Sort results by node id

        Returns:
             NodeStateHistoryTimestamp: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def values(self) -> Iterator[HistoryTimestamp]:
        """
        Iterate over values

        Returns:
             Iterator[HistoryTimestamp]: Iterator over values
        """

class HistoryDateTimeView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def collect(self) -> list[HistoryDateTime]:
        """
        Compute all values and return the result as a list

        Returns:
             list[HistoryDateTime]: all values as a list
        """

    def compute(self) -> NodeStateHistoryDateTime:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateHistoryDateTime: the computed `NodeState`
        """

    def get(self, node: NodeInput, default: Optional[HistoryDateTime] = None) -> Optional[HistoryDateTime]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[HistoryDateTime]): the default value. Defaults to None.

        Returns:
            Optional[HistoryDateTime]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, HistoryDateTime]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, HistoryDateTime]]: Iterator over items
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted_by_id(self) -> NodeStateHistoryDateTime:
        """
        Sort results by node id

        Returns:
             NodeStateHistoryDateTime: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def values(self) -> Iterator[HistoryDateTime]:
        """
        Iterate over values

        Returns:
             Iterator[HistoryDateTime]: Iterator over values
        """

class HistoryEventIdView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def collect(self) -> list[HistoryEventId]:
        """
        Compute all values and return the result as a list

        Returns:
             list[HistoryEventId]: all values as a list
        """

    def compute(self) -> NodeStateHistoryEventId:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateHistoryEventId: the computed `NodeState`
        """

    def get(self, node: NodeInput, default: Optional[HistoryEventId] = None) -> Optional[HistoryEventId]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[HistoryEventId]): the default value. Defaults to None.

        Returns:
            Optional[HistoryEventId]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, HistoryEventId]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, HistoryEventId]]: Iterator over items
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted_by_id(self) -> NodeStateHistoryEventId:
        """
        Sort results by node id

        Returns:
             NodeStateHistoryEventId: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def values(self) -> Iterator[HistoryEventId]:
        """
        Iterate over values

        Returns:
             Iterator[HistoryEventId]: Iterator over values
        """

class IntervalsView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def collect(self) -> list[Intervals]:
        """
        Compute all values and return the result as a list

        Returns:
             list[Intervals]: all values as a list
        """

    def compute(self) -> NodeStateIntervals:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateIntervals: the computed `NodeState`
        """

    def get(self, node: NodeInput, default: Optional[Intervals] = None) -> Optional[Intervals]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Intervals]): the default value. Defaults to None.

        Returns:
            Optional[Intervals]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, Intervals]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Intervals]]: Iterator over items
        """

    def max(self) -> IntervalsIntegerView:
        """
        Calculate the maximum interval in milliseconds for each node.

        Returns:
            IntervalsIntegerView: A lazy view over the maximum interval between consecutive timestamps for each node. The maximum is None if there is fewer than 1 interval.
        """

    def mean(self) -> IntervalsFloatView:
        """
        Calculate the mean interval in milliseconds for each node.

        Returns:
            IntervalsFloatView: A lazy view over the mean interval between consecutive timestamps for each node. The mean is None if there is fewer than 1 interval.
        """

    def median(self) -> IntervalsIntegerView:
        """
        Calculate the median interval in milliseconds for each node.

        Returns:
            IntervalsIntegerView: A lazy view over the median interval between consecutive timestamps for each node. The median is None if there is fewer than 1 interval.
        """

    def min(self) -> IntervalsIntegerView:
        """
        Calculate the minimum interval in milliseconds for each node.

        Returns:
            IntervalsIntegerView: A lazy view over the minimum interval between consecutive timestamps for each node. The minimum is None if there is fewer than 1 interval.
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted_by_id(self) -> NodeStateIntervals:
        """
        Sort results by node id

        Returns:
             NodeStateIntervals: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def values(self) -> Iterator[Intervals]:
        """
        Iterate over values

        Returns:
             Iterator[Intervals]: Iterator over values
        """

class IntervalsFloatView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateOptionF64:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionF64: The k smallest values as a node state
        """

    def collect(self) -> list[Optional[float]]:
        """
        Compute all values and return the result as a list

        Returns:
             list[Optional[float]]: all values as a list
        """

    def compute(self) -> NodeStateOptionF64:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateOptionF64: the computed `NodeState`
        """

    def get(self, node: NodeInput, default: Optional[Optional[float]] = None) -> Optional[Optional[float]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[float]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[float]]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, Optional[float]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[float]]]: Iterator over items
        """

    def max(self) -> Optional[Optional[float]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[float]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[float]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[float]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[Optional[float]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[float]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[float]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[float]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[float]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[float]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[float]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionF64:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionF64: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionF64:
        """
        Sort results by node id

        Returns:
             NodeStateOptionF64: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionF64:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionF64: The k largest values as a node state
        """

    def values(self) -> Iterator[Optional[float]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[float]]: Iterator over values
        """

class IntervalsIntegerView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateOptionI64:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionI64: The k smallest values as a node state
        """

    def collect(self) -> list[Optional[int]]:
        """
        Compute all values and return the result as a list

        Returns:
             list[Optional[int]]: all values as a list
        """

    def compute(self) -> NodeStateOptionI64:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateOptionI64: the computed `NodeState`
        """

    def get(self, node: NodeInput, default: Optional[Optional[int]] = None) -> Optional[Optional[int]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[int]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[int]]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, Optional[int]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[int]]]: Iterator over items
        """

    def max(self) -> Optional[Optional[int]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[int]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[Optional[int]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[int]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[int]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionI64:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionI64: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionI64:
        """
        Sort results by node id

        Returns:
             NodeStateOptionI64: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionI64:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionI64: The k largest values as a node state
        """

    def values(self) -> Iterator[Optional[int]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[int]]: Iterator over values
        """

class EdgeHistoryCountView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> EdgeHistoryCountView:
        """
         Create a view of the EdgeHistoryCountView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             EdgeHistoryCountView:
        """

    def at(self, time: TimeInput) -> EdgeHistoryCountView:
        """
         Create a view of the EdgeHistoryCountView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             EdgeHistoryCountView:
        """

    def before(self, end: TimeInput) -> EdgeHistoryCountView:
        """
         Create a view of the EdgeHistoryCountView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             EdgeHistoryCountView:
        """

    def bottom_k(self, k: int) -> EdgeHistoryCountView:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             EdgeHistoryCountView: The k smallest values as a node state
        """

    def collect(self) -> list[int]:
        """
        Compute all values and return the result as a list

        Returns:
             list[int]: all values as a list
        """

    def compute(self) -> EdgeHistoryCountView:
        """
        Compute all values and return the result as a node view

        Returns:
             EdgeHistoryCountView: the computed `NodeState`
        """

    def default_layer(self) -> EdgeHistoryCountView:
        """
         Return a view of EdgeHistoryCountView containing only the default edge layer
        Returns:
             EdgeHistoryCountView: The layered view
        """

    @property
    def end(self) -> Optional[EventTime]:
        """
         Gets the latest time that this EdgeHistoryCountView is valid.

        Returns:
           Optional[EventTime]: The latest time that this EdgeHistoryCountView is valid or None if the EdgeHistoryCountView is valid for all times.
        """

    def exclude_layer(self, name: str) -> EdgeHistoryCountView:
        """
         Return a view of EdgeHistoryCountView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             EdgeHistoryCountView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> EdgeHistoryCountView:
        """
         Return a view of EdgeHistoryCountView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             EdgeHistoryCountView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> EdgeHistoryCountView:
        """
         Return a view of EdgeHistoryCountView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             EdgeHistoryCountView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> EdgeHistoryCountView:
        """
         Return a view of EdgeHistoryCountView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             EdgeHistoryCountView: The layered view
        """

    def expanding(self, step: int | str, alignment_unit: str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step. For example, if the step is "1 month and 1 day",
                the windows will be aligned on days (00:00:00 to 23:59:59).
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def get(self, node: NodeInput, default: Optional[int] = None) -> Optional[int]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[int]): the default value. Defaults to None.

        Returns:
            Optional[int]: the value for the node or the default value
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if EdgeHistoryCountView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def items(self) -> Iterator[Tuple[Node, int]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, int]]: Iterator over items
        """

    def latest(self) -> EdgeHistoryCountView:
        """
         Create a view of the EdgeHistoryCountView including all events at the latest time.

        Returns:
             EdgeHistoryCountView:
        """

    def layer(self, name: str) -> EdgeHistoryCountView:
        """
         Return a view of EdgeHistoryCountView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             EdgeHistoryCountView: The layered view
        """

    def layers(self, names: list[str]) -> EdgeHistoryCountView:
        """
         Return a view of EdgeHistoryCountView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             EdgeHistoryCountView: The layered view
        """

    def max(self) -> Optional[int]:
        """
        Return the maximum value

        Returns:
             Optional[int]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The Node and maximum value or `None` if empty
        """

    def mean(self) -> float:
        """
        mean of values over all nodes

        Returns:
            float: mean value
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[int]:
        """

    def median_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The median value or `None` if empty
        """

    def min(self) -> Optional[int]:
        """
        Return the minimum value

        Returns:
             Optional[int]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def rolling(self, window: int | str, step: int | str | None = None, alignment_unit: str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.
        If `alignment_unit` is not "unaligned" and a `step` larger than `window` is provided, some time entries
        may appear before the start of the first window and/or after the end of the last window (i.e. not included in any window).

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.
            alignment_unit (str | None): If no alignment_unit is passed, aligns the start of the first window
                to the smallest unit of time passed to step (or window if no step is passed).
                For example, if the step is "1 month and 1 day",
                the first window will begin at the start of the day of the first time event.
                If set to "unaligned", the first window will begin at the first time event.
                If any other alignment unit is passed, the windows will be aligned to that unit.
                alignment_unit defaults to None.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> EdgeHistoryCountView:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             EdgeHistoryCountView:
        """

    def shrink_start(self, start: TimeInput) -> EdgeHistoryCountView:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             EdgeHistoryCountView:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> EdgeHistoryCountView:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             EdgeHistoryCountView:
        """

    def snapshot_at(self, time: TimeInput) -> EdgeHistoryCountView:
        """
         Create a view of the EdgeHistoryCountView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             EdgeHistoryCountView:
        """

    def snapshot_latest(self) -> EdgeHistoryCountView:
        """
         Create a view of the EdgeHistoryCountView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             EdgeHistoryCountView:
        """

    def sorted(self, reverse: bool = False) -> EdgeHistoryCountView:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             EdgeHistoryCountView: Sorted node state
        """

    def sorted_by_id(self) -> EdgeHistoryCountView:
        """
        Sort results by node id

        Returns:
             EdgeHistoryCountView: The sorted node state
        """

    @property
    def start(self) -> Optional[EventTime]:
        """
         Gets the start time for rolling and expanding windows for this EdgeHistoryCountView

        Returns:
            Optional[EventTime]: The earliest time that this EdgeHistoryCountView is valid or None if the EdgeHistoryCountView is valid for all times.
        """

    def sum(self) -> PropValue:
        """
        sum of values over all nodes

        Returns:
            PropValue:
                int: the sum
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> EdgeHistoryCountView:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             EdgeHistoryCountView: The k largest values as a node state
        """

    def valid_layers(self, names: list[str]) -> EdgeHistoryCountView:
        """
         Return a view of EdgeHistoryCountView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             EdgeHistoryCountView: The layered view
        """

    def values(self) -> Iterator[int]:
        """
        Iterate over values

        Returns:
             Iterator[int]: Iterator over values
        """

    def window(self, start: TimeInput, end: TimeInput) -> EdgeHistoryCountView:
        """
         Create a view of the EdgeHistoryCountView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput): The start time of the window.
            end (TimeInput): The end time of the window.

        Returns:
            EdgeHistoryCountView:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this EdgeHistoryCountView.

        Returns:
            Optional[int]:
        """

class UsizeIterable(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def collect(self):
        ...

    def max(self):
        ...

    def mean(self):
        ...

    def min(self):
        ...

    def sum(self):
        ...

class NodeTypeView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateOptionStr:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionStr: The k smallest values as a node state
        """

    def collect(self) -> list[Optional[str]]:
        """
        Compute all values and return the result as a list

        Returns:
             list[Optional[str]]: all values as a list
        """

    def compute(self) -> NodeStateOptionStr:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateOptionStr: the computed `NodeState`
        """

    def get(self, node: NodeInput, default: Optional[Optional[str]] = None) -> Optional[Optional[str]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[str]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[str]]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def items(self) -> Iterator[Tuple[Node, Optional[str]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[str]]]: Iterator over items
        """

    def max(self) -> Optional[Optional[str]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[str]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[str]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[str]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[Optional[str]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[str]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[str]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[str]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[str]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[str]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[str]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionStr:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionStr: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionStr:
        """
        Sort results by node id

        Returns:
             NodeStateOptionStr: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionStr:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionStr: The k largest values as a node state
        """

    def values(self) -> Iterator[Optional[str]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[str]]: Iterator over values
        """

class NodeStateOptionStr(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateOptionStr:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionStr: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[Optional[str]] = None) -> Optional[Optional[str]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[str]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[str]]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def items(self) -> Iterator[Tuple[Node, Optional[str]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[str]]]: Iterator over items
        """

    def max(self) -> Optional[Optional[str]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[str]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[str]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[str]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[Optional[str]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[str]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[str]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[str]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[str]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[str]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[str]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionStr:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionStr: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionStr:
        """
        Sort results by node id

        Returns:
             NodeStateOptionStr: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionStr:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionStr: The k largest values as a node state
        """

    def values(self) -> Iterator[Optional[str]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[str]]: Iterator over values
        """

class NodeStateListDateTime(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateListDateTime:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateListDateTime: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[list[datetime]] = None) -> Optional[list[datetime]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[list[datetime]]): the default value. Defaults to None.

        Returns:
            Optional[list[datetime]]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, list[datetime]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, list[datetime]]]: Iterator over items
        """

    def max(self) -> Optional[list[datetime]]:
        """
        Return the maximum value

        Returns:
             Optional[list[datetime]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, list[datetime]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, list[datetime]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[list[datetime]]:
        """

    def median_item(self) -> Optional[Tuple[Node, list[datetime]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, list[datetime]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[list[datetime]]:
        """
        Return the minimum value

        Returns:
             Optional[list[datetime]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, list[datetime]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, list[datetime]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateListDateTime:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateListDateTime: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateListDateTime:
        """
        Sort results by node id

        Returns:
             NodeStateListDateTime: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateListDateTime:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateListDateTime: The k largest values as a node state
        """

    def values(self) -> Iterator[list[datetime]]:
        """
        Iterate over values

        Returns:
             Iterator[list[datetime]]: Iterator over values
        """

class NodeStateWeightedSP(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def get(self, node: NodeInput, default: Optional[Tuple[float, Nodes]] = None) -> Optional[Tuple[float, Nodes]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Tuple[float, Nodes]]): the default value. Defaults to None.

        Returns:
            Optional[Tuple[float, Nodes]]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, Tuple[float, Nodes]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Tuple[float, Nodes]]]: Iterator over items
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted_by_id(self) -> NodeStateWeightedSP:
        """
        Sort results by node id

        Returns:
             NodeStateWeightedSP: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def values(self) -> Iterator[Tuple[float, Nodes]]:
        """
        Iterate over values

        Returns:
             Iterator[Tuple[float, Nodes]]: Iterator over values
        """

class NodeStateF64(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateF64:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateF64: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[float] = None) -> Optional[float]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[float]): the default value. Defaults to None.

        Returns:
            Optional[float]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, float]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, float]]: Iterator over items
        """

    def max(self) -> Optional[float]:
        """
        Return the maximum value

        Returns:
             Optional[float]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, float]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, float]]: The Node and maximum value or `None` if empty
        """

    def mean(self) -> float:
        """
        mean of values over all nodes

        Returns:
            float: mean value
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[float]:
        """

    def median_item(self) -> Optional[Tuple[Node, float]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, float]]: The median value or `None` if empty
        """

    def min(self) -> Optional[float]:
        """
        Return the minimum value

        Returns:
             Optional[float]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, float]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, float]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateF64:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateF64: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateF64:
        """
        Sort results by node id

        Returns:
             NodeStateF64: The sorted node state
        """

    def sum(self) -> PropValue:
        """
        sum of values over all nodes

        Returns:
            PropValue:
                float: the sum
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateF64:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateF64: The k largest values as a node state
        """

    def values(self) -> Iterator[float]:
        """
        Iterate over values

        Returns:
             Iterator[float]: Iterator over values
        """

class NodeStateOptionF64(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateOptionF64:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionF64: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[Optional[float]] = None) -> Optional[Optional[float]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[float]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[float]]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, Optional[float]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[float]]]: Iterator over items
        """

    def max(self) -> Optional[Optional[float]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[float]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[float]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[float]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[Optional[float]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[float]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[float]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[float]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[float]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[float]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[float]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionF64:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionF64: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionF64:
        """
        Sort results by node id

        Returns:
             NodeStateOptionF64: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionF64:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionF64: The k largest values as a node state
        """

    def values(self) -> Iterator[Optional[float]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[float]]: Iterator over values
        """

class NodeStateNodes(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def get(self, node: NodeInput, default: Optional[Nodes] = None) -> Optional[Nodes]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Nodes]): the default value. Defaults to None.

        Returns:
            Optional[Nodes]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, Nodes]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Nodes]]: Iterator over items
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted_by_id(self) -> NodeStateNodes:
        """
        Sort results by node id

        Returns:
             NodeStateNodes: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def values(self) -> Iterator[Nodes]:
        """
        Iterate over values

        Returns:
             Iterator[Nodes]: Iterator over values
        """

class NodeStateReachability(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def get(self, node: NodeInput, default: Optional[list[Tuple[int, str]]] = None) -> Optional[list[Tuple[int, str]]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[list[Tuple[int, str]]]): the default value. Defaults to None.

        Returns:
            Optional[list[Tuple[int, str]]]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, list[Tuple[int, str]]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, list[Tuple[int, str]]]]: Iterator over items
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted_by_id(self) -> NodeStateReachability:
        """
        Sort results by node id

        Returns:
             NodeStateReachability: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def values(self) -> Iterator[list[Tuple[int, str]]]:
        """
        Iterate over values

        Returns:
             Iterator[list[Tuple[int, str]]]: Iterator over values
        """

class NodeStateListF64(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def get(self, node: NodeInput, default: Optional[list[float]] = None) -> Optional[list[float]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[list[float]]): the default value. Defaults to None.

        Returns:
            Optional[list[float]]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, list[float]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, list[float]]]: Iterator over items
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted_by_id(self) -> NodeStateListF64:
        """
        Sort results by node id

        Returns:
             NodeStateListF64: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def values(self) -> Iterator[list[float]]:
        """
        Iterate over values

        Returns:
             Iterator[list[float]]: Iterator over values
        """

class NodeStateMotifs(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateMotifs:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateMotifs: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[list[int]] = None) -> Optional[list[int]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[list[int]]): the default value. Defaults to None.

        Returns:
            Optional[list[int]]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, list[int]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, list[int]]]: Iterator over items
        """

    def max(self) -> Optional[list[int]]:
        """
        Return the maximum value

        Returns:
             Optional[list[int]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, list[int]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, list[int]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[list[int]]:
        """

    def median_item(self) -> Optional[Tuple[Node, list[int]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, list[int]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[list[int]]:
        """
        Return the minimum value

        Returns:
             Optional[list[int]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, list[int]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, list[int]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateMotifs:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateMotifs: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateMotifs:
        """
        Sort results by node id

        Returns:
             NodeStateMotifs: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateMotifs:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateMotifs: The k largest values as a node state
        """

    def values(self) -> Iterator[list[int]]:
        """
        Iterate over values

        Returns:
             Iterator[list[int]]: Iterator over values
        """

class NodeStateHits(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateHits:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateHits: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[Tuple[float, float]] = None) -> Optional[Tuple[float, float]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Tuple[float, float]]): the default value. Defaults to None.

        Returns:
            Optional[Tuple[float, float]]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, Tuple[float, float]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Tuple[float, float]]]: Iterator over items
        """

    def max(self) -> Optional[Tuple[float, float]]:
        """
        Return the maximum value

        Returns:
             Optional[Tuple[float, float]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Tuple[float, float]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Tuple[float, float]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[Tuple[float, float]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Tuple[float, float]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Tuple[float, float]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Tuple[float, float]]:
        """
        Return the minimum value

        Returns:
             Optional[Tuple[float, float]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Tuple[float, float]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Tuple[float, float]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateHits:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateHits: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateHits:
        """
        Sort results by node id

        Returns:
             NodeStateHits: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateHits:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateHits: The k largest values as a node state
        """

    def values(self) -> Iterator[Tuple[float, float]]:
        """
        Iterate over values

        Returns:
             Iterator[Tuple[float, float]]: Iterator over values
        """

class NodeStateHistory(object): 
    """A NodeState of History objects for each node."""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def collect_time_entries(self) -> list[EventTime]:
        """
        Collect and return all the contained time entries as a sorted list.

        Returns:
            list[EventTime]: All time entries as a list.
        """

    @property
    def dt(self) -> NodeStateHistoryDateTime:
        """
        Access history events as UTC datetimes.

        Returns:
            NodeStateHistoryDateTime: A NodeState with the computed HistoryDateTime object for each node.
        """

    def earliest_time(self) -> Optional[EventTime]:
        """
        Get the earliest time entry of all nodes.

        Returns:
            Optional[EventTime]: The earliest event present in any of the nodes' histories.
        """

    @property
    def event_id(self) -> NodeStateHistoryEventId:
        """
        Access the unique event id of each time entry.

        Returns:
            NodeStateHistoryEventId: A NodeState with the computed HistoryEventId object for each node.
        """

    def flatten(self) -> History:
        """
        Flattens all history objects into a single history object with all time entries ordered.

        Returns:
            History: A history object containing all time entries.
        """

    def get(self, node: NodeInput, default: Optional[History] = None) -> Optional[History]:
        """
        Get History object for the node.

        Arguments:
            node (NodeInput): the node
            default (Optional[History]): The default value. Defaults to None.

        Returns:
            Optional[History]: The value for the node or the default value.
        """

    @property
    def intervals(self) -> NodeStateIntervals:
        """
        Access the intervals between consecutive timestamps in milliseconds.

        Returns:
            NodeStateIntervals: A NodeState with the computed Intervals object for each node.
        """

    def items(self) -> Iterator[Tuple[Node, History]]:
        """
        Iterate over items

        Returns:
            Iterator[Tuple[Node, History]]: Iterator over items.
        """

    def latest_time(self) -> Optional[EventTime]:
        """
        Get the latest time entry.

        Returns:
            Optional[EventTime]: The latest event present in any of the nodes' histories.
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes.

        Returns:
            Nodes: The nodes.
        """

    def sorted_by_id(self) -> NodeStateHistory:
        """
        Sort results by node id

        Returns:
            NodeStateHistory: The sorted node state.
        """

    @property
    def t(self) -> NodeStateHistoryTimestamp:
        """
        Access history events as timestamps (milliseconds since the Unix epoch).

        Returns:
            NodeStateHistoryTimestamp: A NodeState with the computed HistoryTimestamp object for each node.
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: A Pandas DataFrame.
        """

    def values(self) -> Iterator[History]:
        """
        Iterate over History objects.

        Returns:
            Iterator[History]: Iterator over History objects.
        """

class NodeStateHistoryTimestamp(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def get(self, node: NodeInput, default: Optional[HistoryTimestamp] = None) -> Optional[HistoryTimestamp]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[HistoryTimestamp]): the default value. Defaults to None.

        Returns:
            Optional[HistoryTimestamp]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, HistoryTimestamp]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, HistoryTimestamp]]: Iterator over items
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted_by_id(self) -> NodeStateHistoryTimestamp:
        """
        Sort results by node id

        Returns:
             NodeStateHistoryTimestamp: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def values(self) -> Iterator[HistoryTimestamp]:
        """
        Iterate over values

        Returns:
             Iterator[HistoryTimestamp]: Iterator over values
        """

class NodeStateHistoryDateTime(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def get(self, node: NodeInput, default: Optional[HistoryDateTime] = None) -> Optional[HistoryDateTime]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[HistoryDateTime]): the default value. Defaults to None.

        Returns:
            Optional[HistoryDateTime]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, HistoryDateTime]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, HistoryDateTime]]: Iterator over items
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted_by_id(self) -> NodeStateHistoryDateTime:
        """
        Sort results by node id

        Returns:
             NodeStateHistoryDateTime: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def values(self) -> Iterator[HistoryDateTime]:
        """
        Iterate over values

        Returns:
             Iterator[HistoryDateTime]: Iterator over values
        """

class NodeStateHistoryEventId(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def get(self, node: NodeInput, default: Optional[HistoryEventId] = None) -> Optional[HistoryEventId]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[HistoryEventId]): the default value. Defaults to None.

        Returns:
            Optional[HistoryEventId]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, HistoryEventId]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, HistoryEventId]]: Iterator over items
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted_by_id(self) -> NodeStateHistoryEventId:
        """
        Sort results by node id

        Returns:
             NodeStateHistoryEventId: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def values(self) -> Iterator[HistoryEventId]:
        """
        Iterate over values

        Returns:
             Iterator[HistoryEventId]: Iterator over values
        """

class NodeStateIntervals(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def get(self, node: NodeInput, default: Optional[Intervals] = None) -> Optional[Intervals]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Intervals]): the default value. Defaults to None.

        Returns:
            Optional[Intervals]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, Intervals]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Intervals]]: Iterator over items
        """

    def max(self) -> NodeStateOptionI64:
        """
        Calculate the maximum interval in milliseconds for each node.

        Returns:
            NodeStateOptionI64: A NodeState with the computed maximum interval between consecutive timestamps for each node. The maximum is None if there is fewer than 1 interval.
        """

    def mean(self) -> NodeStateOptionF64:
        """
        Calculate the mean interval in milliseconds for each node.

        Returns:
            NodeStateOptionF64: A NodeState with the computed mean interval between consecutive timestamps for each node. The mean is None if there is fewer than 1 interval.
        """

    def median(self) -> NodeStateOptionI64:
        """
        Calculate the median interval in milliseconds for each node.

        Returns:
            NodeStateOptionI64: A NodeState with the computed median interval between consecutive timestamps for each node. The median is None if there is fewer than 1 interval.
        """

    def min(self) -> NodeStateOptionI64:
        """
        Calculate the minimum interval in milliseconds for each node.

        Returns:
            NodeStateOptionI64: A NodeState with the computed minimum interval between consecutive timestamps for each node. The minimum is None if there is fewer than 1 interval.
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted_by_id(self) -> NodeStateIntervals:
        """
        Sort results by node id

        Returns:
             NodeStateIntervals: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def to_list(self) -> list[list[int]]:
        """
        Collect all intervals in milliseconds into a list for each node.

        Returns:
            list[list[int]]: List of intervals in milliseconds for each node.
        """

    def values(self) -> Iterator[Intervals]:
        """
        Iterate over values

        Returns:
             Iterator[Intervals]: Iterator over values
        """

class NodeStateSEIR(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateSEIR:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateSEIR: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[Infected] = None) -> Optional[Infected]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Infected]): the default value. Defaults to None.

        Returns:
            Optional[Infected]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, Infected]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Infected]]: Iterator over items
        """

    def max(self) -> Optional[Infected]:
        """
        Return the maximum value

        Returns:
             Optional[Infected]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Infected]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Infected]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> PropValue:
        """
        Return the median value

        Returns:
            PropValue:
             Optional[Infected]:
        """

    def median_item(self) -> Optional[Tuple[Node, Infected]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Infected]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Infected]:
        """
        Return the minimum value

        Returns:
             Optional[Infected]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Infected]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Infected]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateSEIR:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateSEIR: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateSEIR:
        """
        Sort results by node id

        Returns:
             NodeStateSEIR: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateSEIR:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateSEIR: The k largest values as a node state
        """

    def values(self) -> Iterator[Infected]:
        """
        Iterate over values

        Returns:
             Iterator[Infected]: Iterator over values
        """

class NodeLayout(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def get(self, node: NodeInput, default: Optional[list[float]] = None) -> Optional[list[float]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[list[float]]): the default value. Defaults to None.

        Returns:
            Optional[list[float]]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, list[float]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, list[float]]]: Iterator over items
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted_by_id(self) -> NodeLayout:
        """
        Sort results by node id

        Returns:
             NodeLayout: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def values(self) -> Iterator[list[float]]:
        """
        Iterate over values

        Returns:
             Iterator[list[float]]: Iterator over values
        """

class NodeStateF64String(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def get(self, node: NodeInput, default: Optional[Tuple[float, str]] = None) -> Optional[Tuple[float, str]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Tuple[float, str]]): the default value. Defaults to None.

        Returns:
            Optional[Tuple[float, str]]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, Tuple[float, str]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Tuple[float, str]]]: Iterator over items
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted_by_id(self) -> NodeStateF64String:
        """
        Sort results by node id

        Returns:
             NodeStateF64String: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def values(self) -> Iterator[Tuple[float, str]]:
        """
        Iterate over values

        Returns:
             Iterator[Tuple[float, str]]: Iterator over values
        """
