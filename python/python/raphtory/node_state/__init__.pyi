from __future__ import annotations

###############################################################################
#                                                                             #
#                      AUTOGENERATED TYPE STUB FILE                           #
#                                                                             #
#    This file was automatically generated. Do not modify it directly.        #
#    Any changes made here may be lost when the file is regenerated.          #
#                                                                             #
###############################################################################

from typing import *
from raphtory import *
import raphtory.filter as filter
from raphtory.algorithms import *
from raphtory.vectors import *
from raphtory.graphql import *
from raphtory.typing import *
from datetime import datetime
from pandas import DataFrame
from os import PathLike
import networkx as nx  # type: ignore
import pyvis  # type: ignore

__all__ = ['NodeGroups', 'DegreeView', 'NodeStateUsize', 'NodeStateU64', 'NodeStateOptionI64', 'IdView', 'NodeStateGID', 'EarliestTimeView', 'LatestTimeView', 'NameView', 'NodeStateString', 'EarliestDateTimeView', 'LatestDateTimeView', 'NodeStateOptionDateTime', 'HistoryView', 'EdgeHistoryCountView', 'NodeStateListI64', 'HistoryDateTimeView', 'NodeStateOptionListDateTime', 'NodeTypeView', 'NodeStateOptionStr', 'NodeStateListDateTime', 'NodeStateWeightedSP', 'NodeStateF64', 'NodeStateNodes', 'NodeStateReachability', 'NodeStateListF64', 'NodeStateMotifs', 'NodeStateHits', 'NodeStateSEIR', 'NodeLayout', 'NodeStateF64String']
class NodeGroups(object): 

    def __bool__(self):
        """True if self else False"""

    def __getitem__(self, key):
        """Return self[key]."""

    def __iter__(self):
        """Implement iter(self)."""

    def __len__(self):
        """Return len(self)."""

    def group(self, index: int) -> Tuple[Any, Nodes]:
        """
        Get group nodes and value

        Arguments:
            index (int): the group index

        Returns:
            Tuple[Any, Nodes]: Nodes and corresponding value
        """

    def group_subgraph(self, index: int) -> Tuple[Any, GraphView]:
        """
        Get group as subgraph

        Arguments:
            index (int): the group index

        Returns:
            Tuple[Any, GraphView]: The group as a subgraph and corresponding value
        """

    def iter_subgraphs(self) -> Iterator[Tuple[Any, GraphView]]:
        """
        Iterate over group subgraphs

        Returns:
            Iterator[Tuple[Any, GraphView]]: Iterator over subgraphs with corresponding value
        """

class DegreeView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> DegreeView:
        """
         Create a view of the DegreeView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             DegreeView:
        """

    def at(self, time: TimeInput) -> DegreeView:
        """
         Create a view of the DegreeView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             DegreeView:
        """

    def before(self, end: TimeInput) -> DegreeView:
        """
         Create a view of the DegreeView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             DegreeView:
        """

    def bottom_k(self, k: int) -> NodeStateUsize:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateUsize: The k smallest values as a node state
        """

    def collect(self) -> list[int]:
        """
        Compute all values and return the result as a list

        Returns:
             list[int]: all values as a list
        """

    def compute(self) -> NodeStateUsize:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateUsize: the computed `NodeState`
        """

    def default_layer(self) -> DegreeView:
        """
         Return a view of DegreeView containing only the default edge layer
        Returns:
             DegreeView: The layered view
        """

    @property
    def end(self) -> Optional[int]:
        """
         Gets the latest time that this DegreeView is valid.

        Returns:
           Optional[int]: The latest time that this DegreeView is valid or None if the DegreeView is valid for all times.
        """

    @property
    def end_date_time(self) -> Optional[datetime]:
        """
         Gets the latest datetime that this DegreeView is valid

        Returns:
             Optional[datetime]: The latest datetime that this DegreeView is valid or None if the DegreeView is valid for all times.
        """

    def exclude_layer(self, name: str) -> DegreeView:
        """
         Return a view of DegreeView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             DegreeView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> DegreeView:
        """
         Return a view of DegreeView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             DegreeView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> DegreeView:
        """
         Return a view of DegreeView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             DegreeView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> DegreeView:
        """
         Return a view of DegreeView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             DegreeView: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def get(self, node: NodeInput, default: Optional[int] = None) -> Optional[int]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[int]): the default value. Defaults to None.

        Returns:
            Optional[int]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if DegreeView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def items(self) -> Iterator[Tuple[Node, int]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, int]]: Iterator over items
        """

    def latest(self) -> DegreeView:
        """
         Create a view of the DegreeView including all events at the latest time.

        Returns:
             DegreeView:
        """

    def layer(self, name: str) -> DegreeView:
        """
         Return a view of DegreeView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             DegreeView: The layered view
        """

    def layers(self, names: list[str]) -> DegreeView:
        """
         Return a view of DegreeView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             DegreeView: The layered view
        """

    def max(self) -> Optional[int]:
        """
        Return the maximum value

        Returns:
             Optional[int]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The Node and maximum value or `None` if empty
        """

    def mean(self) -> float:
        """
        mean of values over all nodes

        Returns:
            float: mean value
        """

    def median(self) -> Optional[int]:
        """
        Return the median value

        Returns:
             Optional[int]:
        """

    def median_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The median value or `None` if empty
        """

    def min(self) -> Optional[int]:
        """
        Return the minimum value

        Returns:
             Optional[int]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> DegreeView:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             DegreeView:
        """

    def shrink_start(self, start: TimeInput) -> DegreeView:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             DegreeView:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> DegreeView:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             DegreeView:
        """

    def snapshot_at(self, time: TimeInput) -> DegreeView:
        """
         Create a view of the DegreeView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             DegreeView:
        """

    def snapshot_latest(self) -> DegreeView:
        """
         Create a view of the DegreeView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             DegreeView:
        """

    def sorted(self, reverse: bool = False) -> NodeStateUsize:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateUsize: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateUsize:
        """
        Sort results by node id

        Returns:
             NodeStateUsize: The sorted node state
        """

    @property
    def start(self) -> Optional[int]:
        """
         Gets the start time for rolling and expanding windows for this DegreeView

        Returns:
            Optional[int]: The earliest time that this DegreeView is valid or None if the DegreeView is valid for all times.
        """

    @property
    def start_date_time(self) -> Optional[datetime]:
        """
         Gets the earliest datetime that this DegreeView is valid

        Returns:
             Optional[datetime]: The earliest datetime that this DegreeView is valid or None if the DegreeView is valid for all times.
        """

    def sum(self) -> int:
        """
        sum of values over all nodes

        Returns:
                int: the sum
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateUsize:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateUsize: The k largest values as a node state
        """

    def valid_layers(self, names: list[str]) -> DegreeView:
        """
         Return a view of DegreeView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             DegreeView: The layered view
        """

    def values(self) -> Iterator[int]:
        """
        Iterate over values

        Returns:
             Iterator[int]: Iterator over values
        """

    def window(self, start: TimeInput | None, end: TimeInput | None) -> DegreeView:
        """
         Create a view of the DegreeView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
            DegreeView:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this DegreeView

        Returns:
            Optional[int]:
        """

class NodeStateUsize(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateUsize:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateUsize: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[int] = None) -> Optional[int]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[int]): the default value. Defaults to None.

        Returns:
            Optional[int]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def items(self) -> Iterator[Tuple[Node, int]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, int]]: Iterator over items
        """

    def max(self) -> Optional[int]:
        """
        Return the maximum value

        Returns:
             Optional[int]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The Node and maximum value or `None` if empty
        """

    def mean(self) -> float:
        """
        mean of values over all nodes

        Returns:
            float: mean value
        """

    def median(self) -> Optional[int]:
        """
        Return the median value

        Returns:
             Optional[int]:
        """

    def median_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The median value or `None` if empty
        """

    def min(self) -> Optional[int]:
        """
        Return the minimum value

        Returns:
             Optional[int]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateUsize:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateUsize: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateUsize:
        """
        Sort results by node id

        Returns:
             NodeStateUsize: The sorted node state
        """

    def sum(self) -> int:
        """
        sum of values over all nodes

        Returns:
                int: the sum
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateUsize:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateUsize: The k largest values as a node state
        """

    def values(self) -> Iterator[int]:
        """
        Iterate over values

        Returns:
             Iterator[int]: Iterator over values
        """

class NodeStateU64(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateU64:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateU64: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[int] = None) -> Optional[int]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[int]): the default value. Defaults to None.

        Returns:
            Optional[int]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, int]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, int]]: Iterator over items
        """

    def max(self) -> Optional[int]:
        """
        Return the maximum value

        Returns:
             Optional[int]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The Node and maximum value or `None` if empty
        """

    def mean(self) -> float:
        """
        mean of values over all nodes

        Returns:
            float: mean value
        """

    def median(self) -> Optional[int]:
        """
        Return the median value

        Returns:
             Optional[int]:
        """

    def median_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The median value or `None` if empty
        """

    def min(self) -> Optional[int]:
        """
        Return the minimum value

        Returns:
             Optional[int]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateU64:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateU64: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateU64:
        """
        Sort results by node id

        Returns:
             NodeStateU64: The sorted node state
        """

    def sum(self) -> int:
        """
        sum of values over all nodes

        Returns:
                int: the sum
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateU64:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateU64: The k largest values as a node state
        """

    def values(self) -> Iterator[int]:
        """
        Iterate over values

        Returns:
             Iterator[int]: Iterator over values
        """

class NodeStateOptionI64(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateOptionI64:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionI64: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[Optional[int]] = None) -> Optional[Optional[int]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[int]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[int]]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def items(self) -> Iterator[Tuple[Node, Optional[int]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[int]]]: Iterator over items
        """

    def max(self) -> Optional[Optional[int]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[int]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> Optional[Optional[int]]:
        """
        Return the median value

        Returns:
             Optional[Optional[int]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[int]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[int]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionI64:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionI64: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionI64:
        """
        Sort results by node id

        Returns:
             NodeStateOptionI64: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionI64:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionI64: The k largest values as a node state
        """

    def values(self) -> Iterator[Optional[int]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[int]]: Iterator over values
        """

class IdView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateGID:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateGID: The k smallest values as a node state
        """

    def collect(self) -> list[GID]:
        """
        Compute all values and return the result as a list

        Returns:
             list[GID]: all values as a list
        """

    def compute(self) -> NodeStateGID:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateGID: the computed `NodeState`
        """

    def get(self, node: NodeInput, default: Optional[GID] = None) -> Optional[GID]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[GID]): the default value. Defaults to None.

        Returns:
            Optional[GID]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, GID]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, GID]]: Iterator over items
        """

    def max(self) -> Optional[GID]:
        """
        Return the maximum value

        Returns:
             Optional[GID]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, GID]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, GID]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> Optional[GID]:
        """
        Return the median value

        Returns:
             Optional[GID]:
        """

    def median_item(self) -> Optional[Tuple[Node, GID]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, GID]]: The median value or `None` if empty
        """

    def min(self) -> Optional[GID]:
        """
        Return the minimum value

        Returns:
             Optional[GID]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, GID]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, GID]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateGID:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateGID: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateGID:
        """
        Sort results by node id

        Returns:
             NodeStateGID: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateGID:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateGID: The k largest values as a node state
        """

    def values(self) -> Iterator[GID]:
        """
        Iterate over values

        Returns:
             Iterator[GID]: Iterator over values
        """

class NodeStateGID(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateGID:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateGID: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[GID] = None) -> Optional[GID]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[GID]): the default value. Defaults to None.

        Returns:
            Optional[GID]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, GID]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, GID]]: Iterator over items
        """

    def max(self) -> Optional[GID]:
        """
        Return the maximum value

        Returns:
             Optional[GID]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, GID]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, GID]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> Optional[GID]:
        """
        Return the median value

        Returns:
             Optional[GID]:
        """

    def median_item(self) -> Optional[Tuple[Node, GID]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, GID]]: The median value or `None` if empty
        """

    def min(self) -> Optional[GID]:
        """
        Return the minimum value

        Returns:
             Optional[GID]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, GID]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, GID]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateGID:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateGID: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateGID:
        """
        Sort results by node id

        Returns:
             NodeStateGID: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateGID:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateGID: The k largest values as a node state
        """

    def values(self) -> Iterator[GID]:
        """
        Iterate over values

        Returns:
             Iterator[GID]: Iterator over values
        """

class EarliestTimeView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> EarliestTimeView:
        """
         Create a view of the EarliestTimeView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             EarliestTimeView:
        """

    def at(self, time: TimeInput) -> EarliestTimeView:
        """
         Create a view of the EarliestTimeView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             EarliestTimeView:
        """

    def before(self, end: TimeInput) -> EarliestTimeView:
        """
         Create a view of the EarliestTimeView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             EarliestTimeView:
        """

    def bottom_k(self, k: int) -> NodeStateOptionI64:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionI64: The k smallest values as a node state
        """

    def collect(self) -> list[Optional[int]]:
        """
        Compute all values and return the result as a list

        Returns:
             list[Optional[int]]: all values as a list
        """

    def compute(self) -> NodeStateOptionI64:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateOptionI64: the computed `NodeState`
        """

    def default_layer(self) -> EarliestTimeView:
        """
         Return a view of EarliestTimeView containing only the default edge layer
        Returns:
             EarliestTimeView: The layered view
        """

    @property
    def end(self) -> Optional[int]:
        """
         Gets the latest time that this EarliestTimeView is valid.

        Returns:
           Optional[int]: The latest time that this EarliestTimeView is valid or None if the EarliestTimeView is valid for all times.
        """

    @property
    def end_date_time(self) -> Optional[datetime]:
        """
         Gets the latest datetime that this EarliestTimeView is valid

        Returns:
             Optional[datetime]: The latest datetime that this EarliestTimeView is valid or None if the EarliestTimeView is valid for all times.
        """

    def exclude_layer(self, name: str) -> EarliestTimeView:
        """
         Return a view of EarliestTimeView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             EarliestTimeView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> EarliestTimeView:
        """
         Return a view of EarliestTimeView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             EarliestTimeView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> EarliestTimeView:
        """
         Return a view of EarliestTimeView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             EarliestTimeView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> EarliestTimeView:
        """
         Return a view of EarliestTimeView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             EarliestTimeView: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def get(self, node: NodeInput, default: Optional[Optional[int]] = None) -> Optional[Optional[int]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[int]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[int]]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if EarliestTimeView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def items(self) -> Iterator[Tuple[Node, Optional[int]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[int]]]: Iterator over items
        """

    def latest(self) -> EarliestTimeView:
        """
         Create a view of the EarliestTimeView including all events at the latest time.

        Returns:
             EarliestTimeView:
        """

    def layer(self, name: str) -> EarliestTimeView:
        """
         Return a view of EarliestTimeView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             EarliestTimeView: The layered view
        """

    def layers(self, names: list[str]) -> EarliestTimeView:
        """
         Return a view of EarliestTimeView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             EarliestTimeView: The layered view
        """

    def max(self) -> Optional[Optional[int]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[int]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> Optional[Optional[int]]:
        """
        Return the median value

        Returns:
             Optional[Optional[int]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[int]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[int]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> EarliestTimeView:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             EarliestTimeView:
        """

    def shrink_start(self, start: TimeInput) -> EarliestTimeView:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             EarliestTimeView:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> EarliestTimeView:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             EarliestTimeView:
        """

    def snapshot_at(self, time: TimeInput) -> EarliestTimeView:
        """
         Create a view of the EarliestTimeView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             EarliestTimeView:
        """

    def snapshot_latest(self) -> EarliestTimeView:
        """
         Create a view of the EarliestTimeView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             EarliestTimeView:
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionI64:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionI64: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionI64:
        """
        Sort results by node id

        Returns:
             NodeStateOptionI64: The sorted node state
        """

    @property
    def start(self) -> Optional[int]:
        """
         Gets the start time for rolling and expanding windows for this EarliestTimeView

        Returns:
            Optional[int]: The earliest time that this EarliestTimeView is valid or None if the EarliestTimeView is valid for all times.
        """

    @property
    def start_date_time(self) -> Optional[datetime]:
        """
         Gets the earliest datetime that this EarliestTimeView is valid

        Returns:
             Optional[datetime]: The earliest datetime that this EarliestTimeView is valid or None if the EarliestTimeView is valid for all times.
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionI64:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionI64: The k largest values as a node state
        """

    def valid_layers(self, names: list[str]) -> EarliestTimeView:
        """
         Return a view of EarliestTimeView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             EarliestTimeView: The layered view
        """

    def values(self) -> Iterator[Optional[int]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[int]]: Iterator over values
        """

    def window(self, start: TimeInput | None, end: TimeInput | None) -> EarliestTimeView:
        """
         Create a view of the EarliestTimeView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
            EarliestTimeView:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this EarliestTimeView

        Returns:
            Optional[int]:
        """

class LatestTimeView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> LatestTimeView:
        """
         Create a view of the LatestTimeView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             LatestTimeView:
        """

    def at(self, time: TimeInput) -> LatestTimeView:
        """
         Create a view of the LatestTimeView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             LatestTimeView:
        """

    def before(self, end: TimeInput) -> LatestTimeView:
        """
         Create a view of the LatestTimeView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             LatestTimeView:
        """

    def bottom_k(self, k: int) -> NodeStateOptionI64:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionI64: The k smallest values as a node state
        """

    def collect(self) -> list[Optional[int]]:
        """
        Compute all values and return the result as a list

        Returns:
             list[Optional[int]]: all values as a list
        """

    def compute(self) -> NodeStateOptionI64:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateOptionI64: the computed `NodeState`
        """

    def default_layer(self) -> LatestTimeView:
        """
         Return a view of LatestTimeView containing only the default edge layer
        Returns:
             LatestTimeView: The layered view
        """

    @property
    def end(self) -> Optional[int]:
        """
         Gets the latest time that this LatestTimeView is valid.

        Returns:
           Optional[int]: The latest time that this LatestTimeView is valid or None if the LatestTimeView is valid for all times.
        """

    @property
    def end_date_time(self) -> Optional[datetime]:
        """
         Gets the latest datetime that this LatestTimeView is valid

        Returns:
             Optional[datetime]: The latest datetime that this LatestTimeView is valid or None if the LatestTimeView is valid for all times.
        """

    def exclude_layer(self, name: str) -> LatestTimeView:
        """
         Return a view of LatestTimeView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             LatestTimeView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> LatestTimeView:
        """
         Return a view of LatestTimeView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             LatestTimeView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> LatestTimeView:
        """
         Return a view of LatestTimeView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             LatestTimeView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> LatestTimeView:
        """
         Return a view of LatestTimeView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             LatestTimeView: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def get(self, node: NodeInput, default: Optional[Optional[int]] = None) -> Optional[Optional[int]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[int]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[int]]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if LatestTimeView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def items(self) -> Iterator[Tuple[Node, Optional[int]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[int]]]: Iterator over items
        """

    def latest(self) -> LatestTimeView:
        """
         Create a view of the LatestTimeView including all events at the latest time.

        Returns:
             LatestTimeView:
        """

    def layer(self, name: str) -> LatestTimeView:
        """
         Return a view of LatestTimeView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             LatestTimeView: The layered view
        """

    def layers(self, names: list[str]) -> LatestTimeView:
        """
         Return a view of LatestTimeView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             LatestTimeView: The layered view
        """

    def max(self) -> Optional[Optional[int]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[int]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> Optional[Optional[int]]:
        """
        Return the median value

        Returns:
             Optional[Optional[int]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[int]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[int]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[int]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[int]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> LatestTimeView:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             LatestTimeView:
        """

    def shrink_start(self, start: TimeInput) -> LatestTimeView:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             LatestTimeView:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> LatestTimeView:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             LatestTimeView:
        """

    def snapshot_at(self, time: TimeInput) -> LatestTimeView:
        """
         Create a view of the LatestTimeView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             LatestTimeView:
        """

    def snapshot_latest(self) -> LatestTimeView:
        """
         Create a view of the LatestTimeView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             LatestTimeView:
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionI64:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionI64: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionI64:
        """
        Sort results by node id

        Returns:
             NodeStateOptionI64: The sorted node state
        """

    @property
    def start(self) -> Optional[int]:
        """
         Gets the start time for rolling and expanding windows for this LatestTimeView

        Returns:
            Optional[int]: The earliest time that this LatestTimeView is valid or None if the LatestTimeView is valid for all times.
        """

    @property
    def start_date_time(self) -> Optional[datetime]:
        """
         Gets the earliest datetime that this LatestTimeView is valid

        Returns:
             Optional[datetime]: The earliest datetime that this LatestTimeView is valid or None if the LatestTimeView is valid for all times.
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionI64:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionI64: The k largest values as a node state
        """

    def valid_layers(self, names: list[str]) -> LatestTimeView:
        """
         Return a view of LatestTimeView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             LatestTimeView: The layered view
        """

    def values(self) -> Iterator[Optional[int]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[int]]: Iterator over values
        """

    def window(self, start: TimeInput | None, end: TimeInput | None) -> LatestTimeView:
        """
         Create a view of the LatestTimeView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
            LatestTimeView:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this LatestTimeView

        Returns:
            Optional[int]:
        """

class NameView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateString:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateString: The k smallest values as a node state
        """

    def collect(self) -> list[str]:
        """
        Compute all values and return the result as a list

        Returns:
             list[str]: all values as a list
        """

    def compute(self) -> NodeStateString:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateString: the computed `NodeState`
        """

    def get(self, node: NodeInput, default: Optional[str] = None) -> Optional[str]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[str]): the default value. Defaults to None.

        Returns:
            Optional[str]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def items(self) -> Iterator[Tuple[Node, str]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, str]]: Iterator over items
        """

    def max(self) -> Optional[str]:
        """
        Return the maximum value

        Returns:
             Optional[str]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, str]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, str]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> Optional[str]:
        """
        Return the median value

        Returns:
             Optional[str]:
        """

    def median_item(self) -> Optional[Tuple[Node, str]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, str]]: The median value or `None` if empty
        """

    def min(self) -> Optional[str]:
        """
        Return the minimum value

        Returns:
             Optional[str]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, str]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, str]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateString:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateString: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateString:
        """
        Sort results by node id

        Returns:
             NodeStateString: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateString:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateString: The k largest values as a node state
        """

    def values(self) -> Iterator[str]:
        """
        Iterate over values

        Returns:
             Iterator[str]: Iterator over values
        """

class NodeStateString(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateString:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateString: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[str] = None) -> Optional[str]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[str]): the default value. Defaults to None.

        Returns:
            Optional[str]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def items(self) -> Iterator[Tuple[Node, str]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, str]]: Iterator over items
        """

    def max(self) -> Optional[str]:
        """
        Return the maximum value

        Returns:
             Optional[str]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, str]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, str]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> Optional[str]:
        """
        Return the median value

        Returns:
             Optional[str]:
        """

    def median_item(self) -> Optional[Tuple[Node, str]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, str]]: The median value or `None` if empty
        """

    def min(self) -> Optional[str]:
        """
        Return the minimum value

        Returns:
             Optional[str]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, str]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, str]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateString:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateString: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateString:
        """
        Sort results by node id

        Returns:
             NodeStateString: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateString:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateString: The k largest values as a node state
        """

    def values(self) -> Iterator[str]:
        """
        Iterate over values

        Returns:
             Iterator[str]: Iterator over values
        """

class EarliestDateTimeView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> EarliestDateTimeView:
        """
         Create a view of the EarliestDateTimeView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             EarliestDateTimeView:
        """

    def at(self, time: TimeInput) -> EarliestDateTimeView:
        """
         Create a view of the EarliestDateTimeView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             EarliestDateTimeView:
        """

    def before(self, end: TimeInput) -> EarliestDateTimeView:
        """
         Create a view of the EarliestDateTimeView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             EarliestDateTimeView:
        """

    def bottom_k(self, k: int) -> NodeStateOptionDateTime:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionDateTime: The k smallest values as a node state
        """

    def collect(self) -> list[Optional[datetime]]:
        """
        Compute all values and return the result as a list

        Returns:
             list[Optional[datetime]]: all values as a list
        """

    def compute(self) -> NodeStateOptionDateTime:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateOptionDateTime: the computed `NodeState`
        """

    def default_layer(self) -> EarliestDateTimeView:
        """
         Return a view of EarliestDateTimeView containing only the default edge layer
        Returns:
             EarliestDateTimeView: The layered view
        """

    @property
    def end(self) -> Optional[int]:
        """
         Gets the latest time that this EarliestDateTimeView is valid.

        Returns:
           Optional[int]: The latest time that this EarliestDateTimeView is valid or None if the EarliestDateTimeView is valid for all times.
        """

    @property
    def end_date_time(self) -> Optional[datetime]:
        """
         Gets the latest datetime that this EarliestDateTimeView is valid

        Returns:
             Optional[datetime]: The latest datetime that this EarliestDateTimeView is valid or None if the EarliestDateTimeView is valid for all times.
        """

    def exclude_layer(self, name: str) -> EarliestDateTimeView:
        """
         Return a view of EarliestDateTimeView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             EarliestDateTimeView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> EarliestDateTimeView:
        """
         Return a view of EarliestDateTimeView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             EarliestDateTimeView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> EarliestDateTimeView:
        """
         Return a view of EarliestDateTimeView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             EarliestDateTimeView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> EarliestDateTimeView:
        """
         Return a view of EarliestDateTimeView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             EarliestDateTimeView: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def get(self, node: NodeInput, default: Optional[Optional[datetime]] = None) -> Optional[Optional[datetime]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[datetime]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[datetime]]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if EarliestDateTimeView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def items(self) -> Iterator[Tuple[Node, Optional[datetime]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[datetime]]]: Iterator over items
        """

    def latest(self) -> EarliestDateTimeView:
        """
         Create a view of the EarliestDateTimeView including all events at the latest time.

        Returns:
             EarliestDateTimeView:
        """

    def layer(self, name: str) -> EarliestDateTimeView:
        """
         Return a view of EarliestDateTimeView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             EarliestDateTimeView: The layered view
        """

    def layers(self, names: list[str]) -> EarliestDateTimeView:
        """
         Return a view of EarliestDateTimeView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             EarliestDateTimeView: The layered view
        """

    def max(self) -> Optional[Optional[datetime]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[datetime]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[datetime]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[datetime]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> Optional[Optional[datetime]]:
        """
        Return the median value

        Returns:
             Optional[Optional[datetime]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[datetime]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[datetime]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[datetime]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[datetime]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[datetime]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[datetime]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> EarliestDateTimeView:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             EarliestDateTimeView:
        """

    def shrink_start(self, start: TimeInput) -> EarliestDateTimeView:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             EarliestDateTimeView:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> EarliestDateTimeView:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             EarliestDateTimeView:
        """

    def snapshot_at(self, time: TimeInput) -> EarliestDateTimeView:
        """
         Create a view of the EarliestDateTimeView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             EarliestDateTimeView:
        """

    def snapshot_latest(self) -> EarliestDateTimeView:
        """
         Create a view of the EarliestDateTimeView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             EarliestDateTimeView:
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionDateTime:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionDateTime: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionDateTime:
        """
        Sort results by node id

        Returns:
             NodeStateOptionDateTime: The sorted node state
        """

    @property
    def start(self) -> Optional[int]:
        """
         Gets the start time for rolling and expanding windows for this EarliestDateTimeView

        Returns:
            Optional[int]: The earliest time that this EarliestDateTimeView is valid or None if the EarliestDateTimeView is valid for all times.
        """

    @property
    def start_date_time(self) -> Optional[datetime]:
        """
         Gets the earliest datetime that this EarliestDateTimeView is valid

        Returns:
             Optional[datetime]: The earliest datetime that this EarliestDateTimeView is valid or None if the EarliestDateTimeView is valid for all times.
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionDateTime:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionDateTime: The k largest values as a node state
        """

    def valid_layers(self, names: list[str]) -> EarliestDateTimeView:
        """
         Return a view of EarliestDateTimeView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             EarliestDateTimeView: The layered view
        """

    def values(self) -> Iterator[Optional[datetime]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[datetime]]: Iterator over values
        """

    def window(self, start: TimeInput | None, end: TimeInput | None) -> EarliestDateTimeView:
        """
         Create a view of the EarliestDateTimeView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
            EarliestDateTimeView:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this EarliestDateTimeView

        Returns:
            Optional[int]:
        """

class LatestDateTimeView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> LatestDateTimeView:
        """
         Create a view of the LatestDateTimeView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             LatestDateTimeView:
        """

    def at(self, time: TimeInput) -> LatestDateTimeView:
        """
         Create a view of the LatestDateTimeView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             LatestDateTimeView:
        """

    def before(self, end: TimeInput) -> LatestDateTimeView:
        """
         Create a view of the LatestDateTimeView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             LatestDateTimeView:
        """

    def bottom_k(self, k: int) -> NodeStateOptionDateTime:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionDateTime: The k smallest values as a node state
        """

    def collect(self) -> list[Optional[datetime]]:
        """
        Compute all values and return the result as a list

        Returns:
             list[Optional[datetime]]: all values as a list
        """

    def compute(self) -> NodeStateOptionDateTime:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateOptionDateTime: the computed `NodeState`
        """

    def default_layer(self) -> LatestDateTimeView:
        """
         Return a view of LatestDateTimeView containing only the default edge layer
        Returns:
             LatestDateTimeView: The layered view
        """

    @property
    def end(self) -> Optional[int]:
        """
         Gets the latest time that this LatestDateTimeView is valid.

        Returns:
           Optional[int]: The latest time that this LatestDateTimeView is valid or None if the LatestDateTimeView is valid for all times.
        """

    @property
    def end_date_time(self) -> Optional[datetime]:
        """
         Gets the latest datetime that this LatestDateTimeView is valid

        Returns:
             Optional[datetime]: The latest datetime that this LatestDateTimeView is valid or None if the LatestDateTimeView is valid for all times.
        """

    def exclude_layer(self, name: str) -> LatestDateTimeView:
        """
         Return a view of LatestDateTimeView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             LatestDateTimeView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> LatestDateTimeView:
        """
         Return a view of LatestDateTimeView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             LatestDateTimeView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> LatestDateTimeView:
        """
         Return a view of LatestDateTimeView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             LatestDateTimeView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> LatestDateTimeView:
        """
         Return a view of LatestDateTimeView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             LatestDateTimeView: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def get(self, node: NodeInput, default: Optional[Optional[datetime]] = None) -> Optional[Optional[datetime]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[datetime]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[datetime]]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if LatestDateTimeView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def items(self) -> Iterator[Tuple[Node, Optional[datetime]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[datetime]]]: Iterator over items
        """

    def latest(self) -> LatestDateTimeView:
        """
         Create a view of the LatestDateTimeView including all events at the latest time.

        Returns:
             LatestDateTimeView:
        """

    def layer(self, name: str) -> LatestDateTimeView:
        """
         Return a view of LatestDateTimeView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             LatestDateTimeView: The layered view
        """

    def layers(self, names: list[str]) -> LatestDateTimeView:
        """
         Return a view of LatestDateTimeView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             LatestDateTimeView: The layered view
        """

    def max(self) -> Optional[Optional[datetime]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[datetime]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[datetime]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[datetime]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> Optional[Optional[datetime]]:
        """
        Return the median value

        Returns:
             Optional[Optional[datetime]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[datetime]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[datetime]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[datetime]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[datetime]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[datetime]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[datetime]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> LatestDateTimeView:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             LatestDateTimeView:
        """

    def shrink_start(self, start: TimeInput) -> LatestDateTimeView:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             LatestDateTimeView:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> LatestDateTimeView:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             LatestDateTimeView:
        """

    def snapshot_at(self, time: TimeInput) -> LatestDateTimeView:
        """
         Create a view of the LatestDateTimeView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             LatestDateTimeView:
        """

    def snapshot_latest(self) -> LatestDateTimeView:
        """
         Create a view of the LatestDateTimeView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             LatestDateTimeView:
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionDateTime:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionDateTime: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionDateTime:
        """
        Sort results by node id

        Returns:
             NodeStateOptionDateTime: The sorted node state
        """

    @property
    def start(self) -> Optional[int]:
        """
         Gets the start time for rolling and expanding windows for this LatestDateTimeView

        Returns:
            Optional[int]: The earliest time that this LatestDateTimeView is valid or None if the LatestDateTimeView is valid for all times.
        """

    @property
    def start_date_time(self) -> Optional[datetime]:
        """
         Gets the earliest datetime that this LatestDateTimeView is valid

        Returns:
             Optional[datetime]: The earliest datetime that this LatestDateTimeView is valid or None if the LatestDateTimeView is valid for all times.
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionDateTime:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionDateTime: The k largest values as a node state
        """

    def valid_layers(self, names: list[str]) -> LatestDateTimeView:
        """
         Return a view of LatestDateTimeView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             LatestDateTimeView: The layered view
        """

    def values(self) -> Iterator[Optional[datetime]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[datetime]]: Iterator over values
        """

    def window(self, start: TimeInput | None, end: TimeInput | None) -> LatestDateTimeView:
        """
         Create a view of the LatestDateTimeView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
            LatestDateTimeView:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this LatestDateTimeView

        Returns:
            Optional[int]:
        """

class NodeStateOptionDateTime(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateOptionDateTime:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionDateTime: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[Optional[datetime]] = None) -> Optional[Optional[datetime]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[datetime]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[datetime]]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def items(self) -> Iterator[Tuple[Node, Optional[datetime]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[datetime]]]: Iterator over items
        """

    def max(self) -> Optional[Optional[datetime]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[datetime]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[datetime]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[datetime]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> Optional[Optional[datetime]]:
        """
        Return the median value

        Returns:
             Optional[Optional[datetime]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[datetime]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[datetime]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[datetime]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[datetime]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[datetime]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[datetime]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionDateTime:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionDateTime: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionDateTime:
        """
        Sort results by node id

        Returns:
             NodeStateOptionDateTime: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionDateTime:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionDateTime: The k largest values as a node state
        """

    def values(self) -> Iterator[Optional[datetime]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[datetime]]: Iterator over values
        """

class HistoryView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> HistoryView:
        """
         Create a view of the HistoryView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             HistoryView:
        """

    def at(self, time: TimeInput) -> HistoryView:
        """
         Create a view of the HistoryView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             HistoryView:
        """

    def before(self, end: TimeInput) -> HistoryView:
        """
         Create a view of the HistoryView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             HistoryView:
        """

    def bottom_k(self, k: int) -> NodeStateListI64:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateListI64: The k smallest values as a node state
        """

    def collect(self) -> list[list[int]]:
        """
        Compute all values and return the result as a list

        Returns:
             list[list[int]]: all values as a list
        """

    def compute(self) -> NodeStateListI64:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateListI64: the computed `NodeState`
        """

    def default_layer(self) -> HistoryView:
        """
         Return a view of HistoryView containing only the default edge layer
        Returns:
             HistoryView: The layered view
        """

    @property
    def end(self) -> Optional[int]:
        """
         Gets the latest time that this HistoryView is valid.

        Returns:
           Optional[int]: The latest time that this HistoryView is valid or None if the HistoryView is valid for all times.
        """

    @property
    def end_date_time(self) -> Optional[datetime]:
        """
         Gets the latest datetime that this HistoryView is valid

        Returns:
             Optional[datetime]: The latest datetime that this HistoryView is valid or None if the HistoryView is valid for all times.
        """

    def exclude_layer(self, name: str) -> HistoryView:
        """
         Return a view of HistoryView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             HistoryView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> HistoryView:
        """
         Return a view of HistoryView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             HistoryView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> HistoryView:
        """
         Return a view of HistoryView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             HistoryView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> HistoryView:
        """
         Return a view of HistoryView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             HistoryView: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def get(self, node: NodeInput, default: Optional[list[int]] = None) -> Optional[list[int]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[list[int]]): the default value. Defaults to None.

        Returns:
            Optional[list[int]]: the value for the node or the default value
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if HistoryView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def items(self) -> Iterator[Tuple[Node, list[int]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, list[int]]]: Iterator over items
        """

    def latest(self) -> HistoryView:
        """
         Create a view of the HistoryView including all events at the latest time.

        Returns:
             HistoryView:
        """

    def layer(self, name: str) -> HistoryView:
        """
         Return a view of HistoryView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             HistoryView: The layered view
        """

    def layers(self, names: list[str]) -> HistoryView:
        """
         Return a view of HistoryView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             HistoryView: The layered view
        """

    def max(self) -> Optional[list[int]]:
        """
        Return the maximum value

        Returns:
             Optional[list[int]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, list[int]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, list[int]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> Optional[list[int]]:
        """
        Return the median value

        Returns:
             Optional[list[int]]:
        """

    def median_item(self) -> Optional[Tuple[Node, list[int]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, list[int]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[list[int]]:
        """
        Return the minimum value

        Returns:
             Optional[list[int]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, list[int]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, list[int]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> HistoryView:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             HistoryView:
        """

    def shrink_start(self, start: TimeInput) -> HistoryView:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             HistoryView:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> HistoryView:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             HistoryView:
        """

    def snapshot_at(self, time: TimeInput) -> HistoryView:
        """
         Create a view of the HistoryView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             HistoryView:
        """

    def snapshot_latest(self) -> HistoryView:
        """
         Create a view of the HistoryView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             HistoryView:
        """

    def sorted(self, reverse: bool = False) -> NodeStateListI64:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateListI64: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateListI64:
        """
        Sort results by node id

        Returns:
             NodeStateListI64: The sorted node state
        """

    @property
    def start(self) -> Optional[int]:
        """
         Gets the start time for rolling and expanding windows for this HistoryView

        Returns:
            Optional[int]: The earliest time that this HistoryView is valid or None if the HistoryView is valid for all times.
        """

    @property
    def start_date_time(self) -> Optional[datetime]:
        """
         Gets the earliest datetime that this HistoryView is valid

        Returns:
             Optional[datetime]: The earliest datetime that this HistoryView is valid or None if the HistoryView is valid for all times.
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateListI64:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateListI64: The k largest values as a node state
        """

    def valid_layers(self, names: list[str]) -> HistoryView:
        """
         Return a view of HistoryView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             HistoryView: The layered view
        """

    def values(self) -> Iterator[list[int]]:
        """
        Iterate over values

        Returns:
             Iterator[list[int]]: Iterator over values
        """

    def window(self, start: TimeInput | None, end: TimeInput | None) -> HistoryView:
        """
         Create a view of the HistoryView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
            HistoryView:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this HistoryView

        Returns:
            Optional[int]:
        """

class EdgeHistoryCountView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> EdgeHistoryCountView:
        """
         Create a view of the EdgeHistoryCountView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             EdgeHistoryCountView:
        """

    def at(self, time: TimeInput) -> EdgeHistoryCountView:
        """
         Create a view of the EdgeHistoryCountView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             EdgeHistoryCountView:
        """

    def before(self, end: TimeInput) -> EdgeHistoryCountView:
        """
         Create a view of the EdgeHistoryCountView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             EdgeHistoryCountView:
        """

    def bottom_k(self, k: int) -> EdgeHistoryCountView:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             EdgeHistoryCountView: The k smallest values as a node state
        """

    def collect(self) -> list[int]:
        """
        Compute all values and return the result as a list

        Returns:
             list[int]: all values as a list
        """

    def compute(self) -> EdgeHistoryCountView:
        """
        Compute all values and return the result as a node view

        Returns:
             EdgeHistoryCountView: the computed `NodeState`
        """

    def default_layer(self) -> EdgeHistoryCountView:
        """
         Return a view of EdgeHistoryCountView containing only the default edge layer
        Returns:
             EdgeHistoryCountView: The layered view
        """

    @property
    def end(self) -> Optional[int]:
        """
         Gets the latest time that this EdgeHistoryCountView is valid.

        Returns:
           Optional[int]: The latest time that this EdgeHistoryCountView is valid or None if the EdgeHistoryCountView is valid for all times.
        """

    @property
    def end_date_time(self) -> Optional[datetime]:
        """
         Gets the latest datetime that this EdgeHistoryCountView is valid

        Returns:
             Optional[datetime]: The latest datetime that this EdgeHistoryCountView is valid or None if the EdgeHistoryCountView is valid for all times.
        """

    def exclude_layer(self, name: str) -> EdgeHistoryCountView:
        """
         Return a view of EdgeHistoryCountView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             EdgeHistoryCountView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> EdgeHistoryCountView:
        """
         Return a view of EdgeHistoryCountView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             EdgeHistoryCountView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> EdgeHistoryCountView:
        """
         Return a view of EdgeHistoryCountView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             EdgeHistoryCountView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> EdgeHistoryCountView:
        """
         Return a view of EdgeHistoryCountView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             EdgeHistoryCountView: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def get(self, node: NodeInput, default: Optional[int] = None) -> Optional[int]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[int]): the default value. Defaults to None.

        Returns:
            Optional[int]: the value for the node or the default value
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if EdgeHistoryCountView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def items(self) -> Iterator[Tuple[Node, int]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, int]]: Iterator over items
        """

    def latest(self) -> EdgeHistoryCountView:
        """
         Create a view of the EdgeHistoryCountView including all events at the latest time.

        Returns:
             EdgeHistoryCountView:
        """

    def layer(self, name: str) -> EdgeHistoryCountView:
        """
         Return a view of EdgeHistoryCountView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             EdgeHistoryCountView: The layered view
        """

    def layers(self, names: list[str]) -> EdgeHistoryCountView:
        """
         Return a view of EdgeHistoryCountView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             EdgeHistoryCountView: The layered view
        """

    def max(self) -> Optional[int]:
        """
        Return the maximum value

        Returns:
             Optional[int]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The Node and maximum value or `None` if empty
        """

    def mean(self) -> float:
        """
        mean of values over all nodes

        Returns:
            float: mean value
        """

    def median(self) -> Optional[int]:
        """
        Return the median value

        Returns:
             Optional[int]:
        """

    def median_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The median value or `None` if empty
        """

    def min(self) -> Optional[int]:
        """
        Return the minimum value

        Returns:
             Optional[int]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, int]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, int]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> EdgeHistoryCountView:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             EdgeHistoryCountView:
        """

    def shrink_start(self, start: TimeInput) -> EdgeHistoryCountView:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             EdgeHistoryCountView:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> EdgeHistoryCountView:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             EdgeHistoryCountView:
        """

    def snapshot_at(self, time: TimeInput) -> EdgeHistoryCountView:
        """
         Create a view of the EdgeHistoryCountView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             EdgeHistoryCountView:
        """

    def snapshot_latest(self) -> EdgeHistoryCountView:
        """
         Create a view of the EdgeHistoryCountView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             EdgeHistoryCountView:
        """

    def sorted(self, reverse: bool = False) -> EdgeHistoryCountView:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             EdgeHistoryCountView: Sorted node state
        """

    def sorted_by_id(self) -> EdgeHistoryCountView:
        """
        Sort results by node id

        Returns:
             EdgeHistoryCountView: The sorted node state
        """

    @property
    def start(self) -> Optional[int]:
        """
         Gets the start time for rolling and expanding windows for this EdgeHistoryCountView

        Returns:
            Optional[int]: The earliest time that this EdgeHistoryCountView is valid or None if the EdgeHistoryCountView is valid for all times.
        """

    @property
    def start_date_time(self) -> Optional[datetime]:
        """
         Gets the earliest datetime that this EdgeHistoryCountView is valid

        Returns:
             Optional[datetime]: The earliest datetime that this EdgeHistoryCountView is valid or None if the EdgeHistoryCountView is valid for all times.
        """

    def sum(self) -> int:
        """
        sum of values over all nodes

        Returns:
                int: the sum
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> EdgeHistoryCountView:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             EdgeHistoryCountView: The k largest values as a node state
        """

    def valid_layers(self, names: list[str]) -> EdgeHistoryCountView:
        """
         Return a view of EdgeHistoryCountView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             EdgeHistoryCountView: The layered view
        """

    def values(self) -> Iterator[int]:
        """
        Iterate over values

        Returns:
             Iterator[int]: Iterator over values
        """

    def window(self, start: TimeInput | None, end: TimeInput | None) -> EdgeHistoryCountView:
        """
         Create a view of the EdgeHistoryCountView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
            EdgeHistoryCountView:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this EdgeHistoryCountView

        Returns:
            Optional[int]:
        """

class NodeStateListI64(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateListI64:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateListI64: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[list[int]] = None) -> Optional[list[int]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[list[int]]): the default value. Defaults to None.

        Returns:
            Optional[list[int]]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, list[int]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, list[int]]]: Iterator over items
        """

    def max(self) -> Optional[list[int]]:
        """
        Return the maximum value

        Returns:
             Optional[list[int]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, list[int]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, list[int]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> Optional[list[int]]:
        """
        Return the median value

        Returns:
             Optional[list[int]]:
        """

    def median_item(self) -> Optional[Tuple[Node, list[int]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, list[int]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[list[int]]:
        """
        Return the minimum value

        Returns:
             Optional[list[int]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, list[int]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, list[int]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateListI64:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateListI64: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateListI64:
        """
        Sort results by node id

        Returns:
             NodeStateListI64: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateListI64:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateListI64: The k largest values as a node state
        """

    def values(self) -> Iterator[list[int]]:
        """
        Iterate over values

        Returns:
             Iterator[list[int]]: Iterator over values
        """

class HistoryDateTimeView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def after(self, start: TimeInput) -> HistoryDateTimeView:
        """
         Create a view of the HistoryDateTimeView including all events after `start` (exclusive).

        Arguments:
            start (TimeInput): The start time of the window.

        Returns:
             HistoryDateTimeView:
        """

    def at(self, time: TimeInput) -> HistoryDateTimeView:
        """
         Create a view of the HistoryDateTimeView including all events at `time`.

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             HistoryDateTimeView:
        """

    def before(self, end: TimeInput) -> HistoryDateTimeView:
        """
         Create a view of the HistoryDateTimeView including all events before `end` (exclusive).

        Arguments:
            end (TimeInput): The end time of the window.

        Returns:
             HistoryDateTimeView:
        """

    def bottom_k(self, k: int) -> NodeStateOptionListDateTime:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionListDateTime: The k smallest values as a node state
        """

    def collect(self) -> list[Optional[list[datetime]]]:
        """
        Compute all values and return the result as a list

        Returns:
             list[Optional[list[datetime]]]: all values as a list
        """

    def compute(self) -> NodeStateOptionListDateTime:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateOptionListDateTime: the computed `NodeState`
        """

    def default_layer(self) -> HistoryDateTimeView:
        """
         Return a view of HistoryDateTimeView containing only the default edge layer
        Returns:
             HistoryDateTimeView: The layered view
        """

    @property
    def end(self) -> Optional[int]:
        """
         Gets the latest time that this HistoryDateTimeView is valid.

        Returns:
           Optional[int]: The latest time that this HistoryDateTimeView is valid or None if the HistoryDateTimeView is valid for all times.
        """

    @property
    def end_date_time(self) -> Optional[datetime]:
        """
         Gets the latest datetime that this HistoryDateTimeView is valid

        Returns:
             Optional[datetime]: The latest datetime that this HistoryDateTimeView is valid or None if the HistoryDateTimeView is valid for all times.
        """

    def exclude_layer(self, name: str) -> HistoryDateTimeView:
        """
         Return a view of HistoryDateTimeView containing all layers except the excluded `name`
        Errors if any of the layers do not exist.

        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             HistoryDateTimeView: The layered view
        """

    def exclude_layers(self, names: list[str]) -> HistoryDateTimeView:
        """
         Return a view of HistoryDateTimeView containing all layers except the excluded `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             HistoryDateTimeView: The layered view
        """

    def exclude_valid_layer(self, name: str) -> HistoryDateTimeView:
        """
         Return a view of HistoryDateTimeView containing all layers except the excluded `name`
        Arguments:
            name (str): layer name that is excluded for the new view

        Returns:
             HistoryDateTimeView: The layered view
        """

    def exclude_valid_layers(self, names: list[str]) -> HistoryDateTimeView:
        """
         Return a view of HistoryDateTimeView containing all layers except the excluded `names`
        Arguments:
            names (list[str]): list of layer names that are excluded for the new view

        Returns:
             HistoryDateTimeView: The layered view
        """

    def expanding(self, step: int | str) -> WindowSet:
        """
        Creates a `WindowSet` with the given `step` size using an expanding window.

        An expanding window is a window that grows by `step` size at each iteration.

        Arguments:
            step (int | str): The step size of the window.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def get(self, node: NodeInput, default: Optional[Optional[list[datetime]]] = None) -> Optional[Optional[list[datetime]]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[list[datetime]]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[list[datetime]]]: the value for the node or the default value
        """

    def has_layer(self, name: str) -> bool:
        """
         Check if HistoryDateTimeView has the layer `"name"`

        Arguments:
            name (str): the name of the layer to check

        Returns:
            bool:
        """

    def items(self) -> Iterator[Tuple[Node, Optional[list[datetime]]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[list[datetime]]]]: Iterator over items
        """

    def latest(self) -> HistoryDateTimeView:
        """
         Create a view of the HistoryDateTimeView including all events at the latest time.

        Returns:
             HistoryDateTimeView:
        """

    def layer(self, name: str) -> HistoryDateTimeView:
        """
         Return a view of HistoryDateTimeView containing the layer `"name"`
        Errors if the layer does not exist

        Arguments:
            name (str): then name of the layer.

        Returns:
             HistoryDateTimeView: The layered view
        """

    def layers(self, names: list[str]) -> HistoryDateTimeView:
        """
         Return a view of HistoryDateTimeView containing all layers `names`
        Errors if any of the layers do not exist.

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             HistoryDateTimeView: The layered view
        """

    def max(self) -> Optional[Optional[list[datetime]]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[list[datetime]]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[list[datetime]]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[list[datetime]]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> Optional[Optional[list[datetime]]]:
        """
        Return the median value

        Returns:
             Optional[Optional[list[datetime]]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[list[datetime]]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[list[datetime]]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[list[datetime]]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[list[datetime]]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[list[datetime]]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[list[datetime]]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def rolling(self, window: int | str, step: int | str | None = None) -> WindowSet:
        """
        Creates a `WindowSet` with the given `window` size and optional `step` using a rolling window.

        A rolling window is a window that moves forward by `step` size at each iteration.

        Arguments:
            window (int | str): The size of the window.
            step (int | str | None): The step size of the window.
                `step` defaults to `window`.

        Returns:
            WindowSet: A `WindowSet` object.
        """

    def shrink_end(self, end: TimeInput) -> HistoryDateTimeView:
        """
        Set the end of the window to the smaller of `end` and `self.end()`

        Arguments:
            end (TimeInput): the new end time of the window
        Returns:
             HistoryDateTimeView:
        """

    def shrink_start(self, start: TimeInput) -> HistoryDateTimeView:
        """
        Set the start of the window to the larger of `start` and `self.start()`

        Arguments:
           start (TimeInput): the new start time of the window

        Returns:
             HistoryDateTimeView:
        """

    def shrink_window(self, start: TimeInput, end: TimeInput) -> HistoryDateTimeView:
        """
        Shrink both the start and end of the window (same as calling `shrink_start` followed by `shrink_end` but more efficient)

        Arguments:
            start (TimeInput): the new start time for the window
            end (TimeInput): the new end time for the window

        Returns:
             HistoryDateTimeView:
        """

    def snapshot_at(self, time: TimeInput) -> HistoryDateTimeView:
        """
         Create a view of the HistoryDateTimeView including all events that have not been explicitly deleted at `time`.

        This is equivalent to `before(time + 1)` for `Graph` and `at(time)` for `PersistentGraph`

        Arguments:
            time (TimeInput): The time of the window.

        Returns:
             HistoryDateTimeView:
        """

    def snapshot_latest(self) -> HistoryDateTimeView:
        """
         Create a view of the HistoryDateTimeView including all events that have not been explicitly deleted at the latest time.

        This is equivalent to a no-op for `Graph` and `latest()` for `PersistentGraph`

        Returns:
             HistoryDateTimeView:
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionListDateTime:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionListDateTime: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionListDateTime:
        """
        Sort results by node id

        Returns:
             NodeStateOptionListDateTime: The sorted node state
        """

    @property
    def start(self) -> Optional[int]:
        """
         Gets the start time for rolling and expanding windows for this HistoryDateTimeView

        Returns:
            Optional[int]: The earliest time that this HistoryDateTimeView is valid or None if the HistoryDateTimeView is valid for all times.
        """

    @property
    def start_date_time(self) -> Optional[datetime]:
        """
         Gets the earliest datetime that this HistoryDateTimeView is valid

        Returns:
             Optional[datetime]: The earliest datetime that this HistoryDateTimeView is valid or None if the HistoryDateTimeView is valid for all times.
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionListDateTime:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionListDateTime: The k largest values as a node state
        """

    def valid_layers(self, names: list[str]) -> HistoryDateTimeView:
        """
         Return a view of HistoryDateTimeView containing all layers `names`
        Any layers that do not exist are ignored

        Arguments:
            names (list[str]): list of layer names for the new view

        Returns:
             HistoryDateTimeView: The layered view
        """

    def values(self) -> Iterator[Optional[list[datetime]]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[list[datetime]]]: Iterator over values
        """

    def window(self, start: TimeInput | None, end: TimeInput | None) -> HistoryDateTimeView:
        """
         Create a view of the HistoryDateTimeView including all events between `start` (inclusive) and `end` (exclusive)

        Arguments:
            start (TimeInput | None): The start time of the window (unbounded if `None`).
            end (TimeInput | None): The end time of the window (unbounded if `None`).

        Returns:
            HistoryDateTimeView:
        """

    @property
    def window_size(self) -> Optional[int]:
        """
         Get the window size (difference between start and end) for this HistoryDateTimeView

        Returns:
            Optional[int]:
        """

class NodeStateOptionListDateTime(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateOptionListDateTime:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionListDateTime: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[Optional[list[datetime]]] = None) -> Optional[Optional[list[datetime]]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[list[datetime]]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[list[datetime]]]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, Optional[list[datetime]]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[list[datetime]]]]: Iterator over items
        """

    def max(self) -> Optional[Optional[list[datetime]]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[list[datetime]]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[list[datetime]]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[list[datetime]]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> Optional[Optional[list[datetime]]]:
        """
        Return the median value

        Returns:
             Optional[Optional[list[datetime]]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[list[datetime]]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[list[datetime]]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[list[datetime]]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[list[datetime]]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[list[datetime]]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[list[datetime]]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionListDateTime:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionListDateTime: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionListDateTime:
        """
        Sort results by node id

        Returns:
             NodeStateOptionListDateTime: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionListDateTime:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionListDateTime: The k largest values as a node state
        """

    def values(self) -> Iterator[Optional[list[datetime]]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[list[datetime]]]: Iterator over values
        """

class NodeTypeView(object): 
    """A lazy view over node values"""

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateOptionStr:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionStr: The k smallest values as a node state
        """

    def collect(self) -> list[Optional[str]]:
        """
        Compute all values and return the result as a list

        Returns:
             list[Optional[str]]: all values as a list
        """

    def compute(self) -> NodeStateOptionStr:
        """
        Compute all values and return the result as a node view

        Returns:
             NodeStateOptionStr: the computed `NodeState`
        """

    def get(self, node: NodeInput, default: Optional[Optional[str]] = None) -> Optional[Optional[str]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[str]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[str]]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def items(self) -> Iterator[Tuple[Node, Optional[str]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[str]]]: Iterator over items
        """

    def max(self) -> Optional[Optional[str]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[str]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[str]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[str]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> Optional[Optional[str]]:
        """
        Return the median value

        Returns:
             Optional[Optional[str]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[str]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[str]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[str]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[str]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[str]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[str]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionStr:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionStr: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionStr:
        """
        Sort results by node id

        Returns:
             NodeStateOptionStr: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionStr:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionStr: The k largest values as a node state
        """

    def values(self) -> Iterator[Optional[str]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[str]]: Iterator over values
        """

class NodeStateOptionStr(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateOptionStr:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionStr: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[Optional[str]] = None) -> Optional[Optional[str]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Optional[str]]): the default value. Defaults to None.

        Returns:
            Optional[Optional[str]]: the value for the node or the default value
        """

    def groups(self) -> NodeGroups:
        """
        Group by value

        Returns:
            NodeGroups: The grouped nodes
        """

    def items(self) -> Iterator[Tuple[Node, Optional[str]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Optional[str]]]: Iterator over items
        """

    def max(self) -> Optional[Optional[str]]:
        """
        Return the maximum value

        Returns:
             Optional[Optional[str]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Optional[str]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[str]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> Optional[Optional[str]]:
        """
        Return the median value

        Returns:
             Optional[Optional[str]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Optional[str]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[str]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Optional[str]]:
        """
        Return the minimum value

        Returns:
             Optional[Optional[str]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Optional[str]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Optional[str]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateOptionStr:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateOptionStr: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateOptionStr:
        """
        Sort results by node id

        Returns:
             NodeStateOptionStr: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateOptionStr:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateOptionStr: The k largest values as a node state
        """

    def values(self) -> Iterator[Optional[str]]:
        """
        Iterate over values

        Returns:
             Iterator[Optional[str]]: Iterator over values
        """

class NodeStateListDateTime(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateListDateTime:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateListDateTime: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[list[datetime]] = None) -> Optional[list[datetime]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[list[datetime]]): the default value. Defaults to None.

        Returns:
            Optional[list[datetime]]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, list[datetime]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, list[datetime]]]: Iterator over items
        """

    def max(self) -> Optional[list[datetime]]:
        """
        Return the maximum value

        Returns:
             Optional[list[datetime]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, list[datetime]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, list[datetime]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> Optional[list[datetime]]:
        """
        Return the median value

        Returns:
             Optional[list[datetime]]:
        """

    def median_item(self) -> Optional[Tuple[Node, list[datetime]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, list[datetime]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[list[datetime]]:
        """
        Return the minimum value

        Returns:
             Optional[list[datetime]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, list[datetime]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, list[datetime]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateListDateTime:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateListDateTime: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateListDateTime:
        """
        Sort results by node id

        Returns:
             NodeStateListDateTime: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateListDateTime:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateListDateTime: The k largest values as a node state
        """

    def values(self) -> Iterator[list[datetime]]:
        """
        Iterate over values

        Returns:
             Iterator[list[datetime]]: Iterator over values
        """

class NodeStateWeightedSP(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def get(self, node: NodeInput, default: Optional[Tuple[float, Nodes]] = None) -> Optional[Tuple[float, Nodes]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Tuple[float, Nodes]]): the default value. Defaults to None.

        Returns:
            Optional[Tuple[float, Nodes]]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, Tuple[float, Nodes]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Tuple[float, Nodes]]]: Iterator over items
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted_by_id(self) -> NodeStateWeightedSP:
        """
        Sort results by node id

        Returns:
             NodeStateWeightedSP: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def values(self) -> Iterator[Tuple[float, Nodes]]:
        """
        Iterate over values

        Returns:
             Iterator[Tuple[float, Nodes]]: Iterator over values
        """

class NodeStateF64(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateF64:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateF64: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[float] = None) -> Optional[float]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[float]): the default value. Defaults to None.

        Returns:
            Optional[float]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, float]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, float]]: Iterator over items
        """

    def max(self) -> Optional[float]:
        """
        Return the maximum value

        Returns:
             Optional[float]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, float]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, float]]: The Node and maximum value or `None` if empty
        """

    def mean(self) -> float:
        """
        mean of values over all nodes

        Returns:
            float: mean value
        """

    def median(self) -> Optional[float]:
        """
        Return the median value

        Returns:
             Optional[float]:
        """

    def median_item(self) -> Optional[Tuple[Node, float]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, float]]: The median value or `None` if empty
        """

    def min(self) -> Optional[float]:
        """
        Return the minimum value

        Returns:
             Optional[float]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, float]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, float]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateF64:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateF64: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateF64:
        """
        Sort results by node id

        Returns:
             NodeStateF64: The sorted node state
        """

    def sum(self) -> float:
        """
        sum of values over all nodes

        Returns:
                float: the sum
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateF64:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateF64: The k largest values as a node state
        """

    def values(self) -> Iterator[float]:
        """
        Iterate over values

        Returns:
             Iterator[float]: Iterator over values
        """

class NodeStateNodes(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def get(self, node: NodeInput, default: Optional[Nodes] = None) -> Optional[Nodes]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Nodes]): the default value. Defaults to None.

        Returns:
            Optional[Nodes]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, Nodes]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Nodes]]: Iterator over items
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted_by_id(self) -> NodeStateNodes:
        """
        Sort results by node id

        Returns:
             NodeStateNodes: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def values(self) -> Iterator[Nodes]:
        """
        Iterate over values

        Returns:
             Iterator[Nodes]: Iterator over values
        """

class NodeStateReachability(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def get(self, node: NodeInput, default: Optional[list[Tuple[int, str]]] = None) -> Optional[list[Tuple[int, str]]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[list[Tuple[int, str]]]): the default value. Defaults to None.

        Returns:
            Optional[list[Tuple[int, str]]]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, list[Tuple[int, str]]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, list[Tuple[int, str]]]]: Iterator over items
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted_by_id(self) -> NodeStateReachability:
        """
        Sort results by node id

        Returns:
             NodeStateReachability: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def values(self) -> Iterator[list[Tuple[int, str]]]:
        """
        Iterate over values

        Returns:
             Iterator[list[Tuple[int, str]]]: Iterator over values
        """

class NodeStateListF64(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def get(self, node: NodeInput, default: Optional[list[float]] = None) -> Optional[list[float]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[list[float]]): the default value. Defaults to None.

        Returns:
            Optional[list[float]]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, list[float]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, list[float]]]: Iterator over items
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted_by_id(self) -> NodeStateListF64:
        """
        Sort results by node id

        Returns:
             NodeStateListF64: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def values(self) -> Iterator[list[float]]:
        """
        Iterate over values

        Returns:
             Iterator[list[float]]: Iterator over values
        """

class NodeStateMotifs(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateMotifs:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateMotifs: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[list[int]] = None) -> Optional[list[int]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[list[int]]): the default value. Defaults to None.

        Returns:
            Optional[list[int]]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, list[int]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, list[int]]]: Iterator over items
        """

    def max(self) -> Optional[list[int]]:
        """
        Return the maximum value

        Returns:
             Optional[list[int]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, list[int]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, list[int]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> Optional[list[int]]:
        """
        Return the median value

        Returns:
             Optional[list[int]]:
        """

    def median_item(self) -> Optional[Tuple[Node, list[int]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, list[int]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[list[int]]:
        """
        Return the minimum value

        Returns:
             Optional[list[int]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, list[int]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, list[int]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateMotifs:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateMotifs: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateMotifs:
        """
        Sort results by node id

        Returns:
             NodeStateMotifs: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateMotifs:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateMotifs: The k largest values as a node state
        """

    def values(self) -> Iterator[list[int]]:
        """
        Iterate over values

        Returns:
             Iterator[list[int]]: Iterator over values
        """

class NodeStateHits(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateHits:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateHits: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[Tuple[float, float]] = None) -> Optional[Tuple[float, float]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Tuple[float, float]]): the default value. Defaults to None.

        Returns:
            Optional[Tuple[float, float]]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, Tuple[float, float]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Tuple[float, float]]]: Iterator over items
        """

    def max(self) -> Optional[Tuple[float, float]]:
        """
        Return the maximum value

        Returns:
             Optional[Tuple[float, float]]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Tuple[float, float]]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Tuple[float, float]]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> Optional[Tuple[float, float]]:
        """
        Return the median value

        Returns:
             Optional[Tuple[float, float]]:
        """

    def median_item(self) -> Optional[Tuple[Node, Tuple[float, float]]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Tuple[float, float]]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Tuple[float, float]]:
        """
        Return the minimum value

        Returns:
             Optional[Tuple[float, float]]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Tuple[float, float]]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Tuple[float, float]]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateHits:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateHits: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateHits:
        """
        Sort results by node id

        Returns:
             NodeStateHits: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateHits:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateHits: The k largest values as a node state
        """

    def values(self) -> Iterator[Tuple[float, float]]:
        """
        Iterate over values

        Returns:
             Iterator[Tuple[float, float]]: Iterator over values
        """

class NodeStateSEIR(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def bottom_k(self, k: int) -> NodeStateSEIR:
        """
        Compute the k smallest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateSEIR: The k smallest values as a node state
        """

    def get(self, node: NodeInput, default: Optional[Infected] = None) -> Optional[Infected]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Infected]): the default value. Defaults to None.

        Returns:
            Optional[Infected]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, Infected]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Infected]]: Iterator over items
        """

    def max(self) -> Optional[Infected]:
        """
        Return the maximum value

        Returns:
             Optional[Infected]: The maximum value or `None` if empty
        """

    def max_item(self) -> Optional[Tuple[Node, Infected]]:
        """
        Return largest value and corresponding node

        Returns:
             Optional[Tuple[Node, Infected]]: The Node and maximum value or `None` if empty
        """

    def median(self) -> Optional[Infected]:
        """
        Return the median value

        Returns:
             Optional[Infected]:
        """

    def median_item(self) -> Optional[Tuple[Node, Infected]]:
        """
        Return median value and corresponding node

        Returns:
             Optional[Tuple[Node, Infected]]: The median value or `None` if empty
        """

    def min(self) -> Optional[Infected]:
        """
        Return the minimum value

        Returns:
             Optional[Infected]: The minimum value or `None` if empty
        """

    def min_item(self) -> Optional[Tuple[Node, Infected]]:
        """
        Return smallest value and corresponding node

        Returns:
             Optional[Tuple[Node, Infected]]: The Node and minimum value or `None` if empty
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted(self, reverse: bool = False) -> NodeStateSEIR:
        """
        Sort by value

        Arguments:
            reverse (bool): If `True`, sort in descending order, otherwise ascending. Defaults to False.

        Returns:
             NodeStateSEIR: Sorted node state
        """

    def sorted_by_id(self) -> NodeStateSEIR:
        """
        Sort results by node id

        Returns:
             NodeStateSEIR: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def top_k(self, k: int) -> NodeStateSEIR:
        """
        Compute the k largest values

        Arguments:
            k (int): The number of values to return

        Returns:
             NodeStateSEIR: The k largest values as a node state
        """

    def values(self) -> Iterator[Infected]:
        """
        Iterate over values

        Returns:
             Iterator[Infected]: Iterator over values
        """

class NodeLayout(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def get(self, node: NodeInput, default: Optional[list[float]] = None) -> Optional[list[float]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[list[float]]): the default value. Defaults to None.

        Returns:
            Optional[list[float]]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, list[float]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, list[float]]]: Iterator over items
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted_by_id(self) -> NodeLayout:
        """
        Sort results by node id

        Returns:
             NodeLayout: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def values(self) -> Iterator[list[float]]:
        """
        Iterate over values

        Returns:
             Iterator[list[float]]: Iterator over values
        """

class NodeStateF64String(object): 

    def __eq__(self, value):
        """Return self==value."""

    def __ge__(self, value):
        """Return self>=value."""

    def __getitem__(self, key):
        """Return self[key]."""

    def __gt__(self, value):
        """Return self>value."""

    def __iter__(self):
        """Implement iter(self)."""

    def __le__(self, value):
        """Return self<=value."""

    def __len__(self):
        """Return len(self)."""

    def __lt__(self, value):
        """Return self<value."""

    def __ne__(self, value):
        """Return self!=value."""

    def __repr__(self):
        """Return repr(self)."""

    def get(self, node: NodeInput, default: Optional[Tuple[float, str]] = None) -> Optional[Tuple[float, str]]:
        """
        Get value for node

        Arguments:
            node (NodeInput): the node
            default (Optional[Tuple[float, str]]): the default value. Defaults to None.

        Returns:
            Optional[Tuple[float, str]]: the value for the node or the default value
        """

    def items(self) -> Iterator[Tuple[Node, Tuple[float, str]]]:
        """
        Iterate over items

        Returns:
             Iterator[Tuple[Node, Tuple[float, str]]]: Iterator over items
        """

    def nodes(self) -> Nodes:
        """
        Iterate over nodes

        Returns:
            Nodes: The nodes
        """

    def sorted_by_id(self) -> NodeStateF64String:
        """
        Sort results by node id

        Returns:
             NodeStateF64String: The sorted node state
        """

    def to_df(self) -> DataFrame:
        """
        Convert results to pandas DataFrame

        The DataFrame has two columns, "node" with the node ids and "value" with
        the corresponding values.

        Returns:
            DataFrame: the pandas DataFrame
        """

    def values(self) -> Iterator[Tuple[float, str]]:
        """
        Iterate over values

        Returns:
             Iterator[Tuple[float, str]]: Iterator over values
        """
